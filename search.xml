<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Modbus协议_具体实现]]></title>
    <url>%2F2020%2F05%2F30%2FModbus%E5%8D%8F%E8%AE%AE-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式 一、搭建环境&amp;简介 采用的是stm32f103RBT6为例 从机实现采用 FreeModbus库 Modbus TCP通讯是基于 W5500 实现的 &emsp;&emsp;这里主要讲解的是Modbus从机(Server)的实现。因为实际产品常用于采集数据或做动作处理，一般是作为从设备，接入Plc(Modbus主机)。 二、Modbus主机(Master)&emsp;&emsp;Modbus主机一般很少用到。主要用途，一般用于：实际产品分为前后台，后台做所有的数据处理，作为Modbus从机；而前台主要用于做界面显示，即作为Modbus主机，界面数据修改通过串口Modbus通讯。 &emsp;&emsp;由于是前后台的内置通讯，常用的Modbus主机 当然是采用方便、可靠的 Modbus RTU通讯。 &emsp;&emsp;当然由于前后台通讯占用一个硬件串口Modbus通讯。因此，常见的Modbus从机，往往是具有多串口Modbus通讯，共享一套地址处理数据(当然，可能前后台内置通讯在实际产品说明书中被隐藏)。 &emsp;&emsp;Modbus主机，在网上是没有开源，只有收费版本的。其实只要根据Modbus协议，很容易就能写一个Modbus主机。 唯一需要注意的点：每个数据帧发送之间的间隔为 3.5T；防止从机接收到的数据黏合。 &emsp;&emsp;但是由于Modbus主机一般要处理其他事宜，往往本身每个数据帧发送之间的间隔都 &gt; 3.5T。因此实际上，写得不标准也能用；当然严谨一点的话，写一个定时器，发送就开启定时器，定时器溢出置标志位才能再次发送也是可以的。 三、Modbus从机(Slave)&emsp;&emsp;这里的Modbus从机是基于 FreeModbus库 实现的。 &emsp;&emsp;Freemodbus库的代码是写得很好的，如果C语言学得好，且对Modbus协议了解的话，建议直接看源码，多看多观察可以提高自己的代码水平。 3.1 FreeModbus移植(RTU模式)&emsp;&emsp;FreeModbus详细移植方法可以参照以下博主： FreeModbus在STM32上移植 STM32上移植FreeModbus详细过程 3.2 如何计算RTU模式的 3.5T 超时时间？波特率：每秒钟通过信道传输的信息量称为位传输速率，也就是每秒钟传送的二进制位数,简称比特率。 比特率：表示有效数据的传输速率，用b/s 、bit/s、比特/秒，读作：比特每秒。 通常的串口桢格式为10位：开始位1bit + 数据位8bit + 停止位1bit &emsp;&emsp;如9600b/s：指总线上每秒可以传输9600个bit；也就是说：在9600的波特率下，每秒可以传输出的桢数为：9600 / (1 + 8 + 1) = 960桢/秒，即960字节/秒(实际数据速率)； 反推：一帧或一字节数据需要的时间是多少呢？ 1s / 960 = 1.4ms 而ModBus协议中超时时间定为：3.5个帧长度为超时时间； 超时时间 = 3.5 * 1 / BaudRate / 10 秒 = 3.5 * 10 / BaudRate 秒 = 3.5 * 10 * 2 / BaudRate * 2 秒 = 70 / BaudRate * 2 秒 FreeModBus是这样实现的： 12345678910111213141516171819/* If baudrate &gt; 19200 then we should use the fixed timer values* t35 = 1750us. Otherwise t35 must be 3.5 times the character time.*/if( ulBaudRate &gt; 19200 )&#123; usTimerT35_50us = 35; /* 1800us. */&#125;else&#123; /* The timer reload value for a character is given by: * * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 ) * = 11 * Ticks_per_1s / Baudrate * = 220000 / Baudrate * The reload for t3.5 is 1.5 times this value and similary * for t3.5. */ usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );&#125; 波特率大于19200使用定值：1800us &emsp;&emsp;由于将usTimerT35_50us = 35;直接带入，在定时器驱动初始化实际代入的计算值为 (35 = 36-1)，因此实际的定时时间为：36 * 50(基值) = 1800 us。 波特率小于19200使用定值：1usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate ); 解析：由于Modbus的RTU模式是串口帧格式为11位，故 超时时间 (50us为单位) = 3.5 * 1 / BaudRate / 11 秒 = 3.5 * 11 / BaudRate 秒 = 3.5 * 11 * 2 / BaudRate * 2 秒 = 7 * 11 / BaudRate * 2 秒 = 7 * 11 * 1000000 / 50 / BaudRate * 2 (50us为单位) = 7 * 220000 / BaudRate * 2 (50us为单位) &emsp;&emsp;这usTimerT35_50us一个单位为50uS，将这个超时时间计算结果用于定时器驱动初始化。每中断一次为50us * usTimerT35_50us 微秒；且每次更改Modbus通信的波特率，Modbus的定时器驱动初始化都要更新一次，更新定时器计数溢出值。 四、 FreeModbus库源码&emsp;&emsp;3.1所提到的移植，是把RTU模式通讯的底层给移植好，报文中的具体数据单元处理功能函数还是得自己继续写。 &emsp;&emsp;但暂先不讲具体的数据单元处理功能函数写法，先讲解整个FreeModbus源码的实现过程，使其后面更清晰如何写数据单元处理功能函数，甚至可以自己移植、扩展改动(ASCII、TCP模式)。 4.1 实现的核心原理&emsp;&emsp;每一帧的数据区分是采用3.5T的方法。那么MCU具体的实现方法思路如下： &emsp;&emsp;使能串口接收中断，一但接收到数据(触发串口接收中断)，就开启定时器，每一次重新触发串口接收中断，就会重启定时器&amp;重新计数；直到不触发串口接收中断，导致定时器溢出，此时视为接收一帧完整数据，开始解析数据。再根据自己喜好响应主机的信息。 &emsp;&emsp;以上就是整体思路，你甚至可以根据这个思路自己实现Modbus通讯的从机部分。接下来就是FreeModbus同样思路实现方式的讲解 4.2 FreeModbus库通讯实现讲解(RTU模式为例) Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态 串口接收中断 在初始化状态下，打开定时器 等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将eMBPoll的 事件状态机 置为 初始化。 以上就是初始化完成，接下来就是数据收发的流程了 串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。 每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。 当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态 由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。 eMBPoll的 事件状态机 为Frame received接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功 核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 MB_EIO的错误。 经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为Execute function 执行数据函数(事件)。开始对数据进行处理。 这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。 如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 功能码|0x80 + 错误代码。 举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。 在处理完后会返回一个enum状态值。如果状态 不为MB_ENOERR，即内部使用的错误代码，根据内部使用的enum错误代码，switch生成 对外的错误代码 返回的CRC会在发送前先把CRC校验完成。 发送前，检查能不能数据接收，能接收则报硬件错误MB_EIO，因为协议规定只能单向收发 发送一个字节数据，然后开启发送中断，一直发送，直到完成 发送完成后，将 eMBPoll的 事件状态机 置为 发送完成 事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲 &emsp;&emsp;以上就是FreeModbus库实现Modbus RTU通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。这个库源码写的很好，如果是嵌入式新手，这份源码还是很推荐看的。 &emsp;&emsp;如果顺着程序缕是能看得懂的，这里再留一份函数==笔记==，方便小白初次看时疑惑，可查阅一下。 4.3 数据单元处理功能函数这里的写法思路分为3个部分： 第一部分函数用于对应FreeModbus库编写的处理函数 例如，库里面处理到最后，总是地址+1,；可以在这里去掉 这里用来区分 读、写 第二部分函数用于自己应用层的地址约束 并可以对不同地址块进行不同处理 第三部分函数用于具体地址的详细操作 4.3.1 数据单元初步处理&emsp;&emsp;编写具体如下四个函数对应FreeModbus库的处理： eMBRegCoilsCB eMBRegHoldingCB eMBRegDiscreteCB eMBRegInputCB12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/********************************************************************************* 函数名 : eMBRegCoilsCB* 功 能 : 线圈回复函数* 说 明 : none* 入 参 : *pucRegBuffer : 要添加到协议中的数据* usAddress : 线圈地址(PLC地址)* usNRegs : 要访问线圈的个数* eMode : 访问类型（MB_REG_READ为读线圈状态，MB_REG_WRITE为写线圈）* 返 回 : eStatus : 处理结果********************************************************************************/eMBErrorCode eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, eMBRegisterMode eMode )&#123; eMBErrorCode eStatus = MB_ENOERR; usAddress--;// 由PLC地址转为协议地址 switch ( eMode ) &#123; case MB_REG_READ: eStatus = AppFMD_RdCoils(usNCoils,usAddress,pucRegBuffer);break; case MB_REG_WRITE: eStatus = AppFMD_WrCoils(usNCoils,usAddress,pucRegBuffer);break; default:break; &#125; return eStatus;&#125;/********************************************************************************* 函数名 : eMBRegHoldingCB* 功 能 : 保持寄存器回复函数* 说 明 : none* 入 参 : *pucRegBuffer : 要添加到协议中的数据* usAddress : 寄存器地址* usNRegs : 访问寄存器的个数* eMode : 访问类型（MB_REG_READ为读保持寄存器，MB_REG_WRITE为写保持寄存器）* 返 回 : eStatus : 处理结果********************************************************************************/eMBErrorCode eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, eMBRegisterMode eMode )&#123; eMBErrorCode eStatus = MB_ENOERR; usAddress--;// 由PLC地址转为协议地址 if (eMode == MB_REG_READ) eStatus = AppFMD_RdRegs(usNRegs,usAddress,pucRegBuffer); if(eMode == MB_REG_WRITE) eStatus = AppFMD_WrRegs(usNRegs,usAddress,pucRegBuffer); return eStatus; &#125; 4.3.2 线圈和寄存器处理&emsp;&emsp;根据 4.3.1，只编写可读写线圈和寄存器的函数，具体对应函数如下： eMBErrorCode AppFMD_RdCoils(uint32_t si_num, uint32_t uiAddr, uint8_t *puc_txpointer) eMBErrorCode AppFMD_WrCoils(uint32_t si_num, uint32_t uiAddr,uint8_t *puc_txpointer) 最好在这块函数进行总的地址划分1234567891011121314151617181920212223242526272829303132333435363738/********************************************************************************* 函数名 : * 功 能 : * 说 明 : none* 入 参 : si_num : 待读的 线圈|寄存器 个数* uiAddr : 地址索引 从0起始* *puc_txpointer : 输出缓存* 返 回 : eStatus : 处理结果********************************************************************************/eMBErrorCode AppFMD_RdRegs(uint32_t lNum, uint32_t ulAddr,uint8_t *puc_txpointer)&#123; eMBErrorCode eStatus = MB_ENOERR; //内部参数 if(ulAddr&lt;1000) &#123; while(lNum) &#123; puc_txpointer = BuiltReadWord(ulAddr, puc_txpointer); lNum -= 1; ulAddr += 1; &#125; &#125; //用户自定义参数 else if(ulAddr&gt;=1000 &amp;&amp; ulAddr&lt;1400) &#123; while(lNum) &#123; puc_txpointer = BuiltReadWord_Double(ulAddr, puc_txpointer); lNum -= 2; ulAddr += 2; &#125; &#125; else eStatus = MB_ENOREG; return eStatus;&#125; 4.3.3 用户自定义的 线圈 &amp; 寄存器 处理&emsp;&emsp;根据 4.3.2，在对应的函数写具体到某个地址位的操作就行了。 五、通讯报文讲解&emsp;&emsp;这里是方便没接触过Modbus的人，或者是长时间没用急用，直接来查阅Modbus报文的；好清楚是哪里出的问题(主机 or 从机？)。 5.1 报文格式总结&emsp;&emsp;首先，如果从机是返回很短的(报错)报文，直接看功能码位，例如 0x83 ；去掉 &amp; 0x80 的操作，那就是 功能码 0x03 出现错误。 主机的读取数据命令(长度)是固定的：ID + 功能码 + 地址 + 数据长度 + CRC16 从机返回的数据格式不是固定的： 读取长度为1：ID + 功能码 + 数据长度 + 数据1 + CRC16 读取长度为2：ID + 功能码 + 数据长度 + 数据1 + 数据2 + CRC16 主机的写入数据格式不是固定的 从机返回数据格式(长度)是固定的(与上面的相反) 5.2 报文举例功能码0x03，读可读写模拟量寄存器： (主机)发送命令格式： [设备地址] [功能码03] [起始寄存器地址高8位] [低8位] [读取的寄存器数高8位] [低8位] [CRC校验低8位] [CRC校验高8位] 例：[11][03][00][6B][00][03][CRC低][CRC高] 意义如下： 11：设备地址，例子中的地址是11； 03：读模拟量的命令号固定为03，这是Modbus协议规定的。 00、6B：起始地址高8位（00）、低8位（6B）：表示想读取的模拟量的起始地址，比如例子中的起始地址为107。这个006B表示一个完整的地址，注意这里的地址是高8位在前，低8位在后。 00、03：寄存器数高8位（00）、低8位（03）：表示从起始地址开始读多少个模拟量（返回的每一个模拟量是用两个字节表示的）。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节同时这里的地址也是高8位在前，低8位在后。 [CRC低][CRC高]：帧尾的CRC-16校验，尤其需要注意的一点是校验结果的低8位在前，高8位在后，这个顺序不同于起始地址以及读取深度的地址顺序。 (从机)设备响应： [设备地址] [命令号03] [返回的字节个数][数据1][数据2]…[数据n][CRC校验的低8位] [CRC校验的高8位] 例：[11][03][06][02][2B][00][00][00][64][CRC低][CRC高] 意义如下： 11：设备地址（从机地址）； 03：功能码； 06：返回的字节个数（不高扩两字节的校验码）：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。数据1…n：其中[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。 [CRC低][CRC高]：CRC校验同上。 六、基于W5500的Modbus TCP&emsp;&emsp;如果是理解了上面源码的讲解，那么这里将会异常简单。由于W5500芯片，集成了硬件TCP/IP协议，数据接收完成与否的判断，也在W5500内完成；因此，FreeModbus库内的TCP函数大部分都不需要用到(例如，初始化函数)，只需要FreeModbus库的 TCP_Poll事件状态机(初始化要置位事件状态)。 &emsp;&emsp;先根据W5500的数据手册、或者例程，先编写好W5500的通讯驱动；程序中，读取W5500中断，如果有产生接收完成中断，就把TCP_Poll事件状态机置为接收完成，然后接下来就是TCP_Poll自己处理了，沿用同一套的数据单元处理功能函数。这样就完成了！ 七、FreeModbus库_拓展&emsp;&emsp;Freemodbus库虽然写得很好，但是它的思路框架是以1个通讯接口实现的。如果是在 Modbus主机 一节提到的：有多串口Modbus通讯，共享一套地址处理数据。当你多串口RTU通讯，且波特率不相同，定时器的配置也就要变动一下。甚至还有，一个实际产品，它不仅有Modbus 多串口通讯，它还可能要有Modbus TCP通讯，而且也还是共享一套地址处理数据。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Modbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modbus协议_概念讲解]]></title>
    <url>%2F2020%2F05%2F30%2FModbus%E5%8D%8F%E8%AE%AE-%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯 一、基本概念&emsp;&emsp;Modbus协议 是一个请求/应答协议，发起请求的为Master（client），响应请求的为Slave（server）;Modbus协议包括ASCII、RTU、TCP三种报文类型，并没有规定物理层。 &emsp;&emsp;标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。 Master端发出读数据请求消息，Slave端接收到正确消息后，就发送对应数据到Master端以响应请求； Master端发出写数据请求消息，Slave端接收到正确消息后，就修改Slave端的数据； 先发请求，再接收响应，从而实现 主机 对 从机 读/写操作。 二、报文格式_通用部分 (ADU)报文，指的是一串完整的指令数据；一个报文就是一帧数据，一个数据帧就一个报文 (MBAP)报文头，即报文的一部分，用于识别。当然也有些是部分数据在报文尾部，例如CRC数据校验。 (PDU)协议数据单元，这部分就是通信中的数据部分了。 举例如下： &emsp;&emsp;由于报文类型的不同，报文之间也存在一些差异。先讲解通用的 功能码 &amp; 错误代码 部分。 2.1 Modbus部分功能码 功能码（十六进制） 中文名称 位操作/字节操作 操作数量 错误功能码(&amp;0x80) 01 读线圈状态 位操作 单个或多个 0x81 02 读离散状态 位操作 单个或多个 0x82 03 读保持寄存器 字节操作 单个或多个 0x83 04 读输入寄存器 字节操作 单个或多个 0x84 05 写单个线圈 位操作 单个 0x85 06 写单个保持寄存器 字节操作 单个 0x86 0F 写多个线圈 位操作 多个 0x8F 10 写多个保持寄存器 字节操作 多个 0x90 &emsp;&emsp;Modbus协议规定，从机当执行对应功能码处理时发生错误，响应主机时需要将 功能码 & 0x80 将其返回。 2.2 错误代码表 代码 名称 含义 01 非法功能 对于服务器（或从站）来说，询问中接收到的功能码是不可允许的操作，可能是因为功能码仅适用于新设备而被选单元中不可实现同时，还指出服务器（或从站）在错误状态中处理这种请求，例如：它是未配置的，且要求返回寄存器值。 02 非法数据地址 对于服务器（或从站）来说，询问中接收的数据地址是不可允许的地址，特别是参考号和传输长度的组合是无效的。对于带有100个寄存器的控制器来说，偏移量96和长度4的请求会成功，而偏移量96和长度5的请求将产生异常码02。 03 非法数据值 对于服务器（或从站）来说，询问中包括的值是不可允许的值。该值指示了组合请求剩余结构中的故障。例如：隐含长度是不正确的。modbus协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。 04 从站设备故障 当服务器（或从站）正在设法执行请求的操作时，产生不可重新获得的差错。 05 确认 与编程命令一起使用，服务器（或从站）已经接受请求，并且正在处理这个请求，但是需要长持续时间进行这些操作，返回这个响应防止在客户机（或主站）中发生超时错误，客户机（或主机）可以继续发送轮询程序完成报文来确认是否完成处理。 07 从属设备忙 与编程命令一起使用，服务器（或从站）正在处理长持续时间的程序命令，当服务器（或从站）空闲时，客户机（或主站）应该稍后重新传输报文。 08 存储奇偶性差错 与功能码20和21以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器（或从站）设备读取记录文件，但在存储器中发现一个奇偶校验错误。客户机（或主机）可重新发送请求，但可以在服务器（或从站）设备上要求服务。 0A 不可用网关路径 与网关一起使用，指示网关不能为处理请求分配输入端口值输出端口的内部通信路径，通常意味着网关是错误配置的或过载的。 0B 网关目标设备响应失败 与网关一起使用，指示没有从目标设备中获得响应，通常意味着设备未在网络中。 ## 2.3 Modbus 寄存器地址分配 寄存器信息地址(PLC 地址) 适用功能码（十六进制） 寄存器种类 —- — —- 00001-09999 01 05 15 线圈状态 10001-19999 02 (开关)输入状态 30001-39999 04 输入寄存器 40001-49999 03 06 16 保持寄存器 ## 2.4 小总结(心得) &emsp;&emsp;一般情况下，只需要看一下返回的功能码就行了，错误代码可以不用看。Modbus通讯发生错误，往往出现的情况如下: 1. Modbus主机(PLC)读取有问题，例如读的地址写错，读的数据长度写错 2. Modbus从机压根就没写该 功能码 0r 地址 对应的处理，当主机对其操作自然报错。 3. 并不是符合Modbus协议规范的报文就一定通信正确，只能说是通讯成功，因为它返回给你一条报错指令。通讯无响应，说明是主机本身发的数据就有问题；通信有响应(可能返回错误报文)，说明该地址不可用，主机读歪了或者从机压根没写该功能处理。 三、各报文格式_详细解析&emsp;&emsp;每个报文都与其他报文格式有一定区分。在Modbus从机的角度看，讲解一下他们之间的类似之处。 三者功能码是通用的 RTU 和 TCP的报文十分类似。TCP由于是可靠的协议，且通过IP连接，相比RTU就少了 设备ID &amp; CRC数据校验。数据单元部分是完全一样的。 RTU &amp; ASCII 都是通过串口通讯的，因此都是需要 定时器。但是定时器具体用法不相同。 Ps：ASCII模式，国内基本没用到。常用的是 RTU &amp; TCP 模式。 3.1 RTU模式&emsp;&emsp;Modbus RTU协议中没有明显的开始符和结束符，而是通过帧与帧之间的间隔时间来判断的。如果在指定的时间内，没有接收到新的字符数据，那么就认为新的帧接收完毕。接下来就是处理数据。Modbus通过时间来判断帧接收完成，自然需要 MCU 的定时器配合(3.5T)。| 设备地址 | 功能代码 | 数据 | CRC校验 | 结束符(实际报文可没有这个！)| — | —- | — | —- | —| 1个字节 | 1个字节 | n个字节 | 2个字节 | T1-T2-T3-T4 地址码：每个从机都必须有唯一的地址码ID（从1到247，0是广播地址），并且只有符合地址码的从机才能响应回送。当从机回送信息时，相应的地址码表明该信息来自于何处。 功能码：主机发送的功能码告诉从机执行什么任务。ModBus通讯规约定义功能号为1到127。表2-1列出部分常用功能码，以备查询。 数据区：数据区包含需要从机执行什么动作或由从机采集的返送信息。应答包中，数据包括了数据字节长度+数据值，请求包中数据只包含数据值。 校验码：主机或从机可用校验码进行判别接收信息是否出错。 从Modbus主机角度上看 使用RTU模式，消息发送至少要以3.5个字符时间的停顿间隔开始（如上图的T1-T2-T3-T4所示）。传输的第一个域是设备地址。可以使用的传输字符是十六进制的0…9,A…F。网络设备不断侦测网络总线，包括停顿间隔时间内。当第一个域（地址域）接收到，每个设备都进行解码以判断是否发往自己的。在最后一个传输字符之后，一个至少3.5个字符时间的停顿标定了消息的结束。一个新的消息可在此停顿后开始。 一旦连续发送间隔 小于3.5T，就会对从机数据接收造成 数据黏合。 从Modbus从机角度上看 整个消息帧必须作为一连续的流传输，如果在帧完成之前有超过1.5个字符时间的停顿时间则为非法帧；如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续，这将导致一个错误，因为在最后的CRC域的值不可能是正确的。即帧之间的间隔必须大于3.5T，帧内字符的间隔必须小于1.5T。实际应用中1.5T一般不处理，只采用3.5T进行处理（FreeModBus开源代码就是这样)。 FreeModbus库，采用的是3.5T作为判断。只要是超过3.5T，就视为两个数据帧处理。当然，如果主机发送数据异常，让 某条报文中间字符发送相隔时间超过3.5T，那么就会造成 1条正确报文被分割成2条报文，造成 数据裂开。 数据裂开一般不会出现。采用FreeModbus库时，正常情况下，高波特率会对3.5T的值进行限制。如果解开该限制，导致3.5T实际值太小(高波特率转换计算出来)，这时候主机的字符发送间隔慢一点，从机将无法识别到正确的报文(数据被分裂)。 3.2 ASCII模式&emsp;&emsp;除了数据域为ASCII码，其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码下个域（地址域）来判断是否发给自己的。消息中字符间发送的时间间隔(MCU 的定时器)最长不能超过1秒，否则接收的设备将认为传输错误。 起始位 设备地址 功能代码 数据 LRC校验 结束符 ： 2个字符 2个字符 n个字符 2个字符 2个字符 &emsp;&emsp;使用ASCII模式，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH） 3.3 TCP/IP模式&emsp;&emsp;与MODBUS RTU相比，少了校验域和地址码，其中地址码被放到MBAP报文头里面了(即 00 00)，没有校验域是因为TCP本身就有校验所以省略了。 报文头MBAP，长度为7字节，组成如下： 事务处理标识 ：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文(主机要注意的点，从机不对该数据进行识别处理)。 协议标识符 ：00 00表示ModbusTCP协议。 长度 ：表示接下来的数据长度，单位为字节。 单元标识符 ：可以理解为设备地址。 事务处理标识 协议标识 长度 单元标识符 功能代码 数据 2字节 2字节 2字节 1字节 1字节 n字节 四、调试工具 如果你做的是Modbus Master，可以使用modbus slave工具模拟从设备来调试，该工具下载地址：Modbus Slave 如果你做的是Modbus Slave，可以使用modbus poll工具模拟主设备来调试，该工具下载地址：Modbus Poll 以上两个工具的使用方法，可以参考此博客：Modbus测试工具ModbusPoll与Modbus Slave使用方法]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Modbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这段时间的总结]]></title>
    <url>%2F2020%2F05%2F30%2F%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;好久没更新博客了= =？ &emsp;&emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。 &emsp;&emsp;然后偶然，又和高中老同学聊了聊；这回会持续更新，而且要加很多新内容！！！ &emsp;&emsp;继续加油，奥力给！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野指针]]></title>
    <url>%2F2020%2F03%2F15%2F%E9%87%8E%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、野指针由来1.1 野指针概念(简述)概述：“野指针”不是NULL指针，是指向“垃圾”内存的指针。(内存能不能用另外一回事) (局部)指针变量没有初始化 使用已经释放后的指针 指针所指向的变量在指针之前被销毁 1.2 野指针概念(专业描述) 指针未初始化&emsp;&emsp;指针变量在定义时不会自动初始化成空指针，而是随机的一个值，可能指向任意空间，这就使得该指针成为野指针。因此指针在初始化时要么指向一个合理的地址，要么初始化为NULL。即使不初始化，调用指针前，一定要赋值！ 指针指向的变量被free或delete后没有置为NULL&emsp;&emsp;在调用free或delete释放空间后，指针指向的内容被销毁，空间被释放，但是指针的值并未改变，仍然指向这块内存，这就使得该指针成为野指针。因此在调用free或delete之后，应将该指针置为NULL。 指针操作超过所指向变量的生存期&emsp;&emsp;当指针指向的变量的声明周期已经结束时，如果指针仍然指向这块空间，就会使得该指针成为野指针。这种错误很难防范，只有养成良好的编程习惯，才能避免这类情况发生。 1.3 野指针的要点(简单描述) 野指针通常是因为指针变量中保存的值不是一个合法的内存地址而造成的 野指针不是NULL，是一个指向不可用内存的指针 C语言中没有方法可以判断是否为野指针(可替换成NULL指针，NULL指针不容易弄错，可以通过if来判断是否为NULL指针) 1.4 野指针的要点(深度描述) 野指针只能避免而无法判断 &emsp;&emsp;无法判断一个指针是否为野指针，因为野指针本身有值，指向某个内存空间，只是这个值是随机的或错误的。 Ps：空指针并非野指针，它具有特殊性和确定性，可以进行判断；因此要避免在程序中出现野指针，可以做完操作及时将指针指向NULL。 野指针并非立马让系统出事 &emsp;&emsp;指针也是数据，首先如果是局部的，不置空也没关系反正用不到了；如果是全局的，得用的时候释放了可能也会立马再次新赋值，如果不是那肯定需要重置为null，这也是方便你后面的判断是否需要赋值，如果你再次用不到，那么(不重置)就完全不影响程序的健壮性。但是，如果 再调该(野)指针就会可能出现问题！ 有的可能比较复杂不一定开始就初始化，那你在某个地方用的时候会判断是否为空，然后给它赋值。就像很多做逻辑判断的bool，初始也会有值，如果没值，那你就看系统给的初始值，区别就是指针如果没初始化，然后对指针进行操作(调用)，可能会导致崩溃。也就是说，野指针并不是直接让系统出事，而是自己无意识产生野指针但还调用的操作才是让系统出事的真正原因！ 野指针的错误是严重的 指向不可访问的地址&emsp;&emsp;危害：触发段错误。 指向一个可用的，但是没有明确意义的空间&emsp;&emsp;危害：程序可以正确运行，但通常这种情况下，我们就会认为我们的程序是正确的没有问题的，然而事实上就是有问题存在，所以这样就掩盖了我们程序上的错误。 指向一个可用的，而且正在被使用的空间&emsp;&emsp;危害：如果我们对这样一个指针进行解引用，对其所指向的空间内容进行了修改，但是实际上这块空间正在被使用，那么这个时候变量的内容突然被改变，当然就会对程序的运行产生影响，因为我们所使用的变量已经不是我们所想要使用的那个值了。通常这样的程序都会崩溃，或者数据被损坏。 二、未初始化指针的神奇操作&emsp;&emsp;指针未初始化，系统一般会自动分配内存给未初始化的指针，但也有时候指向NULL。由于太过玄学，建议直接初始化置或一个有用的内存。 2.1 非字符串指针未初始化1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //分配内存时用到的头文件int main()&#123; int a=20,*p; //这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针 printf("%d-&gt;%p\n", a, p); //观察%p是输出一个地址数据 p=NULL; printf("%d-&gt;%p\n", a, p); p=&amp;a; printf("%d-&gt;%p：%d\n", a, p, *p); p=(int *)malloc(sizeof(int)); printf("%d-&gt;%p：%d\n", a, p, *p); *p=30; printf("%d-&gt;%p：%d\n", a, p, *p); return 0;&#125; 程序执行的结果如下： 1234520-&gt;(nil)20-&gt;(nil)20-&gt;0x7ffe4b25dc04：2020-&gt;0xfaa010：020-&gt;0xfaa010：30 2.2 字符串指针未初始化123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //分配内存时用到的头文件intint main()&#123; char *a="ShaTang"; char *p; //这里定义了一个字符串指针，但没赋初值，这时我们叫这个指针为野指针 printf("%s-&gt;%p\n", a, p); //观察%p是输出一个地址数据 p=NULL; printf("%s-&gt;%p\n", a, p); p=a; printf("%s-&gt;%p：%s\n", a, p, p); p=(char *)malloc(sizeof(char)); printf("%s-&gt;%p：%s\n", a, p, p); p="Zhu"; printf("%s-&gt;%p：%s\n", a, p, p); return 0;&#125; 程序执行的结果如下： 12345ShaTang-&gt;(nil)ShaTang-&gt;(nil)ShaTang-&gt;0x4006d4：ShaTangShaTang-&gt;0x134a010：ShaTang-&gt;0x4006f1：Zhu Ps：观察2.1和2.2，就会发现字符(数组)类型，引用数据和查看地址都是用指针。&emsp;&emsp;编译器此时帮我们把 未初始化指针 指向 NULL。我们对野指针的定义：指针指向垃圾(未知)的内存；在这里，我们就不能称它为野指针。 2.3 例1变形的玄学123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //分配内存时用到的头文件int main()&#123; int a=20; int *d1,*p;//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针 printf("%d-&gt;%p\n", a, p); //观察%p是输出一个地址数据 printf("%d-&gt;%p\n", a, d1); //观察%p是输出一个地址数据 p=NULL; printf("%d-&gt;%p\n", a, p); printf("%d-&gt;%p\n", a,d1); return 0;&#125; 编译器1，程序执行的结果如下： 123420-&gt;0x7ffde8b16b8020-&gt;0x4004f020-&gt;(nil)20-&gt;0x4004f0 编译器2，程序执行的结果如下： 1234-&gt;0x7fff890b4780-&gt;(nil)-&gt;(nil)-&gt;(nil) &emsp;&emsp;编译器此时分配内存给 未初始化指针，还是玄学分配,有时候置NULL(虚_野指针)，有时候又分配一块内存(真_野指针)。因此需要注意 要指针的初始化，或者调用时一定要(检查)赋值，带来不可估量的Bug。&emsp;&emsp;编译器1和编译器2对 例2.1 编译的结果都是一样的，但是对 例2.3 的编译结果却各不相同。但是反过来，只是简单变动，编译器就能玄学分配，这是很恐怖的事情。 三、野指针概念案例&emsp;&emsp;按照野指针的概念，举如下例子 例1：指针变量没有初始化12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1; //不初始化，此时指向NULL char *s2="Zhu"; // s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针// strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 编译器1，程序执行的结果如下： 120x7fffea4889f0 编译器2，程序执行的结果如下： 111 Segmentation fault &emsp;&emsp;这里不采用strcpy举例说明 指针变量没有初始化 的问题，后面单独一节再讲解原因。&emsp;&emsp;这里很明显，在编译器2上，printf打印 未初始化的指针，出现段错误(实际指针 指向NULL)。而编译器1，则是通过了，并得知编译器1给 未初始化的指针 赋了一块随机内存。你的代码在不同的编译器上，有的报错，有的通过，这也是野指针带来的危害。 例2：使用已经释放后的指针(释放后没改指向NULL)123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void func(char* p)&#123; printf("%s\n", p); free(p);&#125;int main()&#123; char* s = (char*)malloc(sizeof(char)); printf("%p\n", s); strcpy(s, "Delphi Tang"); func(s); printf("%s\n", s); //OOPS! printf("%p\n", s); return 0;&#125; 程序执行的结果如下： 12340x1f0e010Delphi Tang0x1f0e010 &emsp;&emsp;程序是可以正常执行的。但是在执行结果第三行：打印野指针指向的内存为空白。首先我们先重新明确上面的概念：“野指针”不是NULL指针，是指向“垃圾”内存的指针。内存的申请释放和指针没有太大关系，内存释放后，printf能正常打印出指针指向的地址，但是地址所在的内存内容就有问题了(为下次调用埋雷)。 例3：指针所指向的变量在指针之前被销毁123456789101112#include &lt;stdio.h&gt;char* func()&#123; char p[] = "Delphi Tang"; return p;&#125;int main()&#123; char* s = func(); printf("%s\n", s); //OOPS! return 0;&#125; &emsp;&emsp;在我测试用的多个编译器，结果都不相同；局部变量在函数执行完，内存是已经释放的，还调用指向该内存的指针，即野指针调用；造成的结果在每个编译器都不太相同。 四、strcpy引发的段错误&emsp;&emsp;很多人讲解 未初始化的指针 导致的 野指针的时候，很多实例代码都是用到strcpy来讲解 指针未初始化 的问题。这是很不严谨的，从上面的案例分析，稍微改下代码，系统就能分配一块内存 或者 置NULL。 4.1 错误的例子112345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1; //不初始化，此时指向NULL char *s2="Shatang"; // s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针 strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 编译器1，程序执行的结果如下： 12Shatang0x7ffc79832540 编译器2，程序执行的结果如下： 111 Segmentation fault 在编译器2环境下，注释strcpy(s1 , s2);和printf("%s\n", s1);，程序执行的结果如下： 1(nil) &emsp;&emsp;也就说，用strcpy来举例 未初始化指针 的问题是有问题的。当编译器给 未初始化指针 置NULL时，这时候已经不算是野指针了，反而会出现段错误；当随机分配内存，编译却通过了，说明这个问题跟野指针无关，这是由strcpy引发的段错误。 4.2 strcpy语法strcpy的语法如下： 1strcpy(char* dest, const char *src); 被覆盖的 dest首先是个变量，变量就必须有内存存放；而一个指向NULL的指针没有指向任何内存。没有内存，怎么存储覆盖过来的值？ &emsp;&emsp;或者来个更直接的： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1=NULL; //不初始化，此时指向NULL char *s2="Shatang"; // s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针 strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 所有的编译器程序执行的结果如下： 112 Segmentation fault 4.3 错误的例子212345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char *s1="Shatang"; char *s2="Zhu"; strcpy(s1 , s2); // OOPS! printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; &emsp;&emsp;注意：这里我们将字符串指针初始化，指向一块明确内存(不是野指针了)；但程序执行还会报 理所应当的 Segmentation fault的错误。strcpy函数的dest是一个变量，不能指向字符串常量；字符串常量存放在内存位置的字符常量区(详情看内存知识)， 字符串指针指向这个区域，而且这个区域是一个const 属性的不可修改的；因此 再进行拷贝覆盖的时候会出现段错误。 4.4 正确的例子112345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char s1[10]="Shatang"; char *s2="Zhu"; strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 程序执行的结果如下： 12Zhu0x7ffff41e089e 4.5 正确的例子212345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *s1; //不初始化，此时指向NULL char *s2="Zhu"; s1=(char *) malloc(sizeof(char)); //重新分配一块内存给指针 strcpy(s1 , s2); printf("%s\n", s1); printf("%p\n", s1); return 0;&#125; 程序执行的结果如下： 12Zhu0x144e010 &emsp;&emsp;由此可见strcpy引发的段错误，并非是野指针引起的；而是编程人对strcpy的用法不了解导致的。 4.6 得出来的结论&emsp;&emsp;只要调用该指针前，先把指针赋值指向对应的内存，就不会影响到系统的健壮性。如果严谨一点，还是把对指针进行 初始化赋值 或 置为NULL吧！ (抽风编译器牛逼!) 五、经典野指针错误&emsp;&emsp;野指针犯错方式是花式的、神奇的。随着编译器的不同，野指针造成的结果也不相同；甚至在同一个编译器下，你定义变量的数量不同，多一个或少一个，系统就可能让 未初始化的指针 置NULL或者是分配随机内存。野指针，强就强在，随机神秘翻车！不仅如此，还是编译通过的后续翻车(关键点)！！！ &emsp;&emsp;因此，大家也不要对野指针编译的结果不同太诧异。具体的错误例子可以看 内存分配方式 一节内容。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>野指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配方式]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、内存分配方式&emsp;&emsp;一个由C/C++编译的程序占用的内存分为以下几个部分： 栈区（stack）：由编译器自动分配释放 ；存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） ： 一般由程序员分配释放； 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 全局区(静态区)(static)：程序结束后有系统释放；全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 文字(字符)常量区 ：程序结束后由系统释放；常量字符串就是放在这里的。 程序代码区 ：存放函数体的二进制代码。 二、例子程序123456789101112131415161718192021222324int a = 0; //全局初始化区char *p1; //全局未初始化区main()&#123; int b; //栈 char s[] = "abc"; //栈 char *p2; //栈 char *p3 = "123456";//123456在常量区，p3在栈上 static int c =0； //全局（静态）初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); //申请分配得来的10和20字节的区域就在堆区 strcpy(p1, "123456"); //123456放在常量区 //编译器可能会将它与p3所指向的"123456"优化成一个地方&#125; 三、堆和栈的理论知识3.1 申请方式 stack：由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 heap：需要程序员自己申请，并指明大小(在c中为，malloc函数) 例如，p1 = (char *)malloc(10); Ps： 但是要注意p1本身是在栈中的。 3.2 申请后系统的响应栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 3.3 申请大小的限制栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 3.4 申请效率的比较栈：由系统自动分配，速度较快。但程序员是无法控制的。 堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. &emsp;&emsp;另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 3.5 堆和栈的存储内容栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 &emsp;&emsp;当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 3.6 存取效率的比较12char s1[] = "aaaaaaaaaaaaaaa";char *s2 = "bbbbbbbbbbbbbbbbb"; aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。比如： 1234567891011121314#include &lt;stdio.h&gt;void main()&#123; char a = 1; char c[] = "1234567890"; char *p ="1234567890"; a = c[1]; a = p[1]; return;&#125; 对应的汇编代码： 1234567891011121310: a = c[1];00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]0040106A 88 4D FC mov byte ptr [ebp-4],cl11: a = p[1];0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]00401070 8A 42 01 mov al,byte ptr [edx+1]00401073 88 45 FC mov byte ptr [ebp-4],al &emsp;&emsp;第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 3.7 小结堆和栈的区别可以用如下的比喻来看出：&emsp;&emsp;使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。&emsp;&emsp;使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 内存分配方面： 堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 申请方式方面： 堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 系统响应方面： 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 大小限制方面： 堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 效率方面： 堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。栈：由系统自动分配，速度较快。但程序员是无法控制的。 存放内容方面： 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 存取效率方面： 堆：是在编译时就确定的；栈：是在运行时赋值的； char *s1 = "Hello Word";char s1[] = "Hello Word";&emsp;&emsp;用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。 四、C++的内存分配方式&emsp;&emsp;在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多） 五、内存分配方式引发的概念区别(C)5.1 只读变量和常量下面的例子用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？ 12const int n = 5;int a[n]; 答案与分析:1）这个问题讨论的是“常量”与“只读变量”的区别。常量肯定是只读的，例如 5， “abc”，等，肯定是只读的，因为程序中根本没有地方存放它的值(存放在字符常量区，不可修改，只读)，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时维度必须是“常量”，“只读变量”也是不可以的。2）注意：在ANSI C中，这种写法是错误的，因为数组的大小应该是个常量，而const int n,n只是一个变量（常量 != 不可变的变量，但在标准C++中，这样定义的是一个常量，这种写法是对的），实际上，根据编译过程及内存分配来看，这种用法本来就应该是合理的，只是 ANSI C对数组的规定限制了它。3）那么，在 ANSI C 语言中用什么来定义常量呢？答案是enum类型和#define宏，这两个都可以用来定义常量。 5.2 指针 和 字符串常量请问下面的代码有什么问题？ 123char *p = "i'm hungry!";p[0]= 'I'; 答案与分析：&emsp;&emsp;上面的代码会造成内存的非法写操作。分析如下， “i’m hungry”实质上是字符串常量，而字符串常量被编译器放在只读的字符常量区内，不可写。指针p初始化，指向这个只读的内存区，是不能修改其中元素值(即存放值)；而p[0] = 'I';则企图修改内存存放值，编译器当然不会答应。 123char *p = "i'm hungry!";p = "I'm hungry!";printf("%s\n",p); &emsp;&emsp;虽说字符串常量(字符常量区)内容不可修改，但指针是变量，可以修改指针p指向的内存位置；即实际上又找了一个新的字符串常量(新申请在字符常量区)。 5.3 字符串数组 和 字符串常量12345char a[15] = "i'm hungry!";char *p = &amp;a;p[0]= 'I';printf("%s\n",p); 答案与分析： &emsp;&emsp;相比较与5.2，由于字符串数组是存放在 栈 或 堆 ，该区是可以修改的，因此对字符串(数组,这里不是常量)的元素可以修改。 5.4 指针 &amp; 内存&emsp;&emsp;往往别人在教指针知识的时候，往往强调指针存放着地址，并举出类似下面的例子： 123int *p;p = (int*)0x12ff7c;printf("%x\n",p); 程序结果如下： 112ff7c &emsp;&emsp;的确是能够打印出来，0x12ff7c是在前面随便打印一个int类型变量的地址获取的。但是如果给这个内存进行赋值操作的话，就会出现 段错误。 12345int *p;p = (int*)0x12ff7c;printf("%x\n",p);*p = 100; &emsp;&emsp;地址和内存是两回事！！！每段内存都有自己的地址，地址映射可以通过指针操作；但是，你无权更改内存存放的值，除非这段内存是 栈 或 堆 分配给你的。需要注意：有地址，没空间(字符常量区也是这样)。 Ps： 如果有地址就能合法操作对应内存空间，那还要什么(手动)内存分配。 六、内存知识的重新总结一个程序分为： 栈区（stack） –编译器自动分配释放，主要存放函数的参数值，局部变量值等； 堆区（heap） –由程序员分配释放； 全局(静态)区 –存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区(.data)和全局未初始化区(.bss)； 字符常量区(.rodata) –常量字符串放与此，程序结束时由系统释放； 程序代码区(.text) 栈 ：(后进先出)栈在程序中用于维护函数的调用上下文；栈保存了一个函数调用所需要的维护信息。 1)函数参数，函数返回地址 2)局部变量 3)函数调用上下文堆：(堆内存需要主动申请)为什么有了栈还需要堆？ 1)栈上的数据在函数返回后就会被释放掉，无法传递到函数外部，如局部变量(关键原因) 2)堆是程序中一块巨大的内存空间，可由程序自由支配 3)堆中被程序申请使用的内存在程序主动释放前将一直有效(全局)静态存储区： 1)程序的静态存储区随着程序的运行而分配空间，直到程序运行结束 2)在程序编译期间静态存储区的大小就已经确定 3)程序的静态存储区主要用于保存程序中的全局变量和静态变量 4)与栈和堆不同，静态存储区的信息最终会保存在可执行程序中七、 非法内存操作分析7.1 指针没有初始化进行内存操作12345678910111213141516#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123; int* d1; int i=0; for(i=0;i&lt;10;i++)//问题1：不能直接赋值，因为并没有分配内存，也没有初始化。 &#123; d1[i]=i+1; &#125; printf("%d-&gt;%p\n", *(d1+6), d1); return 0;&#125; 编译器1，程序执行的结果如下： 17-&gt;0x7ffeaaf62970 编译器2，程序执行的结果如下： 111 Segmentation fault &emsp;&emsp;这里理所应当地出现两种情况： 出现段错误，则是编译器自动将指针置NULL 编译通过的，则是 野指针 7.2 没有给指针分配足够的内存123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123; int *d2; int i=0; d2=(int *)calloc(5,sizeof(int)); for(i=0;i&lt;10;i++)//问题2：只分配了5个空间，却用了10个。 &#123; d2[i]=i+1; &#125; printf("%d-&gt;%p\n", *(d2+6), d2); free(d2); printf("%d-&gt;%p\n", *(d2+6), d2); return 0;&#125; 编译器1，程序执行的结果如下： 127-&gt;0x1b3d010*** Error in `./a.out': free(): invalid next size (fast): 0x0000000001b3d010 *** 编译器2，程序执行的结果如下： 127-&gt;0x16020104113-&gt;0x1602010 &emsp;&emsp;这里会出现free()操作 非法(没有分配)的内存；还有个编译器神奇通过(野指针的恐怖之处)。 7.3 内存分配成功但是没有初始化1234567891011121314#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int main()&#123; char* s=(char*)malloc(5); s[0]='A'; //s[1]='\0'; s[2]='B'; printf("%s\n",s); printf("%p\n",s); free(s); return 0;&#125; 编译器程序执行的结果如下： 12A0x14e5010 &emsp;&emsp;需要注意的是，上面虽然编译通过但是是有问题的。犯这个错误往往是由于没有初始化的概念或者是以为内存分配好之后其缺省初值自然为0。未初始化指针变量也许看起来不那么严重，但是它确确实实是个非常严重的问题，而且往往出现这种错误很难找到原因。(尤其在字库驱动) &emsp;&emsp;内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，但这点在不同的编译器上会有不同的实现。所以好的做法，是手动给数组赋上初值。 &emsp;&emsp;当你只分配内存给字符(串)型指针，并没有缺省初值，严格意义上来讲是不算初始化；有些编译器自然里面都是'\0'，printf打印时，打印出来的数据自然会被其中字符的'\0'截胡。不然可以把上述例子的注释去掉再测试一遍。 也许这种严重的问题并不多见，但是也绝不能掉以轻心。所以在定义一个变量时，第一件事就是初始化。你可以把它初始化为一个有效的值。 7.4 内存(数组)越界数组有两个特性，影响作用在数组上的函数： 不能复制数组； 使用数组名时， 数组名会自动指向其第一个元素的指针。 因为不能复制，所以无法编写使用数组类型的形参，数组会自动转化为指针。123456789101112131415void f(int a[10])//这里面的[10]仅表示我们希望数组是多大；实际没有用处，传入是指针&#123; int i=0; for(i=0;i&lt;10;i++) &#123; a[i]=i; printf("%d\n",a[i]); &#125;&#125;int main()&#123; int a[5]; f(a); return 0;&#125; 编译器程序执行的结果如下： 123456789100123456789 数组作为形参时的一个陷阱：在数组当形参的函数中，使用sizeof来计算传入的实参数组的大小。但是当数组作为形参的时候，其退化为一个指针，如果sizeof其数组名将计算的是一个指针的大小！ 7.5 内存泄漏1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void f(unsigned int size)&#123; int* p = (int*)malloc(size*sizeof(int)); int i = 0; if( size % 2 != 0 ) &#123; return; //奇数个size的情况直接跳转，但申请的内存没有free掉；内存泄漏 &#125; for(i=0; i&lt;size; i++) &#123; p[i] = i; printf("%d\n", p[i]); &#125; free(p);&#125;int main()&#123; f(9); f(10); return 0;&#125; 解决方法：当函数申请了内存：采用单入口，单出口程序 1234567891011121314void f(unsigned int size)&#123; int* p = (int*)malloc(size*sizeof(int)); int i = 0; if( size % 2 == 0 ) &#123; for(i=0; i&lt;size; i++) &#123; p[i] = i; printf("%d\n", p[i]); &#125; &#125; free(p);&#125; 7.6 多次释放指针1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void f(int* p, int size)&#123; int i = 0; for(i=0; i&lt;size; i++) &#123; p[i] = i; printf("%d\n", p[i]); &#125; free(p); //第1次&#125;int main()&#123; int* p = (int*)malloc(5 * sizeof(int)); f(p, 5); free(p); //第2次 return 0;&#125; 多次释放内存的后果，就是强退出 Ps：分配多次完全可以，既然是变量那就是可变的！但是多次释放就是自杀！ 7.7 使用已经释放的内存1234567891011121314151617181920212223//这个和前面的例子有点类似#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void f(int* p, int size)&#123; int i = 0; for(i=0; i&lt;size; i++) &#123; printf("%d\n", p[i]); &#125; free(p);&#125;int main()&#123; int* p = (int*)malloc(5 * sizeof(int)); int i = 0; f(p, 5); for(i=0; i&lt;5; i++) &#123; p[i] = i; // OOPS! &#125; return 0;&#125; 八、C语言有关内存的规则8.1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针12345int *p=(int *)malloc(5*sizeof(int));if(p!=NULL)&#123;&#125;free(p); 8.2 牢记数组长度，防止数组越界操作，考虑使用柔性数组1234567891011121314typedef struct _soft_array&#123; int len; int array[];&#125;SoftArray;int i=0;SoftArray* sa=(SoftArray*)mallo(sizeof(SoftArray)+sizeof(int)*10);sa-&gt;len=10;for(i=0;i&lt;sa-&gt;len;i++)&#123; sa-&gt;array[i]= i + 1;&#125; 8.3 动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放 Ps：可以用if…else…来确定是否释放 123456789101112131415void f()&#123; int *p= (int*)malloc(sizeof(int)); free(p);&#125;int main()&#123; int *p= (int*)malloc(sizeof(int)); f(); free(p); return 0;&#125; 8.4 free指针之后必须赋值为NULL12345678910111213141516int *p=(int*)(malloc(sizeof(int));free(p);p=NULL;//···//······//·········//············if(p!=NULL)&#123; int i=0; for(i=0;i&lt;5;i++) &#123; p[i]=i; &#125;&#125; 九、嵌入式的内存分配&emsp;&emsp;通常应用程序可以调用ANSI C编译器的malloc()和free()函数来动态的分配和释放内存，但多次这样的操作会把原来很大的一块连续存储区域逐渐地分割成许多非常小并且彼此不相邻的存储区域，这就是存储碎片。 &emsp;&emsp;malloc( )属于标准C语言函数，当然可以在单片机上使用，如STM32可以先在启动文件中设置heap的大小，再使用动态内存分配： 1Heap_Size EQU 0x00000200 //也就是 512字节 &emsp;&emsp;但是在嵌入式(裸机)中最好不要这么做，一般单片机的内存都比较小，而且没有MMU(内存管理管理单元),多次的malloc 与free的使用容易造成内存碎片。当后面因为空间不足而分配失败，从而导致系统崩溃，因此应该慎用，或者自己实现内存管理。除了UCOS或FREERTOS等嵌入式操作系统有自带的MMU处理外，裸机长时间连续工作产生的内存碎片为系统工作稳定埋下隐患。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>堆栈</tag>
        <tag>野指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大小端和联合体]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、大小端1.1 大小端含义&emsp;&emsp;大端小端的含义可以看这位博主的：轻松记住大端小端的含义(附对大端和小端的解释) 1.2 大端小端哪里用到？&emsp;&emsp;当涉及到数据拆解(例如一个32位数据拆分成两个16位数据来用) 的时候，就需要注意大小端。因为我们一般存数据和取数据都是一个一个或着一组一组，不会涉及到拆分数据，这样就不涉及大小端。 &emsp;&emsp;举个例子，当你有一个int类型的数据，你不是把数据直接取出来，而是把int变量中的一个字节数据提取出来，想做一些类似位操作的操作。当一个数据拆解取出来的时候，就会设计到数据的存储顺序，即大小端。 &emsp;&emsp;但是，由于一般现在所用的cpu基本上是采用的小端模式。基本上，平常撸代码都不会被涉及(影响到)到，因此简单了解一下其概念就行。以下的情况才有可能是被大小端模式影响到： 在(不熟悉的)平台撸代码，用到union之类的语法。发现读写数据出现异常 正常稳定的代码，迁移新的平台。发现读写数据出现异常 二、联合体联合体：使几个不同类型的变量共占一段内存(相互覆盖)。所占内存长度是各最长的成员占的内存长度。结构体：把不同类型的数据组合成一个整体。所占内存长度是各成员占的内存长度的总和。 &emsp;&emsp;由于嵌入式C基本都是用小端模式：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。小端就是我们(平常逻辑)认知的顺序，因此后面(默认小端)不再提及大小端对联合体的影响。 寄存器(联合体和结构体的妙用) 先声明一个结构体 12345678910//结构体中的冒号表示位域//位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节//同时也是为了节省存储空间和方便处理。typedef struct&#123; uint16_t Mode1:1; //Mode1配置占1位 uint16_t Mode2:3; //Mode2配置占3位 uint16_t Mode3:4; uint16_t Mode4:2; //写满16位&#125;Ctl_Bits; 再声明一个联合体 12345union TBCTL_REG&#123; uint16_t all; Ctl_Bits bit;&#125; 可以再申明一个寄存器结构体： 12345typedef struct&#123; union TBCTL_REG TBCTL1; union TBCTL_REG TBCTL2;&#125;PWM_REGS; 这样的话，我就写了一个关于PWM配置的寄存器，例如我现在想改PWM的Mode1为模式1；如下： 123456PWM_REGS PWM1;//整体赋值PWM1.TBCTL1.all |= 0x01;//位赋值PWM1.TBCTL1.bit.Mode1 = 0x01； &emsp;&emsp;理解了这个方法后，再来看样例对寄存器的操作是不是就很轻松了？掌握这个方法以后，你也可以设计一个带全局或者位操作的结构体来完成自己的程序数据的应用了。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>大小端</tag>
        <tag>联合体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体]]></title>
    <url>%2F2020%2F03%2F15%2F%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、关于c语言的结构体&emsp;&emsp;首先我们为什么要用到结构体，我们都已经学了很多int、 char…等类型，还学到了同类型元素构成的数组；以及取上述类型的指针，在一些小应用可以灵活使用。然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是结构体的好处。 二、结构体小知识 只有结构体变量才分配地址，而结构体的声明是不分配空间的； 结构体声明，包括了结构体中各成员的声明，因此也不分配空间； c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换 相同类型的成员是可以声明在同一类型下的1234567struct Student&#123; int number,age；//int型学号和年龄 char name[20],sex;//char类型姓名和性别 float score;&#125;；//最后的分号不要忘了 总结：声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 int 分配内存一样。只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。 结构体类型的变量的本质：结构体类型的变量，本质上是一个变形的数组。 不同点：结构体不要求元素类型一样，要用的时候，不是以数组下标，而是特定指向(.或->)该成员来 处理（例如赋值）； 相同点： 结构体和数组在定义的时候不进行初始化赋初值，则后面就不能全部赋初值，需逐个赋值； 进行 数组、结构体变量 初始化的时候，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋初值前面几个； 进行 数组、结构体变量 初始化的时候，对于未初始化(后半段)的数据：如果是数值型，则会自动赋值为 0 ；如果是字符型，会自动赋初值为 NULL ，即\0 ；即不足的元素补以默认值； 函数的传入参数(形参)是结构体、数组，均采用指针传递的方式123456789typedef struct &#123; char name[20]; char sex; int number;&#125;Student；Student stu1=&#123;"zhaozixuan",'M'&#125;;int str[10]=&#123;1&#125;;//这里只是把str的第一个元素赋值为1，其他元素默认为0 &emsp;&emsp;这里要强调的一点是， “变量赋值” 和 “变量初始化(赋初值)”不是一回事！给(全局)变量初始化，定义时后跟等号，等号后面是初始化值。赋初值只会在定义的时候进行赋初始化值，其余地方都是赋值。 赋初值 和 赋值 的区别 赋值运算，函数体外是不允许的；而赋初值没有该要求，可在函数体外定义赋初值。 赋初值，可以初始化所有成员；赋值，只能对逐个成员进行赋值，无法一次性对全体成员进行赋值。(举例：数组、结构体) 三、结构体变量的定义和引用3.1 结构体类型的变量&emsp;&emsp;在编译时，结构体的声明并不分配存储空间；声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 int 分配内存一样；只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。 123456789 struct Book &#123; char title[20];//一个字符串表示的titile 题目 char author[20];//一个字符串表示的author作者 float value;//价格表示 &#125;;//这里只是声明 结构体类型struct Book book1,book2;//结构体变量的定义 分配空间book1.value;//引用结构体变量 &emsp;&emsp;定义结构体变量以后，系统就会为其分配内存单元，比如book1和book2在内存中占44个字节（20+20+4）具体的长度你可以在你的编译器中使用sizeof关键字分别求出来。 3.2 结构体空洞&emsp;&emsp;用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍；比方说我们上面求得的为44 为 float(4个字节)的整数倍，但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48(4的整数倍)。 这就涉及到结构体的存储： 结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍； 结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍(一般是int,4字节)，如果不是编译器会自动补齐； &emsp;&emsp;在结构体分配空间时，如果结构体中出现4个字节(32位)及以上的变量时，给每个变量分配空间时都是按字对齐分配的(就是按4个字节，4个字节来分配)；如果结构体中没有出现4个字节以上变量，则按半字对齐(按 2个字节，2个字节。。来分配)。&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储(字对齐或双字对齐等)。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。&emsp;&emsp;看来鱼与熊掌还是不能兼得啊。既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单地(手动计算)相加。因为他们中间存在空洞。 关于偏移量，简单介绍下： 结构体偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小；第一个成员的偏移量为0。 123456struct S1&#123; char a; int b; double c;&#125;; 这里 char a 偏移量为 1 之后为 int b 因为偏移量 1 不为int(4)的整数倍，所以会自动补齐，而在 double c 时，偏移量为 8 是int(4)的整数倍，所以不用自动补齐，最后求得结构体得大小为 16。 四、结构体变量的初始化&emsp;&emsp;结构体的初始化有很多需要注意的地方，这里我们说明下，首先是几种初始化的方法。 Ps： 在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋值前面几个，对于后面未赋值的变量，如果是数值型，则会自动赋值为0；对于字符型，会自动赋初值为 NULL ，即 \0 。 4.1 定义时直接赋值(变量初始化)1234567891011121314struct Student&#123; char name[20]; char sex; int number;&#125;stu1=&#123;"zhaozixuan",'M',12345&#125;;//或者struct Student&#123; char name[20]; char sex; int number;&#125;；struct Student stu1=&#123;"zhaozixuan",'M',12345&#125;; 注意： 字符为 ' ' ，字符串为 " " 4.2 定义结构体之后逐个赋值1234567//赋值操作均在函数内操作stu1.name="王伟"；stu1.sex='M';stu1.number=12305;//也可用strcpy函数进行赋值strcpy(stu1.name,"王伟"); 4.3 定义之后任意赋值12345struct Student stu1=&#123; .name="Wang", .number=12345, .sex='W', &#125;;//可以对任意变量赋值 &emsp;&emsp;这样写的好处时不用按照顺序来进行初始化，而且可以对你想要赋值的变量直接进行赋值，而不想赋值的变量可以不用赋值。&emsp;&emsp;需要注意的是，如果在定义结构体变量的时候没有初始化，那么后面就不能全部一起初始化了。(数组性质) 4.4 typedef 说明结构体类型&emsp;&emsp;typedef 为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。 12345typedef struct tagMyStruct //这里也可以不写tagMyStruct&#123; int iNum; long lLength;&#125;MyStruct; &emsp;&emsp;上面的tagMyStruct是标识符，MyStruct是变量类型(相当于 int , char 等)。 这语句实际上完成两个操作： 定义一个新的结构类型 12345struct tagMyStruct&#123; int iNum; long lLength; &#125;; 分析：tagMyStruct 称为“tag”，即“标签”，实际上是一个临时名字，不论是否有 typedef struct 这个关键字 和 tagMyStruct 一起，构成了这个结构类型，这个结构都存在。我们可以用 tagMyStruct varName 来定义变量；但要注意，使用 tagMyStruct varName 来定义变量是不对的，因为 struct 和 tagMyStruct 合在一起才能表示一个结构类型。 typedef为这个新的结构起了一个名字，叫MyStruct。 1typedef struct tagMyStruct MyStruct; &emsp;&emsp;因此，MyStruct实际上相当于 struct tagMyStruct ，我们可以使用 MyStruct varName 来定义变量。 12345typedef struct tagMyStruct&#123; int iNum; long lLength;&#125;MyStruct; 在C中，这个申明后申请结构变量的方法有两种：(1) struct tagMyStruct 变量名(typedef声明时可省略tagMyStruct，省略后则无法使用该方法定义结构变量)(2) MyStruct 变量名(一般采用该方法) 五、结构体变量的引用(结构体成员) 结构体类型 声明定义的是 普通变量，普通变量 访问成员时就用 . 结构体类型 声明定义的是 指针 ，指针 访问成员时就用 -> Ps： 若使用指针对结构体成员进行访问，格式为：指针-&gt;成员名 等价于 (*指针).成员名 但是有几点需要注意：(1) .是运算符，在所有运算符优先级中最高(2)如果结构体的成员本身是一个结构体，则需要继续用.运算符，直到最低一级的成员。 12345678910111213141516typedef struct &#123; char name[20]; char sex; int number; struct Date &#123; int year; int month; int day; &#125;birthday;&#125;Student;Student Stu1;//定义结构体变量printf("%d",stu1.birthday);//这样子是错误的，因为birthday也是一个结构体变量scanf("%d",&amp;stu1.birthday.month);//正确 六、结构体数组及其初始化(重点)&emsp;&emsp;这里我们简单说下，具有相同类型的结构体变量组成数组就是结构体数组。反而言之，是指数组中的每个元素都是一个结构体。在实际应用中，结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。 123456789101112struct Student&#123; char name[20]; char sex; int number;&#125;stu1[5]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;, &#123;"wangwei",'M',14679&#125;, &#123;"yulongjiao",'W',17857&#125;&#125;; 当对结构体数组中全部元素赋值时，也可不给出数组长度，例如： 123456789101112struct Student&#123; char *name;//指针类型指向字符串 char sex; int number;&#125;stu1[]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;, &#123;"wangwei",'M',14679&#125;, &#123;"yulongjiao",'W',17857&#125;&#125;; Ps：在上面的Tip提到，结构体是一个变形的数组；结构体数组，其实就是变形的二元数组；数组的性质同样也是存在：结构体数组要在定义时就直接初始化赋值，不然后面再全部赋值是错误的。 1234567891011121314//错误的示例struct Student stu1；stu1[3]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;&#125;; //正确的示例 struct Student stu1[]=&#123; &#123;"zhaozixuan",'M',12345&#125;, &#123;"houxiaohong",'M',12306&#125;, &#123;"qxiaoxin",'W',12546&#125;&#125;; 数组初始化 1234567891011//错误示范char str[20];str="I love you"; //这样会修改数组的地址，原因如下//数组初始化后，地址分配是固定的，数组名是(符号)地址常量；常量没有(可写的)内存空间存你要赋的值//因此数组名不能作为左值//所以我们可以把str[i]当左值，而无法把str当左值。//正确示范char *str;str="I love you"; &emsp;&emsp;在第一条语句中 str 就已经被定义成数组，而在C99标准中不允许将字符串(实际上是一个指针变量)赋值给数组(左值)，所以如果我们直接赋值是错误的。 注意区分声明时的初始化和普通的赋值语句！！！ 赋值运算 &emsp;&emsp;赋值运算，分为左值和右值。 左值：可以出现在赋值语句的左边或右边，它不光有值，还有一个存储地址； 右值：只能出现在赋值语句的右边，认为它只有一个值的大小，没有存储地址，只关心它的值(字符串常量则是存在字符常量区，只可读不可写)。 数组名不可能作为左值！数组名不是指针！ &emsp;&emsp;那么数组名应该如何理解呢？用来存放数组的区域是一块在栈中静态分配的内存(非static)，而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且，还是一个不可修改的常量，完整地说，就是一个地址常量。 &emsp;&emsp;数组名跟枚举常量类似，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。注意了！不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址，这就是数组名属于符号常量的意义所在。 &emsp;&emsp;由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，那么，数组名永远都不会是指针！ 这里提供数组赋(字符串)值的3种方法： 定义数组时直接定义 1char str[20] = "I love you"; 用strcpy进行复制 12char str[20];strcpy(str,“I love you”); 用memset进行复制 123//memset&lt;/code&gt;语法介绍void *memset(void *s,int c,size_t n)//作用：将已开辟内存空间s的首n个字节的值设为值c。 3.1 如果是字符类型数组的话，memset可以随便用，如下所示： 12char str[20];memset(str,'a',20); 3.2 但是对于其他类型的数组，一般只用来清0或者填-1，如果是填充其他数据就会出错，如下所示： 12int str[10];memset(str,1,sizeof(str));//这样是错误的 3.3 错误分析 - &lt;code&gt;memset&lt;/code&gt;在进行赋值时，是按字节为单位来进行赋值的，每次填充的数据长度为一个字节； - 对于其他类型的变量，比如int，占4个字节 所以sizeof(str)=40； - 用memset赋值时，将会对指向str地址的前40个字节进行赋值0x01（00000001） 的操作；**把0x00000000赋值4次0x01操作变为&lt;code&gt;0x01010101&lt;/code&gt;**(错误主要原因)； - 相当于给 “(所有)10个int” 进行了赋值&lt;code&gt;0x01010101&lt;/code&gt;的操作 对应十进制的16843009，所以会出很大的错误。 用指针（注意内存分配方式） 12char *str；str = "I love you"; &emsp;&emsp;这两句话的本质是， 在内存中开辟一段内存空间(字符常量区)，把"I love you"放进这段内存空间，然后把这段内存空间的地址交给str，由于str是变量(栈 或 堆)，所以给它赋值(地址，指向的内容)是合法的。 memset用法总结：如果是清零一个数组用memset还是很方便的；简单赋字符串值，用strcmp函数(或memset)就行。 七、结构体与指针&emsp;&emsp;指针指向的是变量所占内存的首地址，在结构体中，指针指向的是结构体变量的起始地址，当然也可指向结构体变量的元素。 7.1 指向结构体变量的指针12345678struct Student&#123; char cName[20]; int number; char csex; &#125;student1;struct Student *p;p=&amp;student1; 简单来说以下三种形式是等价的 123p-&gt;cName //可以进行正常的运算(*p).cName //这里的括号不能少，.运算符优先级最高student1.cName &emsp;&emsp;这里需要注意的是，结构体访问成员方式和数组访问成员方式有些差别。 即使*p访问到了结构对象的第一个成员变量a，也不能保证*(p+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 (用sizeof作为偏移量访问下一个成员要注意一下结构体空洞吖！) 7.2 指向结构体数组的指针&emsp;&emsp;在我们想要用指针访问结构体数组的第n个数据时可以用 12345678910struct Student&#123; char cName[20]; int number; char csex; &#125;;struct Student stu1[5];struct Student*p;p=stu[n];(++p).number//是指向了结构体数组下一个元素的地址 7.3 结构体成员是指针类型变量123456struct Student&#123; char* Name;//这样防止名字长短不一造成空间的浪费 int number; char csex; &#125;student1; 在使用时可以很好地防止内存被浪费，但是注意在引用时一定要给指针变量分配地址，如果你不分配地址，结果可能是对的(野指针)，但是Name会被分配到任意的一地址，指针为字符串分配任何内存存储空间具有不确定性，这样就存在潜在的危险。 12345678struct Student&#123; char* Name; int number; char csex; &#125;stu，*stu；stu.name=(char*)malloc(sizeof(char));//内存初始化 所对应的指针类型结构体成员要相应初始化分配内存 12345678struct Student&#123; char* Name; int number; char csex; &#125;stu,*stu;stu = (struct student*)malloc(sizeof(struct student));./*结构体指针初始化*/stu-&gt;name = (char*)malloc(sizeof(char));/*结构体指针的成员指针同样需要初始化*/ &emsp;&emsp;实际上，结构体指针、结构体成员指针就是指针，没有区别；只不过结构体成员指针容易被忽略初始化。而指针的初始化是很重要的，详情可以看 野指针一章的内容。 7.4 结构体嵌套的问题结构体的自引用(self reference)，就是在结构体内部，包含指向自身类型结构体的指针。结构体的相互引用（mutual reference），就是说在多个结构体中，都包含指向其他结构体的指针。 7.4.1 自引用 结构体 不使用 typedef 错误的方式：1234struct tag_1&#123; struct tag_1 A; int value;&#125;; &emsp;&emsp;这种声明是错误的，因为这种声明实际上是一个无限循环，成员A是一个结构体，A的内部还会有成员是结构体，依次下去，类似于永无出口的递归调用。在分配内存的时候，由于无限嵌套，也无法确定这个结构体的长度，所以这种方式是非法的。 正确的方式：(使用指针)1234struct tag_1&#123; struct tag_1 *A; int value;&#125;; &emsp;&emsp;由于指针的长度是确定的（在32位机器上指针长度为4），所以编译器能够确定该结构体的长度。 Ps：这个指针看似指向自身，其实不是，而是指向同一类型的不同结构。链表和树的数据结构就都使用到此技巧。自身的结构体指针指向下一节点或者下一子树的地址。 使用 typedef 错误的方式：1234typedef struct &#123; int value; NODE *link; &#125;NODE; &emsp;&emsp;这里的目的是使用typedef为结构体创建一个别名NODE。但是这里是错误的，因为此时还没定义完类型名，而在结构体内部引用了结构类型名，是非法的。 正确的方式：(使用不完全声明)有三种，差别不大，使用哪种都可以123456789101112131415161718typedef struct tag_1&#123; int value; struct tag_1 *link; &#125; NODE;//虽然 C 语言编译器完全支持这种做法，但不推荐使用以下的第2种typedef struct tag_2 NODE;struct tag_2&#123; int value; NODE *link; &#125;;//建议使用以下的第3种struct tag_3&#123; int value; struct tag_3 *link; &#125;;typedef struct tag_3 NODE; 7.4.2 相互引用 结构体 错误的方式：123456789typedef struct tag_a&#123; int value; B *bp; &#125;A;typedef struct tag_b&#123; int value; A *ap;&#125;B; &emsp;&emsp;错误的原因和上面一样，这里类型B在定义之前 就被使用。 正确的方式：(使用不完全声明)1234567891011121314151617181920212223242526//推荐使用第一种struct tag_a&#123; struct tag_b *bp; int value;&#125;;struct tag_b&#123; struct tag_a *ap; int value;&#125;;typedef struct tag_a A;typedef struct tag_b B;struct tag_a; struct tag_b;typedef struct tag_a A;typedef struct tag_b B;struct tag_a&#123; struct tag_b *bp; int value;&#125;;struct tag_b&#123; struct tag_a *ap; int value;&#125;; 7.5 结构体作为函数参数(形参)将结构体传递给函数的方式有如下3种： 用结构体的单个成员作为函数参数，向函数传递结构体的单个成员（属于传值调用，不会影响相应的实参结构体的值） 用结构体变量做函数参数，向函数传递结构体完整结构（属于传值调用，不会影响相应的实参结构体的值） 用结构体指针或结构体数组作函数参数属于模拟按引用调用，会影响相应的实参结构体的值,向函数传递结构体地址，因为仅复制结构体首地址一个值给被调函数，相对于第二种方式，这种传递效率更高 补充：传值调用与模拟按引用调用（参数传递） 按值调用：将程序将函数调用语句中的实参的一份副本传给函数的形参模拟按引用调用：指针作为函数的参数，虽然实际上也是传值给被调用函数，但是传给被调用函数的这个值不是变量的值，而是变量的地址，通过向被调用函数传递某个变量的地址值可以在被调函数中改变主调函数中这个变量的值，相当于模拟C++中的按引用调用因此称为模拟按引用调用 &emsp;&emsp;使用结构体变量作为函数参数的时候，是采取传值调用，将结构体所占内存单元的内容全部传递给形参，并且形参必须也要是同类型的结构体变量，在使用时，会自动创建一个结构体变量作为原变量的副本，并且也需要占内存，效率较低。且无法修改实际的结构体变量中成员的值。 &emsp;&emsp;如果用指针作为实参，传递给函数的形参，这时候传递的是结构体变量的地址，形参所指向的地址就是结构体变量的地址，这时候进行修改的话是可以修改的(这正是指针的精华所在)。 7.6 结构体的一些小技巧7.6.1 互换结构体在这里我们再提供几种互换两个结构体的方法： 结构体指针互换地址 直接互换值(同类型结构体) 比较笨的方法：用for循环互换123456789101112131415161718192021222324typedef struct Student&#123; char cName[20]; int number; char csex; &#125;Student;Student student1=&#123;"Wang",12345,'W'&#125;;Student student2=&#123;"Zhao",54321,'M'&#125;; Student *stu1=&amp;student1;Student *stu2=&amp;student2;//法1Student *stu3;stu3=stu1;stu1=stu2;stu2=stu3;//法2struct stu student3;student3=student1;student1=student2;student2=student3; 7.6.2 meset的妙用&emsp;&emsp;最后提下memset清空结构体： 123456struct Student&#123; char cName[20]; int number; char csex; &#125;stu1; 一般情况下，清空str的方法： 123 str.cName[0]='\0'; str.csex='0'; str.number=0; 但是我们用memset就非常方便： 1memset(&amp;str,0,sizeof(struct Student)); 如果是数组，就是： 12struct Student stu[10];memset(stu,0,sizeof(struct Student)*10); 八、拓展(待写)二叉树遍历算法二叉树的二叉链表类型定义如下： 1234typedef struct btnode&#123; datatype data; struct btnode *lchild,*rchild;&#125;； 九、友情链接多亏主要如下几位网友的资料结构体嵌套中的问题c语言结构体学习整理(结构体初始化，结构体指针)结构体中定义函数指针结构体（结构体嵌套、结构体指针、结构体参数传递）]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体的洞和 #pragma pack]]></title>
    <url>%2F2020%2F03%2F15%2F%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B4%9E%E5%92%8C-pragma-pack%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、结构体中的“洞”&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。看来鱼与熊掌还是不能兼得啊。 &emsp;&emsp;既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单的相加。因为他们中间存在空洞。 二、#pragma pack&emsp;&emsp;这是给编译器用的参数设置，有关结构体字节对齐方式设置， #pragma pack是指定数据在内存中的对齐方式。 1234567#pragma pack (n) //作用：C编译器将按照n个字节对齐。#pragma pack () //作用：取消自定义字节对齐方式。#pragma pack (push,1)//作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐#pragma pack(pop)//作用：恢复对齐状态 #pragma pack(push,1)与#pragma pack(1)的区别 &emsp;&emsp;因此可见，加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优。但是很多时候两者差别不大，如： 1234#pragma pack(push) //保存对齐状态#pragma pack(4) //设定为4字节对齐//相当于 #pragma pack (push,4) 具体的使用方法如下： 1234#pragma pack (1) //结构体内容#pragma pack ()//作用：调整结构体的边界对齐，让其以一个字节对齐；&lt;使结构体按1字节方式对齐&gt; 具体例子如下： 1234567#pragma pack(1)struct sample&#123; char a; double b;&#125;;#pragma pack() &emsp;&emsp;注：若不用#pragma pack(1)和#pragma pack()括起来，则sample按编译器默认方式对齐（成员中size最大的那个）。即按8字节（double）对齐，则sizeof(sample)==16.成员char a占了8个字节（其中7个是空字节）；若用#pragma pack(1)，则sample按1字节方式对齐sizeof(sample)＝＝9.（无空字节），比较节省空间啦。在有些场合还可使结构体更易于控制。 三、应用实例&emsp;&emsp;在网络协议编程中，经常会处理不同协议的数据报文。一种方法是通过指针偏移的方法来得到各种信息，但这样做不仅编程复杂，而且一旦协议有变化，程序修改起来也比较麻烦。 &emsp;&emsp;在了解了编译器对结构空间的分配原则之后，我们完全可以利用这一特性定义自己的协议结构，通过访问结构的成员来获取各种信息。这样做，不仅简化了编程，而且即使协议发生变化，我们也只需修改协议结构的定义即可，其它程序无需修改，省时省力。下面以TCP协议首部为例，说明如何定义协议结构。其协议结构定义如下： 123456789101112131415161718192021#pragma pack(1) // 按照1字节方式进行对齐struct TCPHEADER &#123; short SrcPort; // 16位源端口号 short DstPort; // 16位目的端口号 int SerialNo; // 32位序列号 int AckNo; // 32位确认号 unsigned char HaderLen : 4; // 4位首部长度 unsigned char Reserved1 : 4; // 保留6位中的4位 unsigned char Reserved2 : 2; // 保留6位中的2位 unsigned char URG : 1; unsigned char ACK : 1; unsigned char PSH : 1; unsigned char RST : 1; unsigned char SYN : 1; unsigned char FIN : 1; short WindowSize; // 16位窗口大小 short TcpChkSum; // 16位TCP检验和 short UrgentPointer; // 16位紧急指针&#125;; #pragma pack() &emsp;&emsp;这样的代码编译出来的是以1个字节的方式对齐的。这样能节约内存资源，但是会在效率上有所影响。 &emsp;&emsp;虽说在效率上有一定的影响，不过，如果编写的是基于协议，如网口、串口通讯的程序，最好严格按照一定的规则进行接收数据包。使用 #pragma pack(1)，让数据在内存中是连续的，实现结构体通过指针偏移(没有空洞)比较好处理。 &emsp;&emsp;用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，有时候为了内存对齐需要补齐空字节。通常写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。 &emsp;&emsp;也就是如果用编译器的(自动)对齐策略，采用指针偏移方式的方法可能会出现一些(不同编译器，对齐不同，错位)问题。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>结构体</tag>
        <tag>字节对齐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于函数指针的 强制转换 & void指针]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-void%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、大佬链接 和 结论&emsp;&emsp;下面链接是这篇博文的主力大佬，我只是润润色。函数指针的强制类型转换与void指针关于函数指针类型强制转换的一些摸索 先说结论： 函数指针的指针参数只是一个标记，总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。 换一种说法，函数指针中的形参最后使用的效果只由函数指针指向的实际函数的形参类型决定，中间处理过程只是作为一个没有类型的32位或者16位二进制数来处理。效果跟函数指针申明的形参没有多大关系。 我们在使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参保持一致。 二、 常见的情况2.1 函数指针常见用法123456789101112131415161718#include "stdio.h"/* 真实函数fun_int */void fun_int(int *p_fun)&#123; printf("整数:%d\n", *p_fun);&#125;int main()&#123; int i = 200; /* 真实整数变量 */ int* p_i = &amp;i; /* 整数指针 */ void (*f_ptr)(int *p_fun); /* 函数指针 */ f_ptr = fun_int; /* 函数指针赋值 */ f_ptr(p_i); return 0;&#125;c 运行结果如下： 1整数:200 &emsp;&emsp;总之就是，定义一个包含返回值类型和参数的函数指针，然后把一个返回值类型，参数类型及个数都相同的函数名（即地址）赋值给这个函数指针，这个函数指针就可以当成普通函数用了。 2.2 函数指针强制类型转换&emsp;&emsp;此处只展示一种情况：函数指针和真实函数的返回值及参数个数都相同，只有参数类型不同。 12345678910111213141516171819202122#include "stdio.h"/* 真实函数fun_float */void fun_float(float *p_fun)&#123; printf("小数:%f\n", *p_fun);&#125;int main()&#123; int i = 20000; /* 真实整数变量 */ int* p_i = &amp;i; /* 整数指针 */ float f = 9.999f; /* 真实浮点变量 */ float* p_f = &amp;f; /* 浮点指针 */ void (*f_ptr)(int *p_fun); /* 函数指针 */ f_ptr = (void (*)(int *))fun_float; /* 函数指针强制类型转换 */ f_ptr(p_i); /* 传入int指针 */ f_ptr((int *)p_f); /* 传入float指针 */ return 0;&#125; 运行结果如下： 12小数:0.000000小数:9.999000 &emsp;&emsp;此时我们可以发现一件有趣的事情：尽管函数指针f_ptr的参数是int，但传入的int指针打印数据不正常（正常为20000），而类型不匹配的float指针却是对的（9.999）。 对此我总结了两点： 函数指针的指针参数只是一个标记（或者说只是一个保存指针的地址？），总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。 我们在使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参个数保持一致。 2.3 以void指针作为参数的函数指针&emsp;&emsp;结合之前的结论，在函数指针中包含指针参数时，都可以用void指针进行替代（如果类型很明确就另当别论，直接写）。 123456789101112131415161718192021222324252627282930#include "stdio.h"/* 真实函数fun_int */void fun_int(int *p_fun)&#123; printf("整数:%d\n", *p_fun);&#125;/* 真实函数fun_float */void fun_float(float *p_fun)&#123; printf("小数:%f\n", *p_fun);&#125;int main()&#123; int i = 20000; /* 真实整数变量 */ int* p_i = &amp;i; /* 整数指针 */ float f = 9.999f; /* 真实浮点变量 */ float* p_f = &amp;f; /* 浮点指针 */ void (*f_ptr)(void *p_fun); /* 函数指针 */ f_ptr = (void (*)(void *))fun_int; /* 强制为void* */ f_ptr(p_i); f_ptr = (void(*)(void *))fun_float; /* 强制为void* */ f_ptr(p_f); return 0;&#125; 运行结果如下： 12整数:20000小数:9.999000 &emsp;&emsp;如此一来，只需要在函数指针赋值时进行强制类型转换就可以适应不同的真实函数。在调用时只要保证以void指针作为参数的函数指针结论中的第2点(形参个数保持一致)即可。 三、参数个数不同的函数指针&emsp;&emsp;这一块的知识简单了解一下就行。太内核了，从外面看就是玄学。 3.1 “运气”例子代码如下： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; typedef void (*F1)(int, int);typedef void (*F2)(int); void ff1(int a, int b)&#123; printf("ff1\n"); printf("%d,%d\n", a, b);&#125; void ff2(int a)&#123; printf("ff2\n"); printf("%d\n", a);&#125;int main()&#123; F1 f1 = (F1)ff2; f1(1,2); F2 f2 = (F2)ff1; f2(3); return 0;&#125; = =本人运行结果如下： 1234ff21ff13,2147483646 原本例子的运行结果如下： 1234ff21ff13,2 &emsp;&emsp;从运行结果中可以看到，当函数ff2被强制转换成一个F1类型的函数后，ff2的形参a的取值为F1类型函数的第一个形参的值，这里说明程序在执行的时候，如果该函数为一个只有n个形参的函数，如果你传递给他m个形参（n&lt;=m）,则该函数只会使用前n个形参。至于这里为什么可以允许这样的操作，后面将试探的分析一下。 &emsp;&emsp;接着，我们试图把一个ff1类型的函数，强制转换为一个F2类型的函数，并执行，执行结果还是在上面的图中，可以看到函数ff1的运行结果为3，2。 &emsp;&emsp;问题来了，我明明只传递给ff1这个函数1个参数，但为什么编译器没报错？虽然类型经过了强制转换，也许可以骗过编译器，但是在执行的时候，明明少了一个参数，程序执行的时候为什么也不报错？而且第二个参数的值还比较诡异，从打印的情况看，第二个参数为2，该值正是调用ff2的时候传递的第二个参数，该参数没被ff2处理，这里却被ff1处理，神马情况？ 3.2 测试”运气”&emsp;&emsp;首先，有一点，当每个函数被调用时，都被赋予了相对独立的栈空间，当该函数的生命周期结束后，该栈空间同时也被回收。 &emsp;&emsp;这样，当我们的main函数执行后，main函数有一个栈空间，假设为mem_A。那么根据上述实验结果，我这里有一个猜想，关于函数的参数是如何实现传递的。我的猜想是这样的，main函数在mem_A的栈空间中单独保留了一块类存给参数传递使用，假设该类存空间为mem_B。当一个函数运行时，程序把需要传递的参数按照顺序，放置在mem_B中，且每次都是从头开始放置。 &emsp;&emsp;回到刚刚的实验中，当ff2被执行后，mem_B中应该存放着0x00000001和0x00000002，这时再执行ff1，由于这里把ff1强制转换成了只含有一个形参的函数，所以当我们只传递给ff1一个参数3时，mem_B中应该存放着0x00000003和0x00000002，这样，ff1调用的结果可以符合以上输出结果，这里为了确定这样的结果不是巧合，又进行了数次实验，均与以上猜想相符。按照以上猜想，如果ff1先执行，ff2后执行，则ff1的第二个参数应该为一个随机数，为了验证该想法，又进行了如下实验。 其他代码都一样，就是把两个函数的执行顺序掉了一下顺序，输出结果下： 12345678910int main()&#123; F2 f2 = (F2)ff1; f2(3); F1 f1 = (F1)ff2; f1(1,2); return 0;&#125; 本人和原例运行类似，结果如下： 1234ff13,-417232744ff21 &emsp;&emsp;也就是说，现在的编译器则是另外开辟栈空间。由于是另外开辟的情况，无法验证第二位博主的： 参数的存储是以4字节为一个存储单元的，也就是说当一个char类型的变量作为参数传递，在mem_B中占的内存大写依旧为4字节。 3.3 (无卵用)总结&emsp;&emsp;由于不能复现之前博主的情况，也无法确定他的结论。但是也有发现： 12345678910int main()&#123; F1 f1 = (F1)ff2; f1(1,2); F2 f2 = (F2)ff1; f2(3); return 0;&#125; 本人运行结果如下： 1234ff21ff13,2147483646 &emsp;&emsp;无论如何改动f1中的第二个参数，最后打印的随机值都不会发生变化。但是如果更换成ff2先执行，ff1后执行，该值就会随着f1中的第二个参数变化而变化。 简单分析，按照程序执行顺序： 如果先执行：多形参的函数；会多开辟多的栈空间，但是由于被强转为单形参，另外一个形参值则为一个随机值。后面执行单形参函数，开辟的栈小，多出来的形参会影响到之前双形参的栈空间存放值。 如果先执行：单形参函数；实际的栈开辟小，打印出来的随机值则不受第二个形参输入的影响(不是明确关系，值波动很大)。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>强制转换</tag>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_的_函数（函数指针）]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、函数指针的概念1.1 什么是函数指针&emsp;&emsp;如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。 函数指针 和 函数名 本质上是一样的，都是指向函数调用地址的指针； 只是 函数名 是常量指针，函数指针 是变量指针。 1.2 如何定义函数指针&emsp;&emsp;那么这个指针变量怎么定义呢？ 虽然同样是指向一个地址，但指向函数的指针变量和指向变量的指针变量的定义方式是不同的。例如： 1int(*p)(int, int); &emsp;&emsp;这个语句就定义了一个指向函数的指针变量p。首先它是一个指针变量，所以要有一个“*”，即（*p）；其次前面的 int 表示这个指针变量可以指向返回值类型为int型的函数；后面括号中的两个int表示这个指针变量可以指向有两个参数且都是int型的函数。所以合起来这个语句的意思就是：定义了一个指针变量p，该指针变量可以指向返回值类型为int型，且有两个整型参数的函数。p的类型为int(*)(int，int)。 所以函数指针的定义方式为： 函数返回值类型 (* 指针变量名) (函数参数列表); “函数返回值类型”表示该指针变量可以指向具有什么返回值类型的函数； “函数参数列表”表示该指针变量可以指向具有什么参数列表的函数。这个参数列表中只需要写函数的参数类型即可。 1.3 注意要点 函数指针定义时，(*指针变量名)”两端的括号不能省略 &emsp;&emsp;我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“（*指针变量名）”。但是这里需要注意的是：“(*指针变量名)”两端的括号不能省略，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数(指针函数)。 如何判断 指针变量 是 指向 变量 还是 函数 ？ 首先看变量名前面有没有“*”，如果有“*”说明是指针变量； 其次看变量名的后面有没有带有形参类型的圆括号，如果有就是指向函数的指针变量，即函数指针，如果没有就是指向变量的指针变量； 最后需要注意的是，指向函数的指针变量没有 ++ 和 – 运算。 二、举例&emsp;&emsp;函数指针怎么用？ 2.1 调用例子要点分为两个: 指针 赋值 为函数地址： 函数指针是需要把一个函数的地址赋值给它，有两种写法： 12fun = &amp;Function；fun = Function; 取地址运算符&不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。 调用 函数指针： 调用函数指针的方式也有两种： 12x = (*fun)();x = fun(); &emsp;&emsp;调用函数的写法(*func)()、func()均可；而我们大多数情况下都会写成前者(看上去和普通的函数调用没啥区别)，应该是（C/C++标准制定者）为了方便大家对函数的调用。如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。 简单例子 123int Func(int x); /*声明一个函数*/int (*p) (int x); /*定义一个函数指针*/p = Func; /*将Func函数的首地址赋给指针变量p*/ 赋值时函数 Func 不带括号，也不带参数。 由于函数名Func代表函数的首地址，因此经过赋值以后，指针变量 p 就指向函数 Func() 代码的首地址了。 2.2 实际例子1234567891011121314151617181920212223242526# include &lt;stdio.h&gt;int Max(int, int); //函数声明int main(void)&#123; int(*p)(int, int); //定义一个函数指针 int a, b, c; p = Max; //把函数Max赋给指针变量p, 使p指向Max函数 printf("please enter a and b:"); scanf("%d%d", &amp;a, &amp;b); c = (*p)(a, b); //通过函数指针调用Max函数 printf("a = %d\nb = %d\nmax = %d\n", a, b, c); return 0;&#125;int Max(int x, int y) //定义Max函数&#123; int z; if (x &gt; y) &#123; z = x; &#125; else &#123; z = y; &#125; return z;&#125; 输出结果是： 1234please enter a and b:3 4a = 3b = 4max = 4 三、函数指针的优点&emsp;&emsp;有的通用函数中要涉用到另一个函数，但函数名称未定，是让用户编的，当然要做成函数指针，即API（application programming interface，应用编程接口）。函数指针的优点，其实就是函数指针的应用：回调函数 回调函数，本质上都是“你想让别人的代码执行你的代码，而别人的代码你又不能动”这种需求下产生的。 举例1 &emsp;&emsp;别人给你的不是源代码，是一个已经编译好的模块，并且不会给你源代码，那是商业机密，留给你一个接口，你把你要执行的代码以回调函数的形式交给这个接口，由别人编写的模块在需要的时候调用。 举例2 &emsp;&emsp;进行通用定积分计算，被计算函数是待定的，是由调用者确定的函数，这也得是函数指针。 四、回调函数&emsp;&emsp;对指针的应用是C语言编程的精髓所在，而回调函数就是C语言里面对函数指针的高级应用。简而言之，回调函数是一个通过函数指针调用的函数。 函数指针和函数名本质上是一样的，都是指向函数调用地址的指针； 只是函数名是常量指针，函数指针是变量指针。 4.1 回调函数的定义&emsp;&emsp;把函数指针（函数的入口地址）传递给另一个函数(的形参)，当这个函数指针被用来调用它所指向的函数时，我们就说这个函数是回调函数。 4.2 回调函数的意义(简易) 其他情况：当一个函数要调用另外一个函数，直接在函数体调用对应的函数； 回调情况：当一个函数要调用另外一个函数，将另外函数的指针作为形参，当需要调用对应函数时，调用指针进而可调用对应函数。 &emsp;&emsp;很多朋友可能会想，为什么不像普通函数调用那样，在回调的地方直接写函数的名字呢？这样不也可以吗？为什么非得用回调函数呢？在网上看到解析回调函数的很多例子，其实完全可以用普通函数调用来实现的。 &emsp;&emsp;要回答这个问题，我们先来了解一下回到函数的好处和作用：那就是解耦。对，就是这么简单的答案，就是因为这个特点，普通函数代替不了回调函数。 &emsp;&emsp;当你在库函数传入其他函数指针，只要函数指针的函数类型相同，就能做到改动函数指针指向的函数功能，而且还不影响传入(函数)指针形参的库函数(不需要改动)。甚至你可以调用同类型的函数指针 传入 库函数。(例如多驱动，Uart4和Uart5两个串口驱动，只要传入函数指针变动传入指针就行)。 4.3 回调函数的意义(深入)&emsp;&emsp;函数指针的语法理解上并不难，难就难在对函数指针实现设计模式和设计方法上的运用。 原因在于，难的不是函数指针的概念和语法本身，而是在什么时候，什么地方该使用它。函数指针不仅是语法上的问题，更重要的是它是一个设计范畴。真正的高手当然不单应该懂得语法层面上的技巧，更应该懂得设计上的方法。不懂设计，能算高手吗？怀疑我在夸大其辞吗？那我们先看看函数指针与哪些设计方法有关： 与分层设计有关。分层设计早就不是什么新的概念，分层的好处是众所周知的，比较明显好处就是简化复杂度、隔离变化。采用分层设计，每层都只需关心自己的东西，这减小了系统的复杂度，层与层之间的交互仅限于一个很窄的接口，只要接口不变，某一层的变化不会影响其它层，这隔离了变化。 分层的一般原则是，上层可以直接调用下层的函数，下层则不能直接调用上层的函数。这句话说来简单，在现实中，下层常常要反过来调用上层的函数。比如你在拷贝文件时，在界面层调用一个拷贝文件函数。界面层是上层，拷贝文件函数是下层，上层调用下层，理所当然。但是如果你想在拷贝文件时还要更新进度条，问题就来了。一方面，只有拷贝文件函数才知道拷贝的进度，但它不能去更新界面的进度条。另外一方面，界面知道如何去更新进度条，但它又不知道拷贝的进度。怎么办？常见的做法，就是界面设置一个回调函数给拷贝文件函数，拷贝文件函数在适当的时候调用这个回调函数来通知界面更新状态。 与抽象有关。抽象是面向对象中最重要的概念之一，也是面向对象威力强大之处。面向对象只是一种思想，大家都知道，用C语言一样可以实现面向对象的编程。这可不是为了赶时髦，而是一种实用的方法。如果你对此表示怀疑，可以去看看GTK+、linux kernel等开源代码。 接口是最高级的抽象。在linux kernel里面，接口的概念无处不在，像虚拟文件系统(VFS)，它定义一个文件系统的接口，只要按照这种接口的规范，你可以自己开发一个文件系统挂上去。设备驱动程序更是如此，不同的设备驱动程序有自己一套不同的接口规范。在自己开发设备开发驱动程序时，只要遵循相应的接口规范就行了。接口在C语言中如何表示？很简单，就是一组函数指针。 与接口与实现分开有关。针对接口编程，而不是针对实现编程，此为《设计模式》的第一条设计准则。分开接口与实现的目标是要隔离变化。软件是变化的，如果不能把变化的东西隔离开来，导致牵一发而动全身，代价是巨大的。这是大家所不愿看到的。 C语言既然可以实现面向对象的编程，自然可以利用设计模式来分离接口与实现。像桥接模式、策略模式、状态模式、代理模式等等，在C语言中，无一不需要利用函数指针来实现。 与松耦合原则有关。面向过程与面向对象相比，之所以显得苍白无力，原因之一就是它不像面向对象一样，可以直观的把现实模型映射到计算机中。面向过程讲的是层层控制，而面向对象更强调的对象间的分工合作。现实世界中的对象处于层次关系的较少，处于对等关系的居多。也就是说，对象间的交互往往是双向的。这会加强对象间的耦合性。 耦合本身没有错，实际上耦合是必不可少的，没有耦合就没有协作，对象之间无法形成一个整体，什么事也做不了。关键在于耦合要恰当，在实现预定功能的前提下，耦合要尽可能的松散。这样，系统的一部分变化对其它部分的影响会很少。 函数指针是解耦对象关系的最佳利器。Signal(如boost的signal和glib中的signal)机制是一个典型的例子，一个对象自身的状态可能是在变化的（或者会触发一些事件），而其它对象关心它的变化。一旦该对象有变化发生，其它对象要执行相应的操作。 如果该对象直接去调用其它对象的函数，功能是完成了，但对象之间的耦合太紧了。如何把这种耦合降到最低呢，signal机制是很好的办法。它的原理大致如下：其它关注该对象变化的对象主动注册一个回调函数到该对象中。一旦该对象有变化发生，就调用这些回调函数通知其它对象。功能同样实现了，但它们之间的耦合度降低了 在C语言中，要解决以上这些问题，不采用函数指针，将是非常困难的。在编程中，如果你从没有想到用函数指针，很难想像你是一个C语言高手。 4.4 回调函数的意义(总结)&emsp;&emsp;我们对回调函数的使用无非是对函数指针的应用，函数指针的概念本身很简单，但是把函数指针应用于回调函数就体现了一种解决问题的策略，一种设计系统的思想。 &emsp;&emsp;在解释这种思想前我想先说明一下，回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。 &emsp;&emsp;那么什么是回调函数呢，那是不得以而为之的设计策略，想象一种系统实现：在一个下载系统中有一个文件下载模块和一个下载文件当前进度显示模块，系统要求实时的显示文件的下载进度，想想很简单在面向对象的世界里无非是实现两个类而已。但是问题恰恰出在这里，显示模块如何驱动下载进度条？显示模块不知道也不应该知道下载模块所知道的文件下载进度（面向对象设计的封装性，模块间要解耦，模块内要内聚），文件下载进度是只有下载模块才知道的事情，解决方案很简单给下载模块传递一个函数指针作为回调函数驱动显示模块的显示进度。 &emsp;&emsp;在面向对象的世界中这样的例子还真不少，造成这样的问题的根源，相信大家已经从上面的叙述中体会到了，就是面向对象的程序设计思想，就是设计模式中要求的模块独立性，高内聚低耦合等特性。 &emsp;&emsp;封装变化的编程策略给编程人员第一位的指导思想就是面向接口编程，即设计模式中提到的面向虚拟编程而不是面向实现。这样的编程思想极大地革新了编程世界，可以说没有这一原则就没有面向对象的程序设计，这一原则给程序设计一种指导思想即如何更高的将现实模型映射成程序模型。这样的设计思想在极大地催生高度独立性模块的同时削弱了模块间的协作性，也就是耦合性，它使得模块间更多的从事着单向的调用工作，一个模块需要某种服务就去找另一个模块，这使得程序呈现出层次性，高层通过接口调用底层，底层提供服务。但是现实世界中严格遵循现层次特性的系统是很少见的，绝对的MVC是不存在的，因为更多的模块要求通并协作，可见没有耦合就没有协作没有好的调用关系，耦合真的不是错。 &emsp;&emsp;既然我们需要模块间的协作，同时我们又厌恶的摒弃模块间你中有我我中有你的暧昧关系那如何生成系统呢，答案是函数指针（不一定一定是函数指针）也就是使用回调的方式。如果一个对象关心另一个对象的状态变化那么给状态的变化注册回调函数让它通知你这类状态的改变，这样在封装了模块变化的同时实现了模块间的协作关系另辟独径的给对象解耦。 五、回调函数应用5.1 typedef void (*pFunc)();&emsp;&emsp;事实上,为了代码的移植考虑,一般使用typedef定义函数指针类型。 12345678//typedef int (*funcptr)();//定义一个返回值为int，不带参数的函数指针//就是说funcptr 是 int (*)()型的指针//funcptr table[10]; //定义一个数组，这个数组是funcptr类型的//就是说这个数组内的元素都是一个(函数)指针//这个指针指向一个返回值为int，不带参数的函数 有了函数指针类型，以后我们就可以象变量一样声明函数指针，如下例： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef void(*pFunc)();void myFunc()&#123; cout &lt;&lt; "Hello World!" &lt;&lt; endl;&#125;int main()&#123; pFunc func; unc = &amp;myFunc; func(); return 0;&#125; 5.2 怎么使用带参数的回调函数？123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int Callback_1(int x) // Callback Function 1&#123; printf("Hello, this is Callback_1: x = %d ", x); return 0;&#125;int Callback_2(int x) // Callback Function 2&#123; printf("Hello, this is Callback_2: x = %d ", x); return 0;&#125;int Callback_3(int x) // Callback Function 3&#123; printf("Hello, this is Callback_3: x = %d ", x); return 0;&#125;int Handle(int y, int (*Callback)(int))&#123; printf("Entering Handle Function. "); Callback(y); printf("Leaving Handle Function. ");&#125;int main()&#123; int a = 2; int b = 4; int c = 6; printf("Entering Main Function. "); Handle(a, Callback_1); Handle(b, Callback_2); Handle(c, Callback_3); printf("Leaving Main Function. "); return 0;&#125; 运行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Entering Main Function.Entering Handle Function.Hello, this is Callback_1: x = 2Leaving Handle Function.Entering Handle Function.Hello, this is Callback_2: x = 4Leaving Handle Function.Entering Handle Function.Hello, this is Callback_3: x = 6Leaving Handle Function.Leaving Main Function.``` &amp;emsp;&amp;emsp;可以看到，并不是直接把&lt;code&gt;int Handle(int (\*Callback)())&lt;/code&gt; 改成 &lt;code&gt;int Handle(int (\*Callback)(int))&lt;/code&gt; 就可以的。而是通过另外增加一个参数来保存回调函数的参数值，像这里 &lt;code&gt;int Handle(int y, int (*Callback)(int))&lt;/code&gt; 的参数 y。同理，可以使用多个参数的回调函数。## 5.3 结构体中的函数指针&amp;emsp;&amp;emsp;C语言中的struct是最接近类的概念，但是在C语言的struct中只有成员，不能有函数，但是可以有指向函数的指针，这也就方便了我们使用函数了。举个例子，如下：```C#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct student &#123; int id; char name[50]; void (*initial)(); void (*process)(int id, char *name); void (*destroy)(); &#125;stu; void initial() &#123; printf(&quot;initialization...\n&quot;); &#125; void process(int id, char *name) &#123; printf(&quot;process...\n%d\t%s\n&quot;,id, name); &#125; void destroy() &#123; printf(&quot;destroy...\n&quot;); &#125; int main() &#123; stu *stu1; //在VC和TC下没有malloc也可以正常运行，但是linux gcc下就会出错，为段错误，必须使用malloc stu1=(stu *)malloc(sizeof(stu)); //使用的时候必须要先初始化 stu1-&gt;id=1000; strcpy(stu1-&gt;name,&quot;C++&quot;); stu1-&gt;initial=initial; stu1-&gt;process=process; stu1-&gt;destroy=destroy; printf(&quot;%d\t%s\n&quot;,stu1-&gt;id,stu1-&gt;name); stu1-&gt;initial(); stu1-&gt;process(stu1-&gt;id, stu1-&gt;name); stu1-&gt;destroy(); free(stu1); return 0; &#125; 终端显示： 123451000 C++initialization...process...1000 C++destroy.. Ps：无论是什么类型(结构体也是)的指针，都要主要初始化(或赋内存)。 5.3 结构体拓展——协议类&emsp;&emsp;c语言中，如何在结构体中实现函数的功能？把结构体做成和类相似，让他的内部有属性，也有方法，这样的结构体一般称为协议类，提供参考： 1234567typedef struct&#123; int funcid; char *funcname; int (*funcint)(); /* 函数指针 int 类型*/ void (*funcvoid)(); /* 函数指针 void类型*/ &#125;XXX; &emsp;&emsp;每次都要注意：需要初始化。 该回调函数的用法为： 甲方进行结构体的定义（成员中包括回调函数的指针） 乙方定义结构体变量，并向甲方注册， 甲方收集N个乙方的注册形成结构体链表，在某个特定时刻遍历链表，进行回调。 当函数指针做为函数的参数，传递给一个被调用函数，被调用函数就可以通过这个指针调用外部的函数，这就形成了回调 一般的程序中回调函数作用不是非常明显，可以不使用这种形式 最主要的用途就是当函数不处在同一个文件当中，比如动态库，要调用其他程序中的函数就只有采用回调的形式 通过函数指针参数将外部函数地址传入来实现调用函数的代码作了修改，也不必改动库的代码(只是函数指针指向的函数修改变动，库的处理没有变动)，就可以正常实现调用便于程序的维护和升级]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>函数指针</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_的_函数返回值(指针函数)]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、函数返回值的要点注意（原则）：可以返回局部变量本身，但永远不要返回一个局部变量的指针或引用(其实是隐式的指针)； 原因：局部变量只是临时的存储空间，因为函数执行完之后，将释放分配给局部变量的存储空间，此时，对局部变量的引用和地址就会返回不确定的内存(野指针)。 系统堆栈的知识点 &emsp;&emsp;函数调用过程中，一个函数在调用另外一个函数的时候，会先将调用前的现场信息保存在系统堆栈中，然后按照从又向左的顺序(c语言)将实参的结果入栈，而被调用的函数的形参，用的就是实参的空间，当被调用的函数运行结束后，局部变量的空间被“释放”的本质，其实是栈顶的指针，移动到了调用前函数的现场信息的地方，所以刚才被调用的函数的局部变量，实际上它的值还是存放在内存中，并且在当前栈顶指针的上面的连续空间中。 简单理解 &emsp;&emsp;函数执行完，局部变量会被释放，此时指向 已释放的局部变量 的指针 是很危险(不确定)的；如果不调用还好(但不调用，那要返回值干嘛?)； &emsp;&emsp;一旦其他函数调用该函数返回值指针，该指针指向的内存不确定就会造成不可知的错误。 二、举例 返回变量本身 123456789101112//这个返回变量本身内存可以，正确int add(int x, int y)&#123; int sum = x + y; return sum;&#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; add(a, b) &lt;&lt; endl;&#125; 返回局部变量指针，用法错误 1234567891011int* add(int x, int y)&#123; int sum = x + y; return &amp;sum; &#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; *add(a, b) &lt;&lt; endl;&#125; 会出现以下警告： warning: function returns address of local variable [-Wreturn-local-addr] return &amp;sum; 警告：函数返回地址是局部变量地址—&gt;这是不安全的 三、解决方案和利弊3.1 解决方案该如何解决这种错误呢？有以下3种常用方案： 使用静态变量 使用全局变量 申请堆区变量 其实，使用这三种方法都是为了延长变量的声明周期，从而达到返回的地址是确定的而不是不确定的。 法1： 1234567891011int* add(int x, int y)&#123; static int sum; sum = x + y; return &amp;sum;&#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; *add(a, b) &lt;&lt; endl;&#125; 法2： 12345678910111213int sum;int&amp; add(int x, int y)&#123; sum = x + y; return sum;&#125;int main()&#123; int a = 3, b = 5; cout &lt;&lt; *add(a, b) &lt;&lt; endl;&#125; 法3： 1234567891011121314int* add(int x,int y)&#123; int* sum = new int; *sum = a + b; return sum;&#125;int main()&#123; int a = 3, b = 5; int *result; result = add(a, b); cout &lt;&lt; *result &lt;&lt; endl; delete result;&#125; &emsp;&emsp;但法3需要注意，由于用new申请的动态内存，调用者（这里是main）需要释放这个申请的指针free, delete 3.2 利弊 法3的 申请堆区变量 比较麻烦，一般不常用； 法2的 使用全局变量 比较鸡肋；如果是全局变量的(函数返回值)指针，为啥不直接调用该指针，函数就不需要返回(全局)指针，该返回值充其量像是 提示 ，或者是函数格式要求 法1的 使用局部变量 比较推荐 总结：指针类型的函数返回值 还是不推荐用。 &emsp;&emsp;采用return语句返回的指针，原本想法是让函数返回多个数值(数组、结构体)；但指针往往是作为函数形参来直接改变实参(数值)，从而让函数变相返回多个数值；因此，指针类型的函数返回值，功能少且鸡肋(容易出事)，不推荐使用]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>函数</tag>
        <tag>函数返回值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针类型_的_函数形参]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、指针作为函数参数1.1 函数参数的传递方式C语言的函数参数的传递方式有以下两种： 值传递：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作 1.2 函数相关的知识 函数(return)返回值：实际一般是返回(处理过的)局部变量；且只能返回单个值； 指针作为函数参数，指针能使被调函数(变相)返回一个以上的结果。（直接对内存操作3改变多个实参） 函数内部修改外部变量的值，需要一级指针； 函数内部修改外部指针变量的值，需要二级指针； 所以要想直接对内存单元进行操控，用指针最直接，指针的功能很强大。 1.3 举例 经典例子1 ：交换CET1 和 CET2 的值（一级指针交换值） 1234567//Wrongvoid swap_val(int a,intb)&#123; int tmp = a; a = b; b = tmp;&#125; 错误原因：因为交换的是副本(形参)，真品(实参)没改变的。 经典例子2：是在学习STM32的库函数的使用。当初刚接触库函数，对于函数初始化接口。 1GPIO_Init(GPIOA, &amp;GPIO_InitStructure); 分析：为什么要取初始化结构体变量的地址传递进库函数（&amp;GPIO_InitStructure），而不是直接将结构体变量本身（GPIO_InitStructure）传递进去？ 二、实际例子2.1 两数值交换1234567891011121314151617# include &lt;stdio.h&gt;void Swap(int *p, int *q); //函数声明int main(void)&#123; int i = 3, j = 5; Swap(&amp;i, &amp;j); printf("i = %d, j = %d\n", i, j); return 0;&#125;void Swap(int *p, int *q)&#123; int buf; buf = *p; *p = *q; *q = buf; return;&#125; 输出结果是：i = 5, j = 3 &emsp;&emsp;此时实参向形参传递的不是变量 i 和 j 的数据，而是变量 i 和 j 的地址。其实传递指针也是拷贝传递，只不过它拷贝的不是内存单元中的内容，而是内存单元的地址，这就是天壤之别了。拷贝地址就可以直接对地址所指向的内存单元进行操作，即此时被调函数就可以直接对变量 i 和 j 进行操作了。有人会说：“被调函数用完就释放了，不就把 i 和 j 都释放了吗？”不是的，当函数调用完之后，释放的是 p 和 q，不是 i 和 j。p 和 q 中存放的是 i 和 j 的地址。所以 p 和 q 被释放之后并不会影响 i 和 j 中的值。前面讲过，修改指针变量的值不会影响所指向变量中的数据。只不过它们之间的指向关系没有了而已。 此外需要注意的是，形参中变量名分别为 p 和 q，变量类型都是 int* 型。所以实参 i 和 j 的地址，即 &amp;i 和 &amp;j 是分别传递给 p 和 q，而不是传递给 *p 和 *q。 函数参数传指针和传数据的区别 &emsp;&emsp;综上所述，如果希望在另外一个函数中修改本函数中变量的值，那么在调用函数时只能传递该变量的地址。如果这个变量是普通变量，那么传递它的地址就可以直接操作该变量的内存空间。 &emsp;&emsp;那么，是不是要定义一个指针变量指向它然后传递这个指针变量呢？不用多此一举。比如有一个“int i；”，如果想传递i的地址那就直接传递 &amp;i 就行了，不用专门定义一个指针变量指向它，然后再传递这个指针变量。 如果要传递的变量本身就是一个指针变量怎么办？如果要操作该指针变量所指向的内存空间是不是要传递该指针变量的地址呢？ &emsp;&emsp;指针变量本身就是地址，本身就是指向那个内存空间的，所以直接把它传过去就行了。除非你要改变那个指针变量里面存放的地址，即你要改变指针变量的指向，那么你就必须要传递指针变量的地址。指针可以使得函数返回一个或者一个以上的值 2.2 数组中的n个元素的值分别减去20 需求分析:编写函数,要求将数组中的n个元素的值分别减去20 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#define N 10//函数前置声明void traverseArray(int *pArr,int length);void subArray(int a[],int length);void subArray1(int * pArr,int length );//数组元素的遍历void traverseArray(int *pArr,int length)&#123; int i; for(i = 0;i&lt;length;i++) &#123; printf("%3d",*(pArr+i)); &#125; printf("\n"); return;&#125;//将数组中所有元素都减去20void subArray(int a[],int length)&#123; int i ; for(i = 0;i&lt;length;i++) &#123; a[i] = a[i] - 20; &#125; return;&#125;//将数组中所有元素都减去20void subArray1(int * pArr,int length )&#123; int i ; for(i = 0;i&lt;length;i++) &#123; *(pArr + i) = *( pArr + i) - 20; &#125; return ;&#125;int main(void)&#123; int a[N]=&#123;51,52,53,54,55,56,57,58,59,60&#125;; printf("原来数组中的元素为:\n"); traverseArray(a,N); printf("数组中元素第一次减去20后为:\n"); subArray(a,N); traverseArray(a,N); printf("数组中元素第二次减去20后为:\n"); subArray1(a,N); traverseArray(a,N); return 0;&#125; 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是： 不允许拷贝数组； 使用数组时通常会将其转换成指针。 &emsp;&emsp;因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因此数组会被转换成指针(数组退化现象)，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式： 12345//尽管形式不同，但这三个printf函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10])//这里的维度表示我们期望数组含有多少元素，实际不一定 当编译器处理对printf函数的调用时，只检查传入的参数是否是const int*类型： 1234int i = 2;int j[2] = &#123;1,2&#125;;print(&amp;i); //正确，&amp;i的类型是int*print(j); //正确，j被转换成int*并指向j[0] &emsp;&emsp;如果我们传给printf函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。 三、指针作为函数参数的好处&emsp;&emsp;此外，传指针和传数据相比还有一个好处就是节约内存。我们知道，传数据拷贝的是内存单元的数据，如果数据很多的话拷贝过来都要为它们分配内存。而传指针的话只需要传递 4 字节的地址就行了。而且传数据非常消耗效率，为形参分配内存需要时间，拷贝需要时间，最后结束了返回还是需要时间。前面说过，return时系统会先自动创建一个临时变量来存放返回的值。所以传数据时很消耗效率，而传指针就是为了提高效率。 &emsp;&emsp;事实上，在实际编程中我们都是传递指针！ 往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可： 数据很小，比如就一个 int 型变量。 不需要改变它的值，只是使用它的值。 此时不是不能用指针，当然也可以用指针，只是没有必要。 &emsp;&emsp;以后在使用函数的时候，只要函数的参数不满足上面这两个条件，那么就用指针。此外需要注意的是，数组名本身就是地址，所以如果传递数组的话直接传递数组名就行了。接收的形参可以定义成数组(形式方面上而已)也可以定义为同类型的指针。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>函数</tag>
        <tag>函数形参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针&数组&字符串]]></title>
    <url>%2F2020%2F03%2F15%2F%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = 一、指针 &amp; 数组(细品)&emsp;&emsp;指针就是指针，指针变量在32位系统下，永远占4字节，其值为某一个内存的地址。指针可以指向任何地方(内存)，但是不是任何地方你都能通过这个指针变量访问到呢？(有地址，无[权限]空间) &emsp;&emsp;数组就是数组，其大小与元素的类型和个数有关；定义数组时，必须指定其元素的类型和个数；数组可以存任何类型的数据，但是不能存函数。 总结如下： 指针本质上也是一个变量 指针要占用一定的内存空间（任何类型的指针的内存大小是一样的） 指针用于保存内存地址的值 数组&amp;结构体 数组：所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙 结构体：在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。 二、数组2.1 数组的基础 数组在一片连续的内存中存储元素 元素的个数可以是显示的也可以是隐式的1int a[5]=&#123;1,2&#125;;//其中,其他的元素都为0来填充 2.2 数组地址与数组名 数组名代表数组首元素的地址 数组的地址需要取地址才可以得到 数组首元素的地址值 与 数组的地址值 相同(注意是值) 数组首元素的地址 &a[0] 与数组的地址 &a 是两个不同的概念 &emsp;&emsp;举例，湖南省的省政府在长沙，长沙的市政府也在长沙，两个政府都在长沙。 2.3 数组名的盲点&emsp;&emsp;数组名如何理解呢？用来存放数组的区域是一块在栈中静态分配的内存(非static)，而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且，还是一个不可修改的常量，完整地说，就是一个地址常量。 &emsp;&emsp;数组名跟枚举常量类似，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。注意了！不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址，这就是数组名属于符号常量的意义所在。 &emsp;&emsp;由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，那么，数组名永远都不会是指针！ 数组名可以看作一个常量指针（指针所指向的内容不能改变） 既然是指向常量，那就不能作为表达式左值，因为左值能被修改 可以单独修改数组元素，但用数组名(实际上是符号常量)不能直接修改数组 2.4 指针 &amp; 数组 的定义与声明(经典错误)2.4.1 定义为指针，声明为数组1234567891011//test1 文件1char * p="Hello World!";//test2 文件2#include&lt;stdio.h&gt;extern char p[];void main()&#123; printf("%s\n",p);//printf("%s\n",*(unsigned int *)p);正确&#125; 2.4.2 定义为数组，声明为指针12345//test1 文件1char a[100];//test2 文件2extern char *a; 2.5 定义数组类型&emsp;&emsp;C语言中，可以通过typedef为数组类型重命名 1typedef type(name)[size]; 数组类型(重命名了一种一个数组类型）： 12typedef int(AINT5)[5];typedef float(AFLOAT10)[10]; 数组定义： 12AINT5 i = &#123;0,1,2,3,4&#125;;AFLOAT10 f; 三、 字符串 从概念上讲，C语言中没有字符串数据类型 在C语言中使用字符数组来模拟字符串 单引号' '括起来的一个字符代表整数 双引号" "括起来的字符(串)代表一个指针 字符串是以 '\0'结束的字符数组 字符串可以分配于栈空间，堆空间或者 字符常量区（不能被改变） 123char* s1 = "Hello World"； //在字符常量区,不可改变这个字符串中的字符char s2[100] = "Hello world"; //在栈上，可修改(不能通过数组名！) 3.1 (实)字符数组、(虚)字符串&emsp;&emsp;下面的代码合法吗？使用它有什么隐患？ 1234char a[3] = "abc";char *p = &amp;a;p[0]= 'I';答案与分析： &emsp;&emsp;在标准C中这是合法的，但是它的生存环境非常狭小；它定义一个大小为3的字符数组，初始化为“abc”；注意，它没有通常的字符串终止符’\0’，因此这个数组只是看起来像C语言中的字符串，实质上却不是。因此所有对字符串进行处理的函数，比如strcpy、printf等，都不能够被使用在这个假字符串上。 3.2 字符串的长度 字符串的长度就是字符串说包含字符的个数 C语言中的字符串的长度值得是第一个'\0'字符串出现的字符个数 C语言中通过'\0'结束来确定字符串的长度 以strlen()为例，strlen()为无符号类型 12345//比较两个字符串的长度的时候//正确用法if(strlen(a)&gt;=strlen(b))//错误用法if(strlen(a)-strlen(b)&gt;0) 3.3 不受限制的字符串函数&emsp;&emsp;不受限制的字符串函数是通过寻找字符串得结束符 '\0'来判断长度。 字符串复制函数： char* strcpy(char* dst,const char* src) 字符串连接： char* strcat(char* dst,const char* src) 字符串比较函数：int strcmp(const char* s1,const char* s2) 注意事项 不受限制的字符串函数都是以’\0’作为结束标记来进行的，因此输入参数必须包含’\0’ strcat和strcpy必须保证目标字符数组的剩余空间足以保存整个源字符串 strcmp以0值表示两个字符串相同 第一个字符串大于第二个字符串的时候返回值大于0 第一个字符串小于第二个字符串的时候返回值小于0 strcmp不会修改参数值，但依然以’\0’作为结束符号 3.4 长度受限制的字符串函数&emsp;&emsp;长度受限的字符串函数接收一个显示的长度参数用于限定操作的字符串。 字符串复制:char* strncpy 字符串连接:char* strncat 字符串比较:char* strncmp 四、数组参数和指针参数(针对函数传入)&emsp;&emsp;数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是： 不允许拷贝数组 使用数组时通常会将其转换成指针 因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。 因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。(数组参数退化为指针) 尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式： 12345678//尽管形式不同，但这三个进行print函数是等价的//每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10])//这里的维度表示我们期望数组含有多少元素，实际不一定//第三种容易被误会，且容易造成数组越界://实际元素不确定，但是函数操作(传入数组较短)以10个操作，越界 当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型： 1234int i = 2;int j[2] = &#123;1,2&#125;;print(&amp;i); //正确，&amp;i的类型是int*print(j); //正确，j被转换成int*并指向j[0] 如果我们传给printf函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。 五、二维数组5.1 二维数组参数和指针参数&emsp;&emsp;C语言的编译器会让（不论是一维数组还是二维数组）数组参数退化为指针。C语言中无法向一个函数传递任意的多维数组。 二维数组参数同样存在退化问题。 二维数组可以看作是一维数组 二维数组中的每一个元素是一维数组 二维数组参数中第一维的参数可以省略（退化过程） 注意事项 C语言中无法向一个函数传递任意的多维数组 为了提供正确的指针运算，必须提供除一维之外的所有维的长度(程序写法)限制 一维数组-必须提供结束的标志 二维数组-不能直接传递给函数 多维-无法使用 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;void access(int a[][3],int row)&#123; int col=sizeof(*a)/sizeof(int);//去推导出列的数量 int i=0,j=0; for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; printf("%d ",a[i][j]); &#125; printf("\n"); &#125;&#125;void main()&#123; int a[3][3]=&#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125; &#125;; access(a,3);&#125; 5.2 二维数组与数组指针 二维数组在内存中以一维的方式排布 二维数组中的第一维是一维数组 二维数组中的第二维才是具体的值 二维数组的数组名同样可以看作常量指针 二维数组同样代表数组首元素的地址 12345678#include&lt;stdio.h&gt;int main()&#123; int a[5][5]; int (*p) [4]; p=a; printf("%d\n",&amp;p[4][2]-&amp;a[4][2]);&#125; 答案为-4，因为（*p）一次跨越4个，而a一次跨越5个 123456789101112131415//用指针遍历二维数组#include&lt;stdio.h&gt;int main()&#123; int i,j; int a[3][3]=&#123;&#123;&#125;&#125;; for(i=0;i&lt;3;i++) for(j=0;j&lt;3;j++) *(*(a+i)+j)=1; for(i=0;i&lt;3;i++) for(j=0;j&lt;3;j++) printf("%d",*(*(a+i)+j)); return 0;&#125; 六、指向指针的指针为什么需要指向指针的指针？ 指针在本质上也是一个变量 对于指针来讲也有传值调用与传址调用 123456789101112131415161718192021222324252627282930313233343536//重置动态空间#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;int rest(char** p,int size,int new_size)&#123; int ret=1; int len=0; int i=0; char* mid=NULL; char* pt=NULL; char* pp=*p; if((p!=NULL)&amp;&amp;(new_size&gt;0)) &#123; mid=(char*)malloc(3); pt=mid; len=(size&lt;new_size)?size:new_size; for(i=0;i&lt;len;i++) &#123; *pt++=*pp++; &#125; free(*p); *p=pt; &#125;else&#123; ret=0; &#125; return ret;&#125;void main()&#123; char *p=(char*)malloc(5); printf("%0X\n",p); if(rest(&amp;p,5,3)) &#123; printf("%0X\n",p); &#125;&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在嵌入式中的各种指针用法和概念]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95%E5%92%8C%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器= = Ps：以下所有指针的概念的理解思路可以从字义层面上，从右到左进行理解。 指针数组 ： int *p1[10]; 数组指针 ： int (*p2)[10]; 对应概念 指针数组：一个存放多个指针的数组 数组指针：一个指向数组的指针(首地址) 对应用法 指针数组：一般是存放多个指针分别指向各个不同的字符串，不同的指针可组合起来一段话。 数组指针：一般是作为函数的数组形参，打印字符串可以只修改指向的字符串地址。 结构体指针 ：Student *p2; 结构体数组指针 ：Student (*p2)[10]; 结构体成员是指针： 对应概念 结构体指针：跟数组指针差不多 结构体数组指针：跟指针数组差不多，存放多个结构体指针 结构体成员是指针：跟普通数组差不多，但只是部分成员(元素)是指针 对应用法 结构体指针：普遍常用 结构体数组指针：普遍常用，可对应不同驱动的通道号(例如两路硬件选择) 结构体成员是指针：很常见，不过要注意初始化赋值 指针函数： int *p3(int，int); 函数指针： int (*p4)(int，int); char *(*pf)(char * p); 传递指针： int p5(int*，int*) 对应概念 指针函数：一个返回值是 指针变量 的函数 函数指针：一个指向函数的指针 传递指针：函数形参是指针 对应用法 指针函数：不常用，有风险。不能返回局部变量指针，全局指针变量还需要返回吗？ 函数指针：相当于留出自定义函数接口，常用于回调函数 或 程序适应(选择)不同(硬件)版本的驱动(函数) 传递指针：很常用，传入实参需要修改值时，就传入实参指针(数组退化被迫传入指针) Ps： 函数声明时，可以省略形参名，不能省略形参类型； 函数定义（写函数体）时，则都不能省略。 函数内部修改外部变量的值，需要一级指针；(函数形参) 函数内部修改外部指针变量的值，需要二级指针。 函数的实参和形参之间的传递是单向的，只能由实参向形参传递(拷贝传递)。被调函数调用完之后系统为其分配的内存单元都会被释放。我们在对常量，或者是指针进行操作的时候，实质上是对其对应的内存进行操作 函数指针数组： int (*p5[3])(int ); char *(*pf[3])(char *p); 函数指针数组指针： char *(*(*pf[3])(char *p); 对应概念 函数指针数组：一个数组中，所有元素都是指针，且一个指针对应指向一个函数 函数指针数组指针：一个指针，指向一个数组，这个数组中，所有元素都是指针，一个指针对应指向一个函数 对应用法 函数指针数组：一个数组存放多个不同版本的驱动、算法(函数) 上面那个已经很极限了；这个真太花里胡哨，用不来，用的来也估计是埋坑给后面的]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动转换&强制转换]]></title>
    <url>%2F2020%2F03%2F15%2F%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器 一、类型转换的来源&emsp;&emsp;计算机硬件进行算术操作时，要求各操作数的类型具有相同的大小（存储位数）及存储方式。例如，由于各操作数大小不同，硬件不能将 char 型（ 1 字节）数据与 int 型（ 2 或 4 字节）数据直接参与运算；由于存储方式的不同，也不能将 int 型数据与 float 型数据直接参与运算。 &emsp;&emsp;然而，由于 C 语言编程的灵活性，在一个表达式或一条语句中，允许不同类型的数据混合运算。 &emsp;&emsp;C 语言的灵活性与计算机硬件的机械性是一对矛盾，如处理不好，将会产生错误结果。对于某些类型的转换编译器可隐式地自动进行，不需人工干预，称这种转换为自动类型转换；而有些类型转换需要编程者显式指定，通常，把这种类型转换称为强制类型转换。 二、自动类型转换(隐式)&emsp;&emsp;不同数据类型之间的差别在于数据的表示范围及精度上，一般情况下，数据的表示范围越大、精度越高，其类型也越“高级”。 常见类型级别从低到高依次为：char -&gt; short -&gt; int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; double 浮点型级别从低到高依次为：float -&gt; double 不同类型间的混合运算，较低类型将自动向较高类型转换。(精度提高不影响结果) 注意事项：(以下操作可能会截取精度) 赋值表达式中，表达式的值 (自动)转换为 左值(变量)的类型 函数调用时，实参(自动)转化为形式参数的类型 函数返回值，return 表达式 (自动)转化为返回值的类型 举例如下： 赋值运算符，两恻的类型不一致 &emsp;&emsp;当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型可能提升或降低为左值类型。例如： 12double d;d=5.1f; &emsp;&emsp;由于左值为双精度浮点型，故先把右值单精度浮点型常量 5.1 提升为双精度浮点型后，再赋值给 d，不但不丢失精度反而提高了精度。 12int i;i=5.1; //右值5.1为双精度，左值为整型 &emsp;&emsp;右值双精度浮点型 5.1 降低为左值整型，即 5.1 舍弃小数部分后，把 5 赋给整型变量 i，这种情况会丢失精度。 赋值运算符，右值超出左值类型范围 &emsp;&emsp;更糟糕的情况是，赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。例如： 123char c; //char 占8位，表示范围-127〜128c=1025; //1025 对应二进制形式：100 0000 0001，超出了8位printf("％d",c) ; //以十进制输出c的值 &emsp;&emsp;该输出结果为 1，因为只取 1025 低 8 位 0000 0001（值为1），赋给字符型变量 c，故得到毫无意义的值。 三、强制类型转换&emsp;&emsp;为了给程序设计人员提供更多的类型转换控制权限，使程序设计更加灵活，转换的目的更加清晰，C 语言提供了可显式指定类型转换的语法支持，通常称之为强制类型转换。 强制类型转换常见的用法: (1)数据的 高类型一般不会强制转换成低类型，因为可能会丢失一部分数据； (2)一般是低类型强制转换成高类型，防止数据溢出； (3)提高函数指针的适用性 原因如下： (1)高类型转低类型，往往是函数传参，让函数处理更加明确范围； (2)低类型转高类型，防止数据溢出； (3)强制转换函数指针能够让回调方式更加多样性。 也许有人会问，那一开始都为高类型就不需要强制转换了吗？ &emsp;&emsp;很简单，能低类型处理能够更好体现对应函数的功能性。当需要调用该变量，再强制转换获取到的数值，防止数据溢出。这种灵活性，还能实现节省内存。 举例——强制地址跳转 1#define jump(TargetAddr) (*((void(*)())(TargetAddr)))() &emsp;&emsp;第一个(( void( * )( )) ，意思为强制类型转换为一个无形参，无返回值的函数指针，(*(TargetAddr))为跳转地址，但是函数指针变量不能为常数所以要加((void( * )( )) 进行强制类型转换。最后一个()为执行的意思。 整个宏定义目的是为了跳转到一个绝对地址执行函数。用处如下： 在单片机中可以实现软件复位，比如跳转到0地址。 如果程序是由多个程序合并的（bootloader跳转），跳转到某一个确定的用户程序地址执行。 如果flash空间足够大的话，甚至还可以实现当多份不相同的代码合并为一份后，在软件上做逻辑跳转，好处是新程序不必为旧程序做大量的兼容工作，通常旧程序含有大量的前人的(坏)编程习惯。可以选择执行想要的版本软件程序。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>强制转换</tag>
        <tag>自动转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字&符号&预处理&函数]]></title>
    <url>%2F2020%2F03%2F15%2F%E5%85%B3%E9%94%AE%E5%AD%97-%E7%AC%A6%E5%8F%B7-%E9%A2%84%E5%A4%84%E7%90%86-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;无情的搬砖机器 一、关键字1.1 struct&emsp;&emsp;该关键字看另外博客：结构体 1.2 union&emsp;&emsp;该关键字看另外博客：大小端和联合体 1.3 switchswitch注意事项: case语句中的值只能是整型或字符型的常量或常量表达式（想想字符型数据在内存里是怎么存的） default语句只能用于处理真正的默认情况 每个case语句分支必须有break，否则分支重叠 Ps：switch可用于冗长的程序逻辑进程，每一个case代表一个进程，只有其中进程执行完，才对switch(Temp)判断的值进行改动(例如：Temp++);然后进行下一个流程，方便梳理逻辑。 1.4 enum&emsp;&emsp;相比 #define 标识符常量必须由程序员手工赋值。enum 使程序更容易维护，因为枚举常量是由编译程序自动生成的。 Ps：可搭配switch作为case值方便扩展 1.5 static &amp; extern1.5.1 static1static uint32_t Shatang; 常见用法：屏蔽其他源文件对本源文件static修饰的变量 修饰局部变量：用来延长变量生命周期，防止再次调用函数时需要再初始化修饰的变量，保留原有数据(常见用法) 修饰全局变量：用static对全局变量进行修饰改变了其作用域的范围，防止其他源文件对本源文件的变量调用 static 全局变量：、 static全局变量只初始化一次，防止在其他文件单元中被引用； 只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。 static 局部变量： static局部变量只被初始化一次，下一次依据上一次结果值； 限制了它的使用范围 static 函数： static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为(static)内部函数，内部函数应该在当前源文件中说明和定义。 static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 Ps：指针是变量 总结：从上面用法描述来看，static不会在 .h文件修饰变量(.c文件都调用不了你，要你何用)，正常情况下都会在 .c文件修饰变量、函数定义(声明往往在.h文件），防止其他 .c文件调用； 1.5.2 extern1extern uint32_t Shatang; 常见用法：用在变量或者函数的声明前，用来说明“此变量/函数”是在别处定义的，要在此处引用。 问题描述：因为要使用CAN进行数据传输，因此在主程序”test.c”中采用#include “can.h”，调用”can.h”中的函数和变量。结果编译后出现许多 Error L6200E: symbol xxx multiply defined ... 原因：因为在 "can.h" 中定义（不仅声明还进行定义）了许多变量，"can.c"文件中采用 #include "can.h"，调用"can.h"中的变量定义；在主函数"test.c"中也采用 #include "can.h"，调用"can.h"中的变量定义，导致”can.h”中的变量被重复定义。 解决方法：首先，不应该在”can.h”中定义”can.c”中使用的变量（正常情况都是这样），而是在”can.c”中定义所需的变量。在”can.h”中把变量先进行 extern uint8_t Shatang; 声明，然后 在”can.c”文件再进行定义；此时，主程序”test.c”中将所调用”can.h”中的变量（声明） 将会去”can.c”查找其定义，因此不会存在变量重复定义，问题得到解决。 结论：extern往往用于 .h文件变量声明，然后在相应的 .c文件进行定义，这样防止 .h文件被多个 .c文件调用时产生重复定义的错误 特殊案例：往往图片、字库是按照 .h文件变量定义的，没有.c文件；当你的（lcd.c）文件功能需要调用 某些图片数组.h文件，不能在自身（lcd.h）文件调用 image.h文件，当其他 .c文件调用lcd.h 文件,就会产生上面同样的重复定义；因此对于(只有) .h文件进行变量定义，往往采用直接在（只能在单个） lcd.c 文件调用 1.5.3 static 和 extern 的关系&emsp;&emsp;static表示是本文件内的变量（在函数中的是静态变量），extern表示是其他文件定义的变量，显然两者是矛盾的；只有全局变量并且没有被static声明的变量才能声明为extern。 1.6 const &amp; 指针常见用法：const 修饰变量为只读变量(不是常量！！！)。 为了防止传递的函数参数不被修改，在调用函数的形参中用const关键字 const可以用来创建数组常量、指针常量、指向常量的指针等 如何辨别const是修饰什么？方法：无括号的情况下，可以先忽略类型名。 const int *p; //const修饰*p，p是指针，*p是指针指向的对象，不可变int const *p; //const修饰*p，p是指针，*p是指针指向的对象，不可变int *const p; //const修饰p，p不可变，p指向的对象可变const int *const p; //前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变 &emsp;&emsp;这里或许就有人要问：const int *const p;这种都不可变的有什么用？只不过是教语法时用到的花里胡哨。诚然，指针p和p指向的对象都不可变，但是p指向的对象还可以是个指针啊！因此 const int *const p;往往是用于二级指针。思路反过来，当别人代码这样写的时候：你就应该明白，这里是二级指针。 1234//特殊情况const (int*)p;* const int p;int* const p; &emsp;&emsp;以上的三种情况是等效的。对于const (int *)，因为int *是一个整体，相当于一个类型(如 char)，因此，这个const是限定指针不可变。 Ps：只读变量 和 常量 是有区别的，内存存放区域都不同。详情看内存分配一章。 1.7 voidvoid 常与 (函数)指针 搭配使用： C语言规定只有相同类型的指针才可以相互赋值 void*指针作为左值用于“接收”任意类型的指针 void指针作为右值赋值给其他指针时需要强制类型转换 1.8 volatilevolatile用于告诉编译器必须每次去内存中取变量值： volatile主要修饰可能被多个线程访问的变量 volatile也可以修饰可能被(硬件)未知因数更改的变量 Ps：volatile往往只用于最底层驱动(防止数值被修改，例如通信协议)；最好不要用于封装其他高级应用层的代码，用处不大，而且不利于其他人对你的程序进行移植拓展(极端情况下可能取值问题出错)。 举例如下： 1234int square(volatile int *ptr)&#123; return (*ptr)*(*ptr);&#125; 由于*ptr 的值可能被意想不到地该变，这段代码可能返不是你所期望的平方值！ 1.9 sizeof1sizeof(int) //计算(int类型)内存大小 常见用法：计算内存大小。在嵌入式c代码中，用于计算数组等大小；它往往会和 struct、#define、#pragma pack 连用，用来计算结构体的偏移量，方便调用结构体成员。 1234567891011121314151617181920212223/*块注释：打印参数列表*/typedef struct &#123; uint32_t ulPrintAuto; // 0 自动打印开关 uint32_t ulPrintFormat; // 1 打印格式 uint32_t ulPrintLang; // 2 打印语言 uint32_t ulPrintRow; // 3 打印走纸行数 uint32_t ulPrintAcc; // 4 打印总累计数据 uint32_t ulPrintRecipeSetting; // 5 打印配方设置表 uint32_t ulPrintRecipeAcc; // 6 打印配方累计表 &#125;_strPrintParam;/*块注释：获取打印参数结构体成员的偏移量*/#define GET_PRINTF_PARAM_OFFSET(member) (((uint32_t)(&amp;(((_strPrintParam *)0)-&gt;member))) / sizeof(uint32_t))/*块注释：获取打印参数数量*/#define PRINT_PARAM_NUM (sizeof(_strPrintParam)/sizeof(uint32_t)) PRINT_PARAM_NUM 可用于实现结构体成员的(for循环)赋值； GET_PRINTF_PARAM_OFFSET(member) 计算出来的结构体偏移量可方便 结构体扩展 1.10 typedef&emsp;&emsp;typedef用于给一个已经存在的数据类型重命名。 下边是一个能够说明typedef的语法例子： 1234567891011121314151617181920// simple typedeftypedef unsigned long ulong; // the following two objects have the same typeunsigned long l1;ulong l2; // more complicated typedeftypedef int int_t, *intp_t, (&amp;fp)(int, ulong), arr_t[10]; // the following two objects have the same typeint a1[10];arr_t a2; // common C idiom to avoid having to write "struct S"typedef struct &#123;int a; int b;&#125; S, *pS; // the following two objects have the same typepS ps1;S* ps2; typedef 定义结构体类型 12345678typedef struct&#123; int iNum; long lLength;&#125;MyStruct;MyStruct stu1;MyStruct *stu1;MyStruct class[50]; typedef 定义数组类型 12345678typedef int(AINT5)[5];typedef float(AFLOAT10)[10];typedef char(ACHAR9)[9];AINT5 a1;AFLOAT10* pf = &amp;fArray;ACHAR9 cArray;AINT5 i = &#123;0,1,2,3,4&#125;; typedef 定义(常见)指针类型 123typedef char* pstr;pstr p; typedef 定义函数指针类型 1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef void(*pFunc)();void myFunc()&#123; cout &lt;&lt; "Hello World!" &lt;&lt; endl;&#125;int main()&#123; pFunc func; unc = &amp;myFunc; func(); return 0;&#125; 进阶：typedef 定义函数指针类型后，可以再用 该函数指针类型 定义 数组/结构体成员，让 每个元素 或 结构体成员 为函数指针。 综合例程，如下： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt; typedef char arr[2][5]; // 数组typedef char *name[5]; // 指针数组 typedef char (*lan)[5]; // 数组指针 int main()&#123; arr age; name named; lan land; char i; char j; for(i=0;i&lt;2;i++)&#123; for(j=0;j&lt;5;j++)&#123; age[i][j]=i*j+1; &#125; &#125; for(i=0;i&lt;2;i++)&#123; named[i]=age[i]; &#125; land=&amp;age; for(i=0;i&lt;2;i++)&#123; for(j=0;j&lt;5;j++)&#123; printf("aged[%d][%d]=%d named[%d][%d]=%d land[%d][%d]=%d\n",i,j,age[i][j],i,j,named[i][j],i,j,land[i][j]); &#125; &#125;&#125; 1.11 enum &amp; const &amp; typedef &amp; #define #define：标识符常量必须由程序员手工赋值 enum：枚举常量是由编译程序自动生成的，使程序更容易维护 这两个都是可以用来定义常量 const：修饰 只读变量，不会变的变量。从内存分配区上来看，就已经不一样了。 typedef：跟#define极其相似，但实际有很大区别 举例区分typedef &amp; #define 例子1. 以下p1,p2,p3,p4有什么区别？ 123456//第一段typedef char* PCHAR;PCHAR p1,p2;//第二段#define PCHAR char*PCHAR p3,p4; 答案：p4是一个char类型 例子2. 以下是 指针为只读变量 还是 指针指向的内容不可变？ 12typedef char* pstr;const pstr p; 答案： const pstr p;&lt;==&gt; char* const p; &emsp;&emsp;错误的原因在于将 typedef 当做文本扩展了(#define 才是真正的文本扩展！)。声明 const pstring 时，const修饰的是pstring的类型，这是一个指针。因此，该声明语句应该是把cstr定义为指向string 类型对象的const指针。 123456typedef char* pstr;const pstr p;const (char*) p;* const char p;char* const p; &emsp;&emsp;以上的四种情况是等效的。 二、符号2.1 单引号、双引号 单引号引起来的都是字符常量 双引号引起来的都是字符串常量 举例：1 ，’1’ , “1” 第1个是整数常量，32位系统下占4字节；第2个是字符常量，占1字节；第3个是字符串常量，占2字节。 &emsp;&emsp;字符在内存里是以 ASCII码 存储的，所以字符常量还可以与整形常量或变量进行运算，如：'A' + 1 。 2.2 逻辑运算符使用分析案例分析: 1234567891011#include&lt;stdio.h&gt;void main()&#123; int i=0; int j=0; if(++i&gt;0 || ++j&gt;0) &#123; printf("%d\n",i); printf("%d\n",j); &#125;&#125; 输出的结果为1，0。 2.3 逻辑运算符 &amp; 按位运算符&emsp;&emsp;举例：以下例子函数的DATAx为宏定义stm32各个IO管脚，封装函数实现8pin并口数据输出；以下函数均能在C编译器编译通过 123456789101112131415161718192021222324//errorvoid DATA_Process(uchar com)&#123; DATA0=((com &amp;(1&lt;&lt;0))==1) ? 1 : 0 ; DATA1=((com &amp;(1&lt;&lt;1))==1) ? 1 : 0 ; DATA2=((com &amp;(1&lt;&lt;2))==1) ? 1 : 0 ; DATA3=((com &amp;(1&lt;&lt;3))==1) ? 1 : 0 ; DATA4=((com &amp;(1&lt;&lt;4))==1) ? 1 : 0 ; DATA5=((com &amp;(1&lt;&lt;5))==1) ? 1 : 0 ; DATA6=((com &amp;(1&lt;&lt;6))==1) ? 1 : 0 ; DATA7=((com &amp;(1&lt;&lt;7))==1) ? 1 : 0 ; &#125;//correctvoid DATA_Process(uint8_t com)&#123; DATA0=(com &amp;(0x01&lt;&lt;0)) ? 1 : 0 ; DATA1=(com &amp;(0x01&lt;&lt;1)) ? 1 : 0 ; DATA2=(com &amp;(0x01&lt;&lt;2)) ? 1 : 0 ; DATA3=(com &amp;(0x01&lt;&lt;3)) ? 1 : 0 ; DATA4=(com &amp;(0x01&lt;&lt;4)) ? 1 : 0 ; DATA5=(com &amp;(0x01&lt;&lt;5)) ? 1 : 0 ; DATA6=(com &amp;(0x01&lt;&lt;6)) ? 1 : 0 ; DATA7=(com &amp;(0x01&lt;&lt;7)) ? 1 : 0 ; ｝ 当调用该函数时，错误案例是无法实现相应的输出的 1DATA_Process(0xff); 提示：因为是 按位&amp; ，所以得出来的值 并非 1 或0 ；只有 &amp;&amp; 条件判断 才是得出来的值 1或0。 2.4 优先级 三、预处理&emsp;&emsp;预处理是在编译环节中最早开始执行的，并且后面的代码(因条件变化)都不会影响到任何预处理的一些操作(例如：#define) 3.1 宏定义12#define //定义一个预处理宏#undef //取消宏的定义 举例如下 1#define SREG (*(volatile unsigned char*)0x5F) &emsp;&emsp;嵌入式系统编程，要求程序员能够利用C语言访问固定的内存地址。 既然是个地址，那么按照C语言的语法规则，这个表示地址的量应该是指针类型。 所以，知道要访问的内存地址后，比如0x5F，第一步是要把它强制转换为指针类型(unsigned char*)0x5F，AVR的SREG是八位寄存器，所以0x5F强制转换为指向unsigned char类型。 volatile（可变的）这个关键字说明这变量可能会被意想不到地改变，这样编译器就不会去假设这个变量的值了。这种“意想不到地改变”，不是由程序去改变，而是由硬件去改变——意想不到。 第二步，对指针变量解引用，就能操作指针所指向的地址的内容了*(volatile unsigned char*)0x5F 第三步，小心地把#define宏中的参数用括号括起来，这是一个很好的习惯，所以 #define SREG ((volatile unsigned char)0x5F) 类似的，如果使用一个32位处理器，要对一个32位的内存地址进行访问，可以这样定义： 1#define RAM_ADDR (*(volatile unsigned long *)0x0000555F) &emsp;&emsp;然后就可以用C语言对这个内存地址进行读写操作了. 读：tmp = RAM_ADDR；写：RAM_ADDR = 0x55； 3.2 条件编译12345678910#ifdef //判断某个宏是否被定义，若已定义，执行随后的语句#ifndef //与#ifdef相反，判断某个宏是否未被定义#if //编译预处理中的条件命令，相当于C语法中的if语句#elif //若#if,或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if#else //与#if对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else#endif //#if,#ifdef,#ifndef,这些条件命令的结束标志#error //用于生成一个编译错误的消息，并停止编译 条件编译的意义，实际工程中条件编译主要用于以下情况： 不同的产品线公用一份代码 区分编译产品的调试版和发布版 方便变动程序，例如不同的软件驱动方式 举例： 123#if Test_Version_Enable #error "The version is a test version,please try it to be unable"#endif 四、函数的设计技巧 参数名要能够体现参数意义 如果说传递的参数为指针，且仅仅作输入参数用，则应在类型前加const，以防止该指针在函数体内被恶意修改 不要省略返回值的类型，如果函数没有返回值，那么应当声明为void 在函数体的“入口处”，对参数的有效性进行检查，对指针的检查尤为重要 语句不可返回指向“栈内存”的“指针”，因为该内存会在函数结束后销毁 相同的输入应当产生相同的输出，尽量避免函数带有“记忆”功能少用static 避免函数有太多的参数，参数个数应当控制在4个以内 有时候函数不需要返回值，但是增加灵活性，可以附加返回值]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>符号</tag>
        <tag>预处理</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迟来的总结]]></title>
    <url>%2F2020%2F03%2F14%2F%E8%BF%9F%E6%9D%A5%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近真的是，又懒又菜啊！整理这么久= =]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划整理]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%AE%A1%E5%88%92%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[作为备忘录，记录自己要做的事情 11点睡觉 健身，跑步 时常要审视自己:对熟人的态度，对陌生人的态度 linux ucosii 有道云笔记c语言整理 学习github代码管理 嵌入式C_博文改进：结构体成员指针初始化问题，看收藏，或者第一本笔记 modbus通讯_博文改进(1)Modbus从机(2)Modbus主机(3)Modbus通讯例子 中断_定时器_博文改进：(1)待增加线程任务(2)定时器延时的副作用，轮询，扫描按键作为举例 Keil软件配置_博文改进：增加github上传处理 TCP/IP博文 差驱动 英文 注释 perip 外围 param 参数 offset 偏移 backups 备份 宏定义尝试修改SPI meset panel IO口自定义管脚博文 ADC转换带滤波博文（未来）（IF（实际重量》最大量程+9*分度） ofl） leetcode modbus通讯暂时]]></content>
  </entry>
  <entry>
    <title><![CDATA[IO口配置]]></title>
    <url>%2F2020%2F01%2F14%2FIO%E5%8F%A3%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇为基本IO配置，其思路适用于任意款MCU 一、STM32四种管脚模式对比 普通推挽输出（ GPIO_Mode_Out_PP ） :使用场合：一般用在0V 和 3.3V 的场合。线路经过两个P_MOS和 N_MOS管，负责上拉和下拉电流。使用方法：直接使用输出电平：推挽输出的低电平是 0V，高电平是 3.3V。 普通开漏输出（ GPIO_Mode_Out_OD ）：使用场合：一般用在电平不匹配的场合，如需要输出 5V 的高电平。使用方法：就需要再外部接一个上拉电阻，电源为5V，把 GPIO设置为开漏模式，当输出高组态时，由上拉电阻和电源向外输出5V 的电压。输出电平：在开漏输出模式时，如果输出为0，低电平，则使 N_MOS导通，使输出接地。若控制输出为 1（无法直接输出高电平）， 则既不输出高电平也不输出低电平， 为高组态。为正常使用，必须在外部接一个上拉电阻。特性： 它具“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态， 才由上拉电阻提供高电平 ， 此高电平的 电压 为外部 上拉电阻所接的 电源 的电压。若其中一个引脚为低电平，那线路就相当于短路 接地 ，使得整条线路都为低电平，0 V。 复用推挽输出（ GPIO_Mode_AF_PP ） : 用作串口的输出。 复用开漏输出（ GPIO_Mode_AF_OD ）：用在 IIC 。 Ps：所有的开漏输出都需要接上拉电阻 二、IO(按键)输入消抖&emsp;&emsp;IO(按键)输入的消抖，往往是嵌入式开发的排名前几门基础课。消抖方法分为2种：1)硬件消抖； 2)软件消抖；这里就不讲解硬件消抖方式，主要讲软件消抖； 软件消抖也分为2种: 死循环延迟消抖 定时器轮询消抖； 这里讲解采用定时器轮询消抖方式。 定时器轮询消抖有什么好处？ 那 定时器轮询消抖 需要什么？ 实现思路、功能分层？ Ps：轮询的好处：IO(按键)输入的响应速度，直接与(裸机)系统效率挂钩；一旦其他地方出现问题，程序bug存在可以影响到IO(按键)输入的响应速度；采用轮询机制，在MCU从裸机移植到系统上，也会是十分便利 定时器轮询消抖的好处：很明显，相对死循环延迟，定时器轮询 不会空白占用浪费CPU的资源 定时器消抖需要一个定时器；往往在MCU系统中，一般有公用基准1ms的定时器，用于各类操作，直接采用该定时器即可 实现思路、功能分层？以下均为实现功能的函数1)(基本的)IO口初始化配置2)无消抖 单输入(按键)扫描3)消抖处理：循环调用 无消抖单输入扫描；每次程序重新轮询一次，检查现电平状态相比之前是否翻转；翻转则重新备份时间(采取定时器当前时间)，利用备份时间和当前时间 计算出来的时间差，实现延时消抖； 三、IO口自定义功能&emsp;&emsp;IO口自定义是一个在基础功能外扩展的功能；当我们有一定量的IO(按键)输入和输出时，哪个输入(按键)往往都制定好什么功能，输出IO也根据程序条件判断做对应操作；举个例子，当我们想把A键的功能和B键的功能互挪，我们就需要重新更改固件程序；IO口自定义，可以实现无需更改固件程序，直接在线更改输入输出管教功能。 实现思路如下：&emsp;&emsp;将各种功能以枚举的方式罗列出来；利用数组的方式，将 IO口[功能] 和 功能[IO口] 两个数组，相互映射；先由 IO口 映射到 功能 去 ，程序只根据条件变动 功能 ，然后再 功能 映射回 IO口 ，实现底层的电平操作 以下为实现IO口自定义功能的细节： 1)额外设计掉电储存功能；因为当你设置好每个按键功能后，如果掉电不保存，则每次重新上电需要重新设置功能；2)程序上电初始化，先进行IO口初始化；然后再进行IO口自定义初始化：从掉电存储读取IO功能，更新到对应的IO口；每次更新功能，存储一次对应掉电数据，读取数据只在重新上电初始化执行一次；3)自定义功能复位；每个可自定义功能的IO口，原本就该有自带的默认功能，然后根据需求再改动，对应的，也要有复位默认功能的操作； 数据掉电保存方法 1)外扩额外的ROM(例：24C02)2)基于备份寄存器特点：备份寄存器是依赖者备份电源的，当外界的VDD掉电，只要系统的VBAT能正常存在，那么Bakeup Domaain Registers的内容可以被正常保存起来。3)基于内部闪存原理：FLASH 存储器又称为闪存，它也是可重复擦写的储器。它分为 NOR FLASH 和 NAND FLASH，NOR FLASH一般应用在代码存储的场合，如嵌入式控制器内部的程序存储空间；而 NAND FLASH 一般应用在大数据量存储的场合，如U 盘以及固态硬盘等，一般都是 NAND FLASH 类型的。 &emsp;&emsp;在stm32芯片中，Flash的读写单位都是以“页”为单位的，以STM32F103C8T6为例，它的每页大小为2K bytes;读写保护解除：使用这种方法前提是，当前Flash页的读和写是允许的。 特点：使用该方法，相对比较复杂。但是由于保存数据以页为单位，页的大小可以多达2048bytes，所以该方法可以实用于保存掉电不易失的大数据。考虑到flash读写保护的逻辑机制，该方法最好在不考虑数据的安全性问题前提下，才使用这种方法。 四、预置点4.1 常规预置点4.2 优化预置点五、IO辅助逻辑]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>IO口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32开发]]></title>
    <url>%2F2020%2F01%2F09%2FSTM32%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;水平有限，可能其中也有错误，希望各位大佬提醒和海涵 一、硬件IO驱动异常&emsp;&emsp;Bug现象：刚写一个 功能(驱动)，出现异常；经过多次排查后，发现是硬件IO驱动初始化(部分IO异常)的问题。问题来源： 时钟使能问题； 该管脚为(默认)复用管脚； 1.1 宏定义错误&emsp;&emsp;其实在STM32库(其他芯片也是)，库函数初始化中的所有选项， 均为(寄存器)宏定义 的一个特殊数值；具体例子如下： 12RCC_APB1PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //使能 GPIOB端口 时钟RCC_APB2PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); //使能 串口2 时钟 很明显，上面两行代码的时钟使能是错误的，但是编译是不会报错的；因为本质上就是一个赋值操作，赋错值并不会产生报错，除非类型不同、宏定义名称查询不到。不单单是IO的驱动，不管是什么驱动，大家在配置底层驱动的时候一定要细心，配置错误不一定会报警，但是会卡住你。 1.2 关闭JTAG功能当普通IO口用&emsp;&emsp;例如：PA15是个复用引脚；关闭JTAG功能，把PA15当作普通IO口使用就行了。而下载调试程序就要使用SWD功能（平常应该都是用的SWD下载调试）。 12RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //使能复用时钟GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);//关闭jtag，使能SWD，可以用SWD模式调试 划重点：初始化中，必须使能 复用端口RCC_APB2Periph_AFIO的时钟 才能对应关闭JTAG功能 二、STM32管脚四种输出模式对比 普通推挽输出（ GPIO_Mode_Out_PP ） : 使用场合：一般用在0V 和 3.3V 的场合。线路经过两个P_MOS和 N_MOS管，负责上拉和下拉电流。 使用方法：直接使用 输出电平：推挽输出的低电平是 0V，高电平是 3.3V。 普通开漏输出（ GPIO_Mode_Out_OD ）： 使用场合：一般用在电平不匹配的场合，如需要输出 5V 的高电平。使用方法：就需要再外部接一个上拉电阻，电源为5V，把 GPIO设置为开漏模式，当输出高组态时，由上拉电阻和电源向外输出5V 的电压。 输出电平：在开漏输出模式时，如果输出为0，低电平，则使 N_MOS导通，使输出接地。若控制输出为 1（无法直接输出高电平）， 则既不输出高电平也不输出低电平， 为高组态。为正常使用，必须在外部接一个上拉电阻。 特性： 它具“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态， 才由上拉电阻提供高电平 ， 此高电平的 电压 为外部 上拉电阻所接的 电源 的电压。若其中一个引脚为低电平，那线路就相当于短路 接地 ，使得整条线路都为低电平，0 V。 复用推挽输出（ GPIO_Mode_AF_PP ） : 用作串口的输出。 复用开漏输出（ GPIO_Mode_AF_OD ）：用在 IIC 。 Ps：所有的开漏输出都需要接上拉电阻 三、中断&emsp;&emsp;中断的概念具体就不赘述，这里以stm32F103RBT6芯片为例讲中断配置 3.1 抢占优先级和响应优先级&emsp;&emsp;STM32的中断向量具有两个属性，一个为抢占属性，另一个为响应属性，其属性编号越小，表明它的优先级别越高。&emsp;&emsp;抢占，是指打断其他中断的属性，即因为具有这个属性会出现嵌套中断（在执行中断服务函数A 的过程中被中断B打断，执行完中断服务函数B，再继续执行中断服务函数A），抢占属性由NVIC_IRQChannelPreemptionPriority 的参数配置。&emsp;&emsp;响应，应用在抢占属性相同的情况下，当两个中断向量的抢占优先级相同时，如果两个中断同时到达，则先处理响应优先级高的中断， 响应属性由NVIC_IRQChannelSubPriority 参数配置。&emsp;&emsp;如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行 3.2 NVIC 的优先级组&emsp;&emsp;STM32的NVIC 有十六个优先级（一）STM32分组为：组0-4（二）分组配置在寄存器SCB-&gt;AIRCR中： （三）解析第二点 组0就是4位都用来设置成响应优先级，2^4=16位都是响应优先级 组1分为（2^1）两个抢占优先级，在这两个抢占优先级里面还分别有（2^3）八个响应优先级，（2^1） * （2^3） =16 组2分为（2^2）四个抢占优先级，在这四个抢占优先级里面还分别有（2^2）四个响应优先级，（2^2） * （2^2） =16 组3分为（2^3）八个抢占优先级，在这八个抢占优先级里面还分别有（2^1）两个响应优先级，（2^3） * （2^1） =16 组4分为（2^4）十六个都是抢占优先级 （2^4） =16 （四）配置示例 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 也就是说可以配置成四个抢占优先级，在这四个抢占优先级中还可以配置四个响应优先级 （五）优先级顺序举例&emsp;&emsp;假定设置中断优先级组为2，然后设置中断3(RTC中断)的抢占优先级为2，响应优先级为1中断6（外部中断0）的抢占优先级为3，响应优先级为0中断7（外部中断1）的抢占优先级为2，响应优先级为0。&emsp;&emsp;那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6 四、定时器&emsp;&emsp;STM32 的高级定时器TIM1, TIM8以及通用定时器TIM9, TIM10, TIM11的时钟来源是APB2总线;通用的 TIM2、TIM3、TIM4 和 TIM5 定时器 挂载在低速的APB1总线上。 4.1 时钟疑问疑问：以F103为例，APB1 提供时钟：他的最大值是 36M。有很多人不理解，为什么 TIM2 的时钟不是 36M 而是 72M呢？通用定时器（TIM2-7）的时钟不是直接来自APB1，而是通过APB1的预分频器以后才到达定时器模块 APB1 的时钟最大只能是 36M,在 RCC 时钟配置的函数，也就是程序最开始初始化系统时钟到 72M（AHB）的时候,里面有 1RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2; 除以了 2，也就是在我们配置 AHB 为 72M 的时候 APB1 是 72/2=36M. 根据当APB1的预分频系数为1 时，这个倍频器不起作用，定时器的时钟频率等于 APB1 的频率；当 APB1 的预分频系数为其它数值(即预分频系数为 2、4、8 或 16)时，这个倍频器起作用，定时器的时钟频率等于 APB1 的频率两倍。这里我们设置的是 2，那么到定时器就要乘以 2，那么就是 72M 了 &emsp;&emsp;综上，通用定时器的时钟最大为72MHz，挂在APB1上除了通用定时器的其他外设时钟最大为36MHz。这样设计的目的就是让挂在APB1上的低速外设有合适的低速时钟，同时还可以让挂在APB1上的通用定时器能够在不影响低速外设的情况下仍然有高速的时钟。(注：系统时钟初始化后，默认AHB是72MHz，APB1是AHB的2分频36MHz，通用定时器时钟是APB1的两倍72MHz) 4.2 定时器计时&emsp;&emsp;定时器跟时间相关的量有：系统时钟、分频系数、重装载值 系统时钟: 默认不配置的时候是72M，可以根据自己需求配置；分频系数: psc,就是对系统时钟进行多少分频之后在使用，最好设置为72的倍数，方便运算；重新装载值: arr,是计算这么多值，时间到了之后重新开始计算的值，每一次计数的时间为分频之后时钟的到时； 举例：假设系统时间72M，分频系数设置为7200-1，那现在定时器的时钟为10kHz，每计一个数花费1/（10000）秒，重装值设置为5000-1，那一次溢出的时间为500ms。 Time = （（period+1）*（prescaler+1））/sysclocktime：溢出时间(MHz)sysclock：系统时钟（us）period：重装值prescaler：分频系数 time = ((4999+1)*(7199+1))/72 = 5000 000us = 500ms 4.3 计时拓展&emsp;&emsp;定时器的计时可以采用 任务机制回调；实现思路如下： 创建结构体数组，用于存放 多定时器任务 数据；结构体内容如下： 123456789/*******************************************************************************块注释：结构体定义声明*******************************************************************************/typedef struct&#123; volatile uint32_t Time_task_name; //任务名称（组名称或上ID号码） volatile uint32_t Time_Out; //超时时间 volatile uint32_t Time_Count; //任务启动为止到当前的时间 FUNCTION* callback_F; //回调函数&#125;TIMER_TASK; //定义添加执行任务所需要的数据 创建任务需要：任务名称，设定时间，回调函数名； 定时器中断会循环检索任务的存在；如果任务存在则对应的Time_Count(任务计时)++；如果Time_Count和Time_Out(设定时间)相同，则重置Time_Count，并执行回调； 回调函数一般短小精悍，因为是在中断内处理；用于置某些标志位或者关闭自身定时器任务 实现具体细节如下(均为功能函数)： 创建某个定时器任务 复位某个定时器任务 清除某个定时器任务(一般在回调函数中使用) 清除全体定时器任务 获取当前定时器计数(函数返回值) 五、串口通讯&emsp;&emsp;这里讲串口一般会遇到的问题； 5.1 TXE 和 TC&emsp;&emsp;串口的发送TX标志位 USART_FLAG_TXE 和 USART_FLAG_TC的理解:1)TXE是指“手里要搬运的”空；2)TC 是指“地上要搬运的”空； USART_FLAG_TXE 来说，只是说明数据寄存器中的数据已经被发送移位寄存器取走了USART_FLAG_TC来说，没必要每次当发送移位寄存器中的数据发送完成后都发生中断，而应该是整个串口数据帧全部发送完毕，包括最后一个字节也发送出去之后才应该开中断，这代表的就是一个数据帧发送完成事件了。 5.2 不停进入串口中断的Bug&emsp;&emsp;Bug现象：在使用stm32的时候，发现usart会莫名的卡在串口中断里，然而串口初始化只配置了RXNE中断，打断点发现不断进入中断却发现不是RXNE中断引起的 该Bug来源：经过查找资料发现是ORE的问题：开启RXNE中断同时， ORE 也会被开启； 但是如果直接用 USART_GetITStatus 无法读取到ORE标志位 置位的信息，这样也就无法消除中断申请(不知道什么时候置位)，一直进入串口中断；因为我们没有使能ORE标志位，所以才读不到 置位 信息；故 1USART_ITConfig(USART1, USART_IT_ORE, ENABLE); 然后在串口中断内做对应处理： 12345//注意！不能使用if(USART_GetITStatus(_UART_M, USART_IT_RXNE) != RESET)来判断if(USART_GetITStatus(_UART_M,USART_IT_ORE) != RESET)&#123; USART_ClearITPendingBit(_UART_M,USART_IT_ORE);&#125; STM32中文参考手册541页，内容如下： ORE：过载错误 (Overrun error)当RXNE仍然是’1’的时候，当前被接收在移位寄存器中的数据，需要传送至RDR寄存器时，硬件将该位置位。如果USART_CR1中的RXNEIE为’1’的话，则产生中断。由软件序列将其清零(先读USART_SR，然后读USART_CR)。0：没有过载错误；1：检测到过载错误。注意：该位被置位时， RDR寄存器中的值不会丢失，但是移位寄存器中的数据会被覆盖。如果设置了EIE位，在多缓冲器通信模式下，ORE标志置位会产生中断的 STM32串口中断卡死主循环问题分析关于USART接收中断的BUG和注意事项关于STM32不断进入串口中断的问题 六、程序跑飞&emsp;&emsp;程序跑飞有两种情况：1)人为程序代码逻辑问题；2)进入HardFault_Handler1)代码逻辑问题，往往是逻辑错误(缺少)，进入死循环；可以通过软件仿真，很快就能排查该问题2)HardFault_Handler的问题比较麻烦，这里讲其相关的问题 6.1 HardFault_Handler的原因&emsp;&emsp;在用Keil对STM32的程序进行仿真时程序有时会跑飞，停止仿真程序会停在HardFault_Handler函数里的死循环while(1)中。这说明STM32出现了硬件错误。 STM32出现硬件错误可能有以下原因： 数组越界操作； 内存溢出，访问越界； 堆栈溢出，程序跑飞；(大多数是因为中断嵌套) 中断处理错误； 遇到这种情况，可以通过以下方法来定位到出错代码段。 6.2 解决方法&emsp;&emsp;在HardFault_Handler函数中，一般为 C语言的 While(1); 或 汇编的 B . ，实际效果都一样(死循环)。 方法1 1.1 在硬件中断函数HardFault_Handler里的while(1)处打调试断点，程序执行到断点处时点击“STOP”停止仿真。 1.2 在Keil菜单栏点击“View”——“Registers Window”，在寄存器查看窗口查找R14(LR)的值。如果R14(LR) = 0xFFFFFFE9，继续查看MSP（主堆栈指针）的值，如果R14(LR) = 0xFFFFFFFD，继续查看PSP（进程栈指针）的值。我的程序R14(LR) = 0xFFFFFFF9，接下来以此为例。 1.3 在Keil菜单栏点击“View”——“Memory Windows”——“Memory1”，在“Address”地址栏中输入MSP的值：0x20001288，然后在对应的行里找到地址。地址一般以0x08开头的32位数。本例中，地址为0x08003CB9。 1.4 在Keil菜单栏点击“View”——“Disassembly Window”，在“Disassembly”窗口中右击，在下拉菜单中选择“Show Disassemblyat Address…”。在弹出框“Show Code atAdress”的地址框中输入地址0x08003CB9进行搜索，然后就会找到相对应的代码。这里的代码就是进入循环中断之前的情况。仔细查看附近区域的相关代码来排查错误具体原因。 方法2 2.1 在硬件中断函数HardFault_Handler里的while(1)处打调试断点，程序执行到断点处时点击“STOP”停止仿真。 2.2 在Keil菜单栏点击“View”——“Call Stack Window”弹出“Call Stack + Locals”对话框。然后在对话框中右键选择“Show Caller Code”，就会跳转到出错之前的函数处，仔细查看这部分函数被调用或者数组内存使用情况。 方法3 &emsp;&emsp;默认的HardFault_Handler处理方法不是B .这样的死循环么？将它改成BX LR直接返回的形式，然后在这条语句打个断点；一旦在断点中停下来，说明出错了，然后再返回，就可以返回到出错的位置的下一条语句那儿 12345678910__asm void wait()&#123; BX lr&#125;void HardFault_Handler(void)&#123; /* Go to infinite loop when Hard Fault exception occurs */ wait();&#125; 6.3 具体案例分析&emsp;&emsp;这里介绍 不断进入串口中断的问题分析，提供一种(遇到其他Bug时也可以借鉴)思路现象：使用STM32作为主控，程序运行一段时间后概率出现主循环卡死。问题分析和解决方法如下： 主循环卡死； 仿真并未进入HardFault； 仿真一直死循环在USART2中断处理(不做其他处理) 关闭对应USART2功能，系统正常 检查USART2接收中断标志是否忘记清除； 确认好Bug来自于STM32串口中断异常 确认Bug来自于STM32串口中断异常，可能原因如下：7.1 USART2接收中断标志没有清除；7.2 堆栈数据溢出，导致程序异常；7.3 USART2中断ERR；7.4 USART2中断重入导致异常；7.5 USART2中断函数被异常响应； 综上所述：8.1 开始面向X度编程 or8.2 查看STM32中文参考手册 串口章节 七、UCOSIII系统7.1 把一个裸机程序移植到ucos系统 先把裸机任务改一个名字；先在芯片上把ucos跑起来，启动一个ucos任务调用裸机的main函数就可以了； 先都放在一个进程中，再慢慢剥离到其他进程;想要优化程序的话你就将原来裸机的程序分成几个任务，再按照每个任务的重要性选择任务优先级和大小以及任务执行间隔。 清理原来的程序，区分出任务和任务间通信的数据；把任务按一定的优先级整理好，创建到UCOS中；再把任务间通信的数据，采用UCOS提供的：信号量、锁，队列等，机制建立起来。 然后，把任务和数据关联起来，再进一步调试，跑系统。特别注意有没有优先级反转、死机，任务饥饿等问题 八、Bootloader&emsp;&emsp;一个成熟的嵌入式产品，往往有 软件升级 的功能；升级的功能 需要用到Bootloader。Ps：BootLoader的实现还是需要靠BootLoader程序和App程序的配合才能正常使用：App程序需要重定位中断向量表，才能正常工作。 对于嵌入式系统来说，常见的升级方式为:1)串口升级(私有协议或者X－Modem)2)USB升级(DFU)3)U盘升级(OTG)4)网络升级5)无线升级(OTA) 8.1 hex文件和bin文件&emsp;&emsp;Bootloader程序升级，往往是采用写入bin文件；那hex文件和bin文件有什么关系呢？ hex文件 &emsp;&emsp;hex文件是以ASCII文本形式保存编译后的二进制文件信息。Hex文件使用ASCII文本的形式保存Bin文件的内容和Bin文件的一些配置信息。hex文件可以由下载器（比如jlink）烧写到MCU的ROM中。&emsp;&emsp;平时用J-LINK或者串口下载程序，都是下载hex文件的;因为hex文件包含地址信息，下载程序的时候知道程序下载到ROM的哪个区域。反过来讲，hex文件是不能直接写进ROM的，一边写需要一边转换(解码出地址信息，将对应内容写入ROM)。 bin文件 &emsp;&emsp;Bin文件是MCU固件烧写的最终形式，也就是说MCU的ROM中烧写的内容完全就是Bin文件的内容。 区别 &emsp;&emsp;Hex文件有更好的可读性，最重要的是hex文件能够保证固件在保存与传输时的完整性。因此hex文件更适用于保存与传输。而Bin文件是纯二进制文件，内部只包含程序编译后的机器码和变量数据。当文件损坏时，我们也无法知道文件已损坏。不过Bin文件作为固件的最终形式，在使用串口下载程序或者远程升级时，是不可替代的。 bin文件生成 &emsp;&emsp;默认情况下编译后生成的是hex文件，没有生成bin文件。keil的Bin文件生成方式有很多种，可以另外下载一个hex2bin工具，然后用Keil脚本执行；这里，介绍使用Keil自带的工具fromelf.exe。在Keil的安装目录下，例如：E:\Keil\ARM\ARMCC\bin\fromelf.exe 第一种方式：设置绝对路径(不建议这样做，别人用你工程需要再次修改路径) 1D:\Program Files\MDK516\ARM\ARMCC\bin\fromelf.exe" --bin -o ./obj/test_app.bin ./obj/test_app.axf 第二种方式：相对路径，直接复制下面的路径就能直接使用 1$K\ARM\ARMCC\bin\fromelf.exe --bin --output=@L.bin !L bin文件生成在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下你可看到一个test1.bin（名字是根据你的hex文件名字一样）。 希望生成.bin文件输出在当前工程下的指定目录，比如Bin文件夹，可如下操作： 1$K\ARM\ARMCC\bin\fromelf.exe --bin --output=Bin\@L.bin !L 生成的文件也是在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下，可看到一个新生成的Bin文件夹，里面是test1.bin。 8.2 Flash地址0x08000000 为什么STM32从Flash地址0x08000000的启动重映射? &emsp;&emsp;在初写STM32程序时，遇到一个困惑，STM32的Flash在MDK里被设置为起始地址0x0800 0000，而CM3手册规定芯片复位时要从0x0000 0000地址开始取出中断向量 ，那STM32怎么样执行代码呢？地址重映射？或者在0x0000 0000里有对应有实际存储器？ 仔细阅读手册，发现这件事是因为STM32设计的Flash起始地址是在0x0800 0000位置开始的。全部代码都只能从这里开始存储。详见STM32 referenc manual手册第54页。 那既然从这里才能存储代码，就必须在MDK里设置Flash地址为0x0800 0000，下面是MDK设置页面，这个应该都看到过。 &emsp;&emsp;这样就还有一个问题，理论上，CM3中规定上电后CPU是从0地址开始执行，但是这里中断向量表却被烧写在0x0800 0000地址里，那启动时不就找不到中断向量表了？既然CM3定下的规矩是从0地址启动，SMT32当然不能破坏ARM定下的“规矩”，所以它做了一个启动映射的过程，就是和芯片上总能见到的BOOT0和BOOT1有关了，当选择从主Flash启动模式后，芯片一上电，Flash的0x0800 0000地址被映射到0地址处，不影响CM3内核的读取，所以这时的CM3既可以在0地址处访问中断向量表，也可以在0x0800 0000地址处访问中断向量表，而代码还是在0x0800 0000地址处存储的。这就是最难理解的地方，其实，这是基本上所有ARM芯片采用的启动映射方法。ARM7，ARM9没有内部Flash的通常都是这样做的。这个过程出自STM32 referenc manual手册，里面是有说明的。 还要注意，这个中断向量表是可以在程序中再次被映射的。控制它的就是CM3已经规定的NVIC寄存器SCB->VTOR。在STM32库中给出的启动代码里，startup_stm32f10x_hd.s文件里，第146行，是上电后读取中断向量表中的复位中断位置，并执行复位中断处理代码，代码如下： 12345678910; Reset handlerReset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT __main IMPORT SystemInit LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP 注意复位后第一个被执行的是SystemInit代码，这个代码在库目录下的system_stm32f10x.c文件里，它初始化了时钟，NVIC等一系列操作，这里摘要与中断向量有关的代码： 12345678910void SystemInit (void)&#123;......#ifdef VECT_TAB_SRAM SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */#else SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */#endif &#125; 可以看出中断向量重映射是一个选择性编译，通常宏定义VECT_TAB_SRAM都没有被定义，所以这里执行结束后，SCB->VTOR就是FLASH_BASE了，值为0x0800 0000。以后CM3再取中断向量里，就会根据SCB->VTOR的设置，从这里取向量执行了。中断向量自此终于转正。 注意：这时连__main函数都还没进，看起来中断向量的重映射位置还是够早的。 8.3 Bootloader介绍&emsp;&emsp;源自linux上的BootLoader的概念，在linux上，BootLoader是首先执行的程序，BootLoader启动之后初始化CPU、RAM、Flash等设备，然后从Flash中读取Linux程序数据到RAM中去，最后跳转到RAM中Linux的起始地址中去启动Linux系统。除了从Flash中读取系统启动之外，BootLoader还能通过网络NFS协议从服务器上读取Linux并启动。BootLoader还能够更新Linux内核、配置Linux启动信息、测试系统等等。&emsp;&emsp;在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像Window自带BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。 我们要做的STM32的BootLoader也是类似的工作原理，但是没有Linux系统的BootLoader功能那么强大。我们要做的STM32的BootLoader只有两个主要目的： 跳转到应用程序并执行； 更新应用程序； Ps：因此，下载新程序后并不擦除bootLoader程序，下次启动依然先运行BootLoader程序，可以选择性更新或者不更新程序，所以STM32的BootLoader往往就是用来管理单片机程序的更新。 8.4 Bootloader预备知识8.4.1 复位序列 栈指针复位向量 8.4.2 重定位中断向量表 STM32的中断向量表设置中断向量表偏移 8.4.3 分散加载文件相关 C语言的函数地址BootLoader占用的ROM修改ROM起始地址 8.5 BootLoader的实现8.8 Bin文件合并需要烧录2个bin文件，整个程序才可以正常运行。那如果是量产烧录2次程序是非常耗时间的 目的：合并两个单独程序的bin文件工具：keil，jlink，j-flash ARM 用keil和jlink生成两个bin文件，如何生成不详细解释，主要是几个问题说明一下1)使用jlink时需要注意，尤其是port的选择，明确用jlink是jtag还是sw。2)既然是合并，那么两个bin文件的flash的地址分配需要明确 利用j-flash ARM合并bin文件1)拖拽第一个文件进j-flash ARM，确定好初始地址2)file–message data…–第二个文件，确定好初始地址3)save data file as..保存合并后的文件 使用j-flash ARM进行程序下载1)open project …选择芯片类型2)Options-project setting 进行相关配置，明确用jlink是jtag还是sw。3)注意芯片的选型。参考资料：https://wenku.baidu.com/view/ae895065ddccda38376bafb5.html#####pwm定时器脉冲]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hi,2020]]></title>
    <url>%2F2019%2F12%2F31%2FHi-2020%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今年要好好干，努力奋斗！不要拖稿；干就完了！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议(下)]]></title>
    <url>%2F2019%2F12%2F28%2FTCPIP-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇介绍微观层面的TCP/IP协议————基于W5500的嵌入式TCP通讯开发 一、基础知识&emsp;&emsp;这里将会连续引申出微观TCP/IP协议的一些概念。嵌入式的TCP通讯最重要的一个概念，就是IP地址。 1.1 IP地址1.1.1 概念&emsp;&emsp;IP地址，英文名为IP Address，是internet protocol address的缩写，译为互联网协议地址，又译为网际协议地址。它是IP协议（internet protocol ）提供的一种统一的地址格式，分配给使用IP协议的设备的数字标签。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。更通俗的来说，IP地址给网上的每个通信设备分配了一个编号，每台联网的主机都需要有这个编号来通信。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。 1.1.2 表示通常所说的IP地址，是指IPv4。IP地址是一个32位的二进制数，例如： 100000000111111110000000011111111 通常被分割为4个8位二进制数，例如上面这个IP地址，可以分割为如下形式： 100000000 11111111 00000000 11111111 再使用十进制数来表示每个8位二进制数，十进制数之间使用点号分隔，IP地址最终表示成如下形式： 1a.b.c.d 因为一个8位二进制数表示的范围00000000 ~ 11111111正好对应十进制数0 ~ 255，所以a、b、c和d都是0 ~ 255的十进制整数。例如上面IP地址，可以表示为0.255.0.255.（1）冒分十六进制表示法 1X:X:X:X:X:X:X:X &emsp;&emsp;其中每个X表示地址中的16b，以十六进制表示，例如： 1ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 &emsp;&emsp;这种表示法中，每个X的前导0是可以省略的，例如： 12001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A （2）0位压缩表示法&emsp;&emsp;在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如： 123FF01:0:0:0:0:0:0:1101 → FF01::11010:0:0:0:0:0:0:1 → ::10:0:0:0:0:0:0:0 → :: （3）内嵌IPv4地址表示法为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为： 1X:X:X:X:X:X:d.d.d.d 前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如: 1::192.168.0.1与::FFFF:192.168.0.1 就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用。 1.1.3 IPv4地址分类网络号或网络地址（NetID）：用于识别主机所在的网络；主机号或主机地址（HostID）：用于识别该网络中的主机；&emsp;&emsp;为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。私有地址：所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址。 类别 用途 网络号和主机号 最高位 地址范围 私有地址和保留地址 子网掩码 A 保留给政府机构 第一段表示网络地址，剩下三段表示主机地址 0 0.0.0.0——127.255.255.255 ①10.X.X.X是私有地址 ②127.X.X.X是保留地址 255.0.0.0 B 分配给中等规模的公司 前两段表示网络地址，后两段表示主机地址 10 128.0.0.0——191.255.255.255 ①172.16.0.0—172.31.255.255是私有地址②169.254.X.X是保留地址；191.255.255.255是广播地址，不能分配。 255.255.0.0 C 分配给任何需要的人 前三段表示网络地址，剩下一段表示主机地址 110 192.0.0.0——223.255.255.255 192.168.X.X是私有地址 255.255.255.0 D 用于组播 不分网络地址和主机地址 1110 224.0.0.0——239.255.255.255 E 用于实验 不分网络地址和主机地址 11110 240.0.0.0——255.255.255.254 如图： &emsp;&emsp;这里就不再详细介绍IP地址中的一些特殊地址了；我们目前主要用的是C类别，也就是192.168.X.X的私有地址 1.2 子网掩码&emsp;&emsp;IP地址填完后，网段不同，是并不能够直接通讯的；(平常)路由器连接的是不同的网络，网桥连接的是不同网段，这里的网络和网段有什么区别呢？ 1.2.1 网段&emsp;&emsp;路由器连接的是不同的网络，这里的网络就是网段不同的网段和不同的网络是同一个概念；专业点就说网段，通俗一点就说网络，其实就是一个意思。 那什么是同一网段？同一网段指的是IP地址和子网掩码相与得到相同的网络地址；想在同一网段，必需做到网络标识相同；各类IP的网络标识算法都是不一样的，需要根据子网掩码的位数来判断。 那什么是掩码？ 想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？ 1.2.2 掩码&emsp;&emsp;掩码，是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。用途：将源码与掩码经过按位运算或逻辑运算得出新的操作数。其中要用到按位运算如OR运算和AND运算。用于如将ASCII码中大写字母改作小写字母。 举例：如A的ASCII码值为65= (01000001)2，a的ASCII码值为97=(01100001)2，要想把大写字母A转化为小写字母只需要将A的ASCII码与(00100000)2进行或运算就可以得到小写字母a。&emsp;&emsp;子网掩码，即就是用来算网络标识的掩码. 1.2.3 网络标识 算法只要把IP和子网掩码的每位数AND就可以了。 AND方法：0&amp;1=0 0&amp;0=0 1&amp;1=1 如：And 192.168.0.1，255.255.255.0，先转换为二进制，然后AND每一位 123IP 11000000.10101000.00000000.00000001子网掩码 11111111.11111111.11111111.00000000得出AND结果 11000000.10101000.00000000.00000000 转换为十进制192.168.0.0，这就是网络标识， 再将子网掩码反取，也就是00000000.00000000.00000000.11111111，与IP AND 得出结果00000000.00000000.00000000.00000001，转换为10进制，即0.0.0.1；这0.0.0.1就是主机标识。要想在同一网段，必需做到网络标识一样。 这里介绍最常用的两种子网掩码，它们分别是“255.255.255.0”和“255.255.0.0”。 1.3 网关地址&emsp;&emsp;如果网段不同，就实现不了通信，但现实生活中那么多设备肯定不在同个网段；那么不同网段确能够通信，就需要 网关 了.&emsp;&emsp;网关（gateway）是一个网络连接到另一个网络的“关口”，网关地址实质上是一个网络通向其他网络的IP地址，主要用于不同网络间数据传输。网关在网段内的可用ip中选一个，一般选择是第一个或最后一个。 举例:比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1 ~ 192. 168.1.254”，子网掩码是255.255.255.0；如果需要与其他网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为网段内其他的一个IP地址。网络B的IP地址范围是“192.168.2.1 ~ 192.168.2.254”，子网掩码255.255.255.0。如果需要与其他网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为网段内其它的一个ip地址。 网关是如何实现通信？&emsp;&emsp;在没有路由器的情况下，不同的网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的的主机不再本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。所以说，设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。 网关设置方式有哪些？ 手动设置：手动设置适用于电脑数量比较少、TCP/IP参数基本不变的情况，比如只有几台到十几台电脑。因为这种方法需要在联入网络的每台电脑上设置“默认网关”，非常费劲，一旦因为迁移等原因导致必须修改默认网关的IP地址，就会给网管带来很大的麻烦，所以不推荐使用。 自动设置：利用DHCP服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。这种方法适用于网络规模较大、TCP/IP参数有可能变动的网络。 1.4 MAC地址&emsp;&emsp;媒体访问控制（media access control，MAC）是物理地址、硬件地址，用来定义网络设备的位置。 ip是虚拟地址；mac是网卡地址全世界只有一种没重复的。MAC是网络中用来识别网卡设备的唯一网络地址；由相关硬件制造商统一分配，每台电脑的MAC地址都是唯一的 1.5 DNS&emsp;&emsp;DNS是域名解析服务器，是把网址变成IP地址的服务器。DNS说白了是把域名翻译成IP地址用的； 举例 ，例如我们在浏览器里面输入www.baidu.com的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把www.baidu.com这个域名翻译成了IP地址61.135.169.105。 这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，如果不设置的话，是无法正常访问网页的。 1.6 Socket 和 端口号&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。 这里引入 端口号 的概念：一个计算机上可以有多个进程作为(多个)服务器 or 客户端 ，但是 ip 每个机器只有一个，所以通过不同的 port 数字加以区分。 Ps：端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。 &emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。 Socket ： 就是指代承载这种通讯的系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号) Ps：Socket是一个接口，在用户进程与TCP/IP协议之间充当中间人，完成TCP/IP协议的书写，用户只需理解接口即可。 二、基于W5500的TCP通讯]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 协议 (上)]]></title>
    <url>%2F2019%2F12%2F27%2FTCPIP-%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;该篇介绍宏观层面的TCP/IP协议 一、TCP/IP 协议的层次结构(宏观)&emsp;&emsp;TCP/IP参考模型分为四个层次：应用层、传输层、网络(互连)层和主机到网络层(数据链路层) 1.1 应用层&emsp;&emsp;应用层面向不同的网络应用引入了不同的应用层协议。 传输层采用TCP协议的有：HTTP：超文本传输协议（Hyper Text Transfer Protocol）HTTPS:超文本传输安全协议（Hyper Text Transfer Protocol Secure）FTP：文件传输协议（File Transfer Protocol）它定义了本地登录用户与远程服务器之间的交互过程。SFTP：文件加密传输协议（Secure File Transfer Protocol）TELNET：远程登录（Telecommunications Network）提供远程访问其它主机功能,它允许用户登录 internet主机,并在这台主机上执行命令. 传输层采用UDP协议的有：（一次性传输的数据需求很少）TFTP：简单文件传输协议（Trivial File Transfer Protocol）FTP的简化版本SNMP：简单网络管理协议（Simple Network Management Protocol）该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等.NTP：网络时间协议（Network Time Protocol） 传输层同时采用TCP和UDP协议的有：DNS(域名系统)：该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. Ps：HTTP是面向网页（文本信息）的，而FTP是面向文件的 1.2 传输层TCP：传输控制协议（transmission control protocol）UDP：用户数据报协议（user datagram protocol） TCP与UDP的区别： 基于连接与无连接; 对系统资源的要求（TCP较多，UDP少）; UDP程序结构较简单; 流模式与数据报模式; TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证. TCP 与 UDP 的主要区别：&emsp;&emsp;UDP具有TCP所望尘莫及的速度优势，但在于UDP不一定提供可靠的数据传输。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。 Ps：许多程序将使用单独的TCP连接和单独的UDP连接;重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。 1.3 网络层（网络互连层） &emsp;&emsp;网络互连层定义了分组格式和协议。 &emsp;&emsp;网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。 IP：Internet 协议（Internet Protocol）ICMP：Internet控制信息协议ARP：地址解析协议RARP：反向地址解析协议 1.4 网络访问层（主机到网络层） &emsp;&emsp;网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接。 二、部分具体介绍&emsp;&emsp;TCP/IP协议：是一组网络协议。在这些协议中，最重要、最著名的就是TCP和IP因此，大部分网络管理员称整个协议族为“TCP/IP”。包括：TCP，IP，UDP，ARP等，这些被称为子协议。 2.1 TCP与IP的区别&emsp;&emsp;由第一章的TCP/IP 协议的层次结构可知，TCP 和 IP 是在不同层的，因此两者本来就天差地别。TCP：位于传输层，是一种面向连接的、端对端的、可靠的、基于IP的传输层协议。主要特点是3次握手建立连接，4次挥手断开连接。IP：位于网络层，IP协议规定了数据传输时的基本单元（数据包）和格式，IP协议还定义了数据包的递交办法和路由选择。 总结： 整个网络中的传输流程是：IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层————TCP层；相反，IP层也把从TCP接收来的数据包传送到更低层。 TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步加工，如提供端口号等等。 2.2 Telnet的衍生（SSH等）&emsp;&emsp;TELNET：远程登录（Telecommunications Network）提供远程访问其它主机功能;听起来很陌生，但实际上我们是经常使用远程登录的功能，即使用Telnet的衍生;&emsp;&emsp;Telnet用来訪问远程计算机的TCP/IP协议以控制你的网络设备，是明码传输，缺乏安全性。因此诞生了远程登录的加密传输，如下： SSH：Secure Shell（包括SSH1和SSH2）Telnet/SSL： Secure Socket Layer。Telnet/SSL是带有SSL的Telnet。Rlogin：Rlogin和Telnet功能使用方法相似，可是简单非常多。Serial：串行指每次一个事件，它通常跟并行即一次发生多个事件相反，例如键盘和鼠标仅仅须要串行接口和线路TAPI：telephone Application Programming Interface （它能够使用户在电脑上通过电话或视频电话与电话还有一端的人进行交谈）电话应用编程接口RAW：大多数打印设备的默认协议 2.3 VPN和SS、SSR&emsp;&emsp;这里讲一下大家常见到的VPN和SSR的来头。 2.3.1 什么是VPN&emsp;&emsp;vpn在很多人心目中就是用来科学上网的工具，其实不是。vpn最主要的功能，并不是用来科学上网，只是它可以达到科学上网的目的。vpn–虚拟专用网络，它的功能是：在公用网络上建立专用网络，进行加密通讯。 2.3.2 什么是ss/ssrss：ss作者是clowwindy，大约两年前，他自己为了科学上网写了shadowsocks，简称ss或者叫影梭，后来他觉得这个东西非常好用，速度快，而且不会被封锁，他就把源码共享在了github上，然后就火了，但是后来作者被请去喝茶，删了代码，并且保证不再参与维护更新。现在这个好像是一个国外的大兄弟在维护。 ssr：在ss作者被喝茶之后，github上出现了一个叫breakwa11(破娃)的帐号，声称ss容易被防火墙检测到，所以在混淆和协议方面做了改进，更加不容易被检测到，而且兼容ss，改进后的项目叫shadowsocks-R，简称ssr，然后ss用户和ssr用户自然分成了两个派别，互相撕逼，直到前阵子，破娃被人肉出来，无奈之下删除了ssr的代码，并且解散了所有相关群组。 ss和ssr它的原理都是一样的，就是socks5代理。socks代理只是简单的传递数据包，而不必关心是何种协议，所以socks代理比其他应用层代理要快的多。socks5代理是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地，这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理。通俗的说，现在你有一个代理服务器在香港，比如你现在想要访问google，你的电脑发出请求，流量通过socks5连接发到你在香港的服务器上，然后再由你在香港的服务器去访问google，再把访问结果传回你的电脑，这样就实现了科学上网。]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>SSH</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window的简易bat处理]]></title>
    <url>%2F2019%2F12%2F22%2FWindow%E7%9A%84%E7%AE%80%E6%98%93bat%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;脚本往往是用来批处理等一些简单的操作等等，因此脚本的编写往往比较简单；这里介绍Window环境下的脚本：Batch(批处理)，可以用于嵌入式批处理一些中间文件 或者 是用来做一些平常处理的快捷操作 一、脚本知识&emsp;&emsp;批处理(Batch)，也称为批处理脚本。批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。批处理文件的扩展名为bat 。&emsp;&emsp;脚本(Script)：是一种批处理文件的延伸，是一种纯文本保存的程序。简介：脚本简单地说就是一条条的文字命令，这些文字命令是可以看到的（如可以用记事本打开查看、编辑），脚本程序在执行时，是由系统的一个解释器，将其一条条的翻译成机器可识别的指令，并按程序顺序执行。因为脚本在执行时多了一道翻译的过程，所以它比二进制程序执行效率要稍低一些。 常见的脚本语言有：Scala、JavaScript，VBScript，ActionScript，MAX Script，ASP，JSP，PHP，SQL，Perl，Shell，python，Ruby，JavaFX，Lua，AutoIt等。 &emsp;&emsp;Makefile：类似shell脚本；Linux的编译程序通过make命令，编译大文件（需要批量处理文件），则需用到Makefile文件 1.1 题外话 &emsp;&emsp;一个C/C++文件要经过预处理（preprocesing）、编译（compilation）、汇编（assembly）、链接（linking） 等四步才能变成可执行文件（实际还是机器码）。在日常交流中通常使用“编译”统称这四个步骤。 .s文件、.S文件和.o文件的区别 .s：汇编语言源程序；操作: 汇编在后期阶段不会再进行预处理操作了，所以我们不能在其内写上预处理语句. .S：汇编语言源程序；操作: 预处理 + 汇编会进行预处理、汇编等操作，所以我们可以在这里面加入预处理的命令。编译器在编译汇编大 S 文件之前会进行预处理操作. .o文件：只编译不链接形成.o文件.里面包含了对各个函数的入口标记，描述，当程序要执行时还需要链接(link).链接就是把多个.o文件链成一个可执行文件。如 GCC 编译器就可以指定 -c选项进行输出。打开是乱码。 .dis文件：反汇编文件 &emsp;&emsp;.s文件一般是 .c文件经过汇编器处理后的输出。 如 GCC 编译器就可以指定 -S 选项进行输出，且是经过预处理器处理后的了。 例如：gcc -S test.c—–生成.s结尾的文件，打开为汇编代码例如：gcc -c test.c—–结果生成.o文件. 二、常见批处理指令&emsp;&emsp;这里只介绍一些小白入门的bat指令，不会太过深入，只是用来简化用电脑时的平常处理；Ps:cmd命令是不区分大小写的 2.1 rem 和 ::REM ，为注释命令，一般用来给程序加上注解，该命令后的内容不被执行，但能回显；:: ，为注释命令，但后面字符行在执行时不会回显 2.2 echo 和 @&emsp;&emsp;这里编写一个.bat文件作为举例： 12345@echo offecho 这是测试内容的第1行echo 这是测试内容的第2行echo endpause 如上面源码所示 修改文件内容，将其中的@ 符号去掉 继续修改文件内容，将第一条命令注释掉(::) 总结：@echo off表示执行了这条命令后关闭所有命令(包括本身这条命令)的回显。echo off 命令则表示关闭其他所有命令(不包括本身这条命令)的回显；@ 的作用就是关闭紧跟其后的一条命令的回显 2.3 pause&emsp;&emsp;如果你自己编写的.bat文件，双击打开，出现闪退；原因：执行速度很快，执行完之后，自行关闭；&emsp;&emsp;解决办法：在最后面一行加上 pause pause，停止系统命令的执行并显示下面的内容;最常见的就是：请按任意键继续. . . 不显示请按任意键继续. . .的方法：pause >nul显示其他提示语的方法：echo 其他提示语 & pause >nul 2.4 titletitle,用于设置cmd窗口的标题title 新标题 可以看到cmd窗口的标题栏变了 2.5 modemode，配置系统设备&emsp;&emsp;这里就不详细讲解，有兴趣的话，可以直接help mode查看；下面举一个控制窗口大小的例子： 12345@echo off@mode con lines=18 cols=55echo "Hello World !"pause 2.6 start&emsp;&emsp;批处理中调用外部程序的命令（该外部程序在新窗口中运行，批处理程序继续往下执行，不理会外部程序的运行状况），如果直接运行外部程序则必须等外部程序完成后才继续执行剩下的指令 例： 调用图形界面打开D盘start explorer d:&lt;/code> 启动一个新的cmd窗口并在其内执行命令start cmd /k echo Hello, World! 2.7 cd同一分区切换:cd [盘符][路径]不同分区切换:cd /d [盘符][路径] Ps： 可以用 echo %cd% 查看当前路径 2.8 dir&emsp;&emsp;dir:获取某个文件夹下所有的文件名及扩展;详细的命令用help查看，下面举常见例子 dir /a 显示当前目录中的文件和子目录，包括隐藏文件和系统文件 dir c: /a:d显示 C 盘当前目录中的目录 dir c: /a:-d显示 C 盘根目录中的文件 dir c:" /b/p/b只显示文件名，/p分页显示 c:\dir /s /q /a *.exedir *.exe /s查找当前目录（包括子目录）下所有的exe文件 c:\dir /q /a *.exe查找当前目录下以a开头的exe文件 2.9 del&emsp;&emsp;要知道区别，就要看DEL命令参数 del d:"test.txt删除指定文件，不能是隐藏、系统、只读文件 del /q/a/f d:"temp"*.*删除 d:”temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录 del /q/a/f/s d:"temp"*.*删除 d:”temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录 3.0 详细的CMD命令&emsp;&emsp;另外详细的CMD命令，可以看这位博主的Windows CMD命令大全 三、批处理中的系统变量%ALLUSERSPROFILE% 本地 返回“所有用户”配置文件的位置。%APPDATA% 本地 返回默认情况下应用程序存储数据的位置。%CD% 本地 返回当前目录字符串。%CMDCMDLINE% 本地 返回用来启动当前的 Cmd.exe 的准确命令行。%CMDEXTVERSION% 系统 返回当前的“命令处理程序扩展”的版本号。%COMPUTERNAME% 系统 返回计算机的名称。%COMSPEC% 系统 返回命令行解释器可执行程序的准确路径。%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关date 命令的详细信息，请参阅 Date。%ERRORLEVEL% 系统 返回上一条命令的错误代码。通常用非零值表示错误。%HOMEDRIVE% 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。%HOMEPATH% 系统 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。%HOMESHARE% 系统 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。%LOGONSERVER% 本地 返回验证当前登录会话的域控制器的名称。%NUMBER_OF_PROCESSORS% 系统 指定安装在计算机上的处理器的数目。%OS% 系统 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。%PATH% 系统 指定可执行文件的搜索路径。%PATHEXT% 系统 返回操作系统认为可执行的文件扩展名的列表。%PROCESSOR_ARCHITECTURE% 系统 返回处理器的芯片体系结构。值：x86 或 IA64 基于Itanium%PROCESSOR_IDENTFIER% 系统 返回处理器说明。%PROCESSOR_LEVEL% 系统 返回计算机上安装的处理器的型号。%PROCESSOR_REVISION% 系统 返回处理器的版本号。%PROMPT% 本地 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。%RANDOM% 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。%SYSTEMDRIVE% 系统 返回包含 Windows server operating system 根目录(即系统根目录)的驱动器。%SYSTEMROOT% 系统 返回 Windows server operating system 根目录的位置。%TEMP% 和 %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要TEMP，而其他应用程序则需要 TMP。%TIME% 系统 返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关time 命令的详细信息，请参阅 Time。%USERDOMAIN% 本地 返回包含用户帐户的域的名称。%USERNAME% 本地 返回当前登录的用户的名称。%USERPROFILE% 本地 返回当前用户的配置文件的位置。%WINDIR% 系统 返回操作系统目录的位置。 举例，如下： 第一种方法显示日期星期及时间精确到毫秒 123@echo offecho %date%%time%pause 第二种方法显示日期及时间精确到秒 123@echo offecho %date:~0,4%年%date:~5,2%月%date:~8,2%日%time:~0,8%pause 四、常见的技巧和情况4.1 不显示代码执行期间的各种提示信息&emsp;&emsp;很多时候，为了使得屏幕上不出现无关的信息，我们需要屏蔽掉命令执行过程中产生的一些提示，有时候是屏蔽掉出错信息，有时候是为了屏蔽成功执行命令的信息，有时候两者都需要屏蔽，那么，我们可以把各种提示信息重定向到空设备中去，具体的代码是：① 如果要屏蔽成功执行命令的信息，请在语句的最后加上代码 &gt;nul。比如 copy a.txt d:\test&gt;nul② 如果要屏蔽出错信息，请在语句最后加上代码 2&gt;nul，需要注意的是，数字2前必须带空格。比如，md test 2&gt;nul，如果当前目录已经存在文件夹test，那么，执行这条语句将不会出现错误提示；③ 如果要同时屏蔽正确执行代码后产生的提示和出错时的信息，请在语句最后加上代码 &gt;nul 2&gt;nul。比如，copy a.txt d:\test&gt;nul 2&gt;nul 这条语句，无论命令是否成功执行，都不会在屏幕上出现任何提示；&emsp;&emsp;善用 nul 2&gt;nul 句式，可以很方便地实现很多目的，比如创建文件夹的时候，无需先用if语句来检测是否已经存在某个目录，直接 md test 2&gt;nul 即可，可以提高代码的执行效率。 4.2 del /a /f *.txt&emsp;&emsp;单独的del命令并不能删除带隐藏或只读属性的文件，于是，很多人自然而然地想到先用 attrib 命令来先给将要删除的文件去掉各种属性。其实，操作过程大可不必如此繁琐，只须给del加上 /a /f 的参数就可以了。 4.3 批处理.bat 文件中输出中文乱码原因：记事本新建的文件，编码不是 utf-8解决方法：用【记事本】打开&gt;【另存为】&gt;【修改编码为：utf-8】操作截图： 效果截图： 五、小白用法&emsp;&emsp;其实说多也无用，毕竟平常实际用到的功能并不多，往往都是在需要实现某个具体的功能才会查询相关的指令进行应用 5.1 删除开发环境生成的中间缓存123456789101112131415161718192021222324252627del *.bak /sdel *.ddk /sdel *.edk /sdel *.lst /sdel *.lnp /sdel *.mpf /sdel *.mpj /sdel *.obj /sdel *.omf /s::del *.opt /s ::不允许删除JLINK的设置del *.plg /sdel *.rpt /sdel *.tmp /sdel *.__i /sdel *.crf /sdel *.o /sdel *.d /sdel *.axf /sdel *.tra /sdel *.dep /s del JLinkLog.txt /sdel *.iex /sdel *.htm /sdel *.sct /sdel *.map /sexit 1234567891011copy Objects\ExecutableFile.hex ExecutableFile.hexdel /Q Listings\*.*del /Q Objects\*.*del /Q *.txtdel /Q *.inidel /Q *.bakdel /Q *.plgdel /Q *.depdel /Q *.Administratorrmdir /s/q DebugConfigexit 5.2 一键开启工作环境123456789101112131415161718192021@echo off title 学习咯reg add "hkcu\control panel\desktop" /v Wallpaper /d "F:\壁纸\Faker.jpg" /freg add "hkcu\control panel\desktop" /v WallpaperStyle /t REG_DWORD /d 2 /fRunDll32.exe USER32.DLL,UpdatePerUserSystemParametersecho.echo 今天是 %date:~0,4% 年 %date:~5,2% 月 %date:~8,2% 日 %time:~0,8%echo.echo.TIMEOUT /T 8start vstart.exeTIMEOUT /T 1start "" "C:\Program Files\Sublime Text 3\sublime_text.exe"TIMEOUT /T 1start "" "D:\Program Files (x86)\Tencent\WeChat\WeChat.exe"start cmd /k "cd /d d:/myblog"exit]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式存储器及其控制总线]]></title>
    <url>%2F2019%2F12%2F21%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8%E5%8F%8A%E5%85%B6%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里分享一下在嵌入式设备的存储器和其对应的控制总线的拓展问题 一、存储器科普&emsp;&emsp;RAM、SRAM、SDRAM、ROM、EPROM、EEPROM、Flash存储器可以分为很多种类;其中根据掉电数据是否丢失可以分为RAM（随机存取存储器）和ROM（只读存储器），其中RAM的访问速度比较快，但掉电后数据会丢失，而ROM掉电后数据不会丢失。 1.1 常见存储器&emsp;&emsp;在嵌入式开发过程中，往往会涉及到存储器(掉电存储等功能)；其中的 Flash，EEPROM，SRAM耳熟能详。1. Flash，适用于速度要求高，容量要求大，掉电时要求数据不丢失的场合2. EEPROM，适用于速度不高，容量不大，掉电时要求数据不丢失的场合3. SRAM，一般就相当于计算机的内存，断电不保存，读写速度比flash, eeprom快N倍 &emsp;&emsp;在单片机中，往往 RAM主要是做运行时数据存储器,FLASH主要是程序存储器,EEPROM主要是用以在程序运行保存一些需要掉电不丢失的数据.FLASH:单片机运行的程序存储的地方SRAM：存储单片机运行过程中产生的了临时数据EEPROM：视用户的需要而定，一般用来存储系统的一些参数，这些参数可能需要修改，也可能不会修改。 1.2 EEPPROM 和 Flash 混淆来由&emsp;&emsp;EEPROM的全称是“电可擦除可编程只读存储器”，即Electrically Erasable Programmable Read-Only Memory。是相对于紫外擦除的rom来讲的。但是今天已经存在多种EEPROM的变种，变成了一类存储器的统称。狭义的EEPROM：这种rom的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。这是最传统的一种EEPROM，掉电后数据不丢失，可以保存100年，可以擦写100w次。具有较高的可靠性，但是电路复杂/成本也高。因此目前的EEPROM都是几十千字节到几百千字节的，绝少有超过512K的。 Flash:Flash属于广义的EEPROM，因为它也是电擦除的ROM。但是为了区别于一般的按字节为单位的擦写的EEPROM，我们都叫它Flash。 &emsp;&emsp;FLASH按扇区操作，EEPROM则按字节操作；二者寻址方法不同，存储单元的结构也不同，FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因而适合用作程序存储器，EEPROM则更多的用作非易失的数据存储器。当然用FLASH做数据存储器也行，但操作比EEPROM麻烦的多；所以更“人性化”(成本)的MCU设计会集成FLASH和EEPROM两种非易失性存储器，而廉价型设计往往只有 FLASH，早期可电擦写型MCU则都是EEPRoM结构，现在已基本上停产了。 &emsp;&emsp;EEPROM：电可擦除可编程只读存储器，Flash的操作特性完全符合EEPROM的定义，属EEPROM无疑，首款Flash推出时其数据手册上也清楚的标明是EEPROM，现在的多数Flash手册上也是这么标明的，二者的关系是“白马”和“马”。至于为什么业界要区分二者，主要的原因是 Flash EEPROM的操作方法和传统EEPROM截然不同，次要的原因是为了语言的简练，非正式文件和口语中Flash EEPROM就简称为Flash，这里要强调的是白马的“白”属性而非其“马”属性以区别Flash和传统EEPROM。&emsp;&emsp;Flash的特点是结构简单，同样工艺和同样晶元面积下可以得到更高容量且大数据量下的操作速度更快，但Flash缺点是操作过程麻烦，特别是在小数据量反复重写时，所以在MCU中Flash结构适于不需频繁改写的程序存储器。很多应用中，需要频繁的改写某些小量数据且需掉电非易失，传统结构的EEPROM在此非常适合，所以很多MCU内部设计了两种EEPROM结构，FLASH的和传统的以期获得成本和功能的均衡，这极大的方便了使用者。随着ISP、IAP的流行，特别是在程序存储地址空间和数据存储地址空间重叠的MCU系中，现在越来越多的MCU生产商用支持IAP的程序存储器来模拟EEPROM对应的数据存储器，这是低成本下实现非易失数据存储器的一种变通方法。为在商业宣传上取得和双EEPROM工艺的“等效”性，不少采用Flash程序存储器“模拟”（注意，技术概念上并非真正的模拟）EEPROM数据存储器的厂家纷纷宣称其产品是带EEPROM的，严格说，这是非常不严谨的，但商人有商人的目的和方法，用Flash“模拟”EEPROM可以获取更大商业利益，所以在事实上，技术概念混淆的始作俑者正是他们。 1.3 Flash的细分&emsp;&emsp;目前Flash主要有两种，NOR Flash和NADN Flash。NOR Flash：NOR Flash的读取和我们常见的SDRAM的读取是一样，用户可以直接运行装载在NOR FLASH里面的代码，这样可以减少SRAM的容量从而节约了成本。NAND Flash：NAND Flash没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价。 Ps ：用户不能直接运行NAND Flash上的代码，因此很多使用NAND Flash的开发板除了使用NAND Flash以外，还作上了一块小的NOR Flash来运行启动代码 &emsp;&emsp;一般小容量的用NOR Flash，因为其读取速度快，多用来存储操作系统等重要信息，而大容量的用NAND FLASH，最常见的NAND FLASH应用是嵌入式系统采用的DOC（Disk On Chip）和我们通常用的“闪盘”，可以在线擦除。目前市面上的FLASH 主要来自Intel，AMD，Fujitsu和Toshiba，而生产NAND Flash的主要厂家有Samsung和Toshib 二、存储器底层驱动&emsp;&emsp;这里讲一下 IIC和SPI通讯； &emsp;&emsp;硬件IIC有主从之分；当然，软件I2C也是标准的I2C协议，当然有分主从，但一般是模拟主机(为什么要写从呢？mcu 对 mcu ？)。由于每种MCU的硬件IIC和硬件SPI配置各不相同，故这里只讲 软件IIC 和 软件SPI。 2.1 软件IIC主机2.1.1 基本知识 &emsp;&emsp;I2C总线通过上拉电阻接正电源。即当总线空闲时，两根线均为高电平。如此，连在总线上的任一器件输出的低电平，都可以使得总线的信号变低，也就是说各器件的SDA和SCL都是线”与”关系。 数据位(1\0)有效性规定：I2C总线进行数据传送时，时钟信号为高电平期间，SDA线上的数据必须保持稳定；只有在SCL线的信号为低电平器件，SDA线的才可进行高低电平状态变化。 起始信号、终止信号、应答信号 起始信号：SCL线为高电平期间，SDA线由高电平向低电平跳变(下降沿)—-是一种电平跳变时序信号终止信号：SCL线为高电平期间，SDA线由低电平向高电平跳变(上升沿)—-是一种电平跳变的时序信号 应答信号：在接收数据的IC(接收器)在接收到8bit数据后，向发送数据的IC(发送器)发出特定的低电平脉冲，表示已收到数据。即发送器在时钟脉冲9期间释放数据线，这样接收器就可以反馈一个应答信号。ACK(低电平)—-规定为有效应答位，NACK(高电平)，规定为非应答位，表示接收器接收该字节咩有成功。 2.1.2 软件模拟IIC驱动程序函数编写&emsp;&emsp;在IIC程序设计中，都是以8bit为基础进行数据的传输 IO管教初始化 发出起始信号 发出终止信号 发出应答ACK功能要求：由于IIC为双向数据通信，当从机发送完数据，主机也需要发送应答信号来说我接收到你的信息了，此时从机才可变为接收状态，接收来自主机的数据。 发出应答NACK功能要求：当IIC程序运行到主机读取从机数据完成，需要停止此次数据传输时，主机发送一个发出主无应答信号，从机接收到后就停止发送数据，并释放SDA线；之后主机才可发送终止信号，停止此次数据的传输。 发送一个字节数据基本思路：SCL在为0时，可以进行SDA数据的配置，当SCL为1时，SDA数据一定要锁定。其次为数据的移位，将待发送数据与0x80进行与运算，获得最高位的数据，通过8次循环完成1byte的数据发送。 读取一个字节，并发送ACK或NACK(发送NACK基通知从机发送器结束数据发送，释放SDA线(SDA接口置1))功能要求：发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号(故读取完需要发送 ACK 或 NACK ) 等待ACK应答功能要求：当IIC主机进行获取数值时，主机需要等待从机的应答信号，以此来判断从机是否完成了数据的接收。从主机方看，为IIC等待ASK函数。基本思路：通过 延时等待从机的ACK是否发送出来，如果发送出来，则函数返回0，主机可继续发送数据，如果返回1，则从机没有应答，此时需要停止IIC数据传输。防止出现错误数据。 2.1.3 从具体I2C器件中读写数据 主机写(发送)从机数据 主机读(接收)从机数据 Ps：IIC器件往往是 器件地址+0 为写数据 ，器件地址+1 为读数据主机读从机的情况分为两种：1)读操作之前，都是需要进行一次写操作(写入读地址)，表明你要读的是哪个地址的数据，然后在进行一次读操作(故有两个器件地址)；(这是一般情况)2)直接进行读操作，截取所需数据段&emsp;&emsp;因为有些IIC器件(从机)，例如24C02，当你需要读取它的数据，你要跟它说读取哪个地址数据，故先进行写操作；有些IIC器件，例如SD2403，它的时间日期地址是固定的（寄存器地址：00H-06H），因此读取该器件数据时，直接进行读操作，然后读出来7个数据，截取00H-06H的数据后，停止读取(这是特殊情况) DEVICEADDRESS(器件地址)&emsp;&emsp;器件地址的8位地址信息因器件而异； 2.1.3.1 EEPROM_24C02为例&emsp;&emsp;24C02是一个可储存 256(8bit)字节数据的EEPROM，因此他的Word Address为8bit(单字节)；而他的器件地址如下： 据2.3.1图所示，主机对从机写操作如下： 12345678910111213141516void AT24CXX_WriteOneByte(u16 WriteAddr, u8 DataToWrite)&#123; IIC_Starts(); //发出起始信号 IIC_Send_Byte(0xA0); //写器件地址+写操作 IIC_Wait_Ack(); //IIC_Send_Byte(WriteAddr&gt;&gt;8); //发送高地址，适用于更高容量的EEPROM //IIC_Wait_Ack(); IIC_Send_Byte(WriteAddr%256); //发送低地址 IIC_Wait_Ack(); IIC_Send_Byte(DataToWrite)； IIC_Wait_Ack(); IIC_Stop(); delay_ms(10); //等AT24C02写数据&#125; 据2.3.1图所示，主机对从机读操作如下： 12345678910111213141516171819u8 AT24CXX_ReadOneByte(u16 ReadAddr)&#123; u8 temp=0; IIC_Start(); IIC_Send_Byte(0XA0); //发送器件地址0XA0,写操作 IIC_Wait_Ack(); //IIC_Send_Byte(ReadAddr/256); //发送高地址，适用于更高容量的EEPROM //IIC_Wait_Ack(); IIC_Send_Byte(ReadAddr%256); //发送低地址 IIC_Wait_Ack(); IIC_Start(); IIC_Send_Byte(0XA1); //进入接收模式 IIC_Wait_Ack(); temp=IIC_Read_Byte(0); //读一个字节数据完成，并发出No_Ack(输入参数：0) IIC_Stop(); return temp;&#125; 24C02程序拓展 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//在AT24CXX里面的指定地址开始写入长度为Len的数据//该函数用于写入16bit或者32bit的数据.//WriteAddr :开始写入的地址 //DataToWrite:数据数组首地址//Len :要写入数据的长度2,4void AT24CXX_WriteLenByte(u16 WriteAddr,u32 DataToWrite,u8 Len)&#123; u8 t; for(t=0;t&lt;Len;t++) &#123; AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite&gt;&gt;(8*t))&amp;0xff); &#125; &#125;//在AT24CXX里面的指定地址开始读出长度为Len的数据//该函数用于读出16bit或者32bit的数据.//ReadAddr :开始读出的地址 //返回值 :数据//Len :要读出数据的长度2,4u32 AT24CXX_ReadLenByte(u16 ReadAddr,u8 Len)&#123; u8 t; u32 temp=0; for(t=0;t&lt;Len;t++) &#123; temp&lt;&lt;=8; temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t-1); &#125; return temp; &#125;//检查AT24CXX是否正常//这里用了24XX的最后一个地址(255)来存储标志字.//如果用其他24C系列,这个地址要修改//返回1:检测失败//返回0:检测成功u8 AT24CXX_Check(void)&#123; u8 temp; temp=AT24CXX_ReadOneByte(255);//避免每次开机都写AT24CXX if(temp==0X55)return 0; else//排除第一次初始化的情况 &#123; AT24CXX_WriteOneByte(255,0X55); temp=AT24CXX_ReadOneByte(255); if(temp==0X55)return 0; &#125; return 1; &#125;//在AT24CXX里面的指定地址开始读出指定个数的数据//ReadAddr :开始读出的地址 对24c02为0~255//pBuffer :数据数组首地址//NumToRead:要读出数据的个数void AT24CXX_Read(u16 ReadAddr,u8 *pBuffer,u16 NumToRead)&#123; while(NumToRead) &#123; *pBuffer++=AT24CXX_ReadOneByte(ReadAddr++); NumToRead--; &#125;&#125; //在AT24CXX里面的指定地址开始写入指定个数的数据//WriteAddr :开始写入的地址 对24c02为0~255//pBuffer :数据数组首地址//NumToWrite:要写入数据的个数void AT24CXX_Write(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)&#123; while(NumToWrite--) &#123; AT24CXX_WriteOneByte(WriteAddr,*pBuffer); WriteAddr++; pBuffer++; &#125;&#125; 2.1.3.2 实时时钟_SD2403为例&emsp;&emsp;SD2403是一个实时时钟，他的Word Address为8bit(单字节)；而他的器件地址如下： 据2.3.1图所示，主机对从机写操作如下： 123456789101112static uint8_t SD2403_WriteOneByte(uint8_t addr,uint8_t data)&#123; if(!SD2403_start())return(false); SD2403_SendByte(0x64); SD2403_WaitAck(); SD2403_SendByte(addr); SD2403_WaitAck(); SD2403_SendByte(data); SD2403_WaitAck(); SD2403_stop(); return(true);&#125; 据2.3.1图所示，主机对从机读操作如下： 12345678910111213141516171819202122uint8_t SD2403_ReakOneByte(uint8_t addr)&#123; uint8_t res=0; //先写入要读取的寄存器 if(!SD2403_start()) return false; SD2403_SendByte(0x64); if(!SD2403_WaitAck()) &#123; SD2403_stop(); return false; &#125; SD2403_SendByte(addr); SD2403_WaitAck(); //再读取的寄存器数据 SD2403_start(); SD2403_SendByte(0x65); SD2403_WaitAck(); res=SD2403_ReceiveByte(0); SD2403_stop(); return res;&#125; SD2403程序拓展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869uint8_t SD2403_ReadTimeDate(_strTimeDate *pstrTimeDate)&#123; uint8_t i,dat[7]; if(!SD2403_start()) return false; SD2403_SendByte(0x65); if(!SD2403_WaitAck()) &#123; SD2403_stop(); return(false); &#125; for(i=0; i&lt;7; i++) &#123; dat[i]=SD2403_ReceiveByte(); if(i==2) dat[2]=BCDTODEC(dat[2]&amp;0x7F);//24小时舍弃最高位(区分12/24小时制) else dat[i]=BCDTODEC(dat[i]); *(&amp;pstrTimeDate-&gt;ucSec +i)=dat[i]; if (i!=6) //最后一个数据不应答 &#123; SD2403_ACK();////ACK 低 &#125; &#125; SD2403_No_ACK();//ACK 高结束 SD2403_stop(); return(true);&#125;uint8_t SD2403_WriteTimeDate(uint8_t *pstrTimeDate)&#123; uint8_t *set_time,i; set_time=pstrTimeDate; SD2403_WriteTimeOn(); if(!SD2403_start())return(false); SD2403_SendByte(0x64); if(!SD2403_WaitAck()) &#123; SD2403_stop(); return(false); &#125; SD2403_SendByte(0x00);//设置写起始地址 SD2403_WaitAck(); for(i=0; i&lt;7; i++) &#123; if(i==2) SD2403_SendByte(0x80|DECTOBCD(*set_time));//最高位区分12/24小时制(1为24小时制) else SD2403_SendByte(DECTOBCD(*set_time)); SD2403_WaitAck(); set_time++; &#125; SD2403_stop(); SD2403_WriteTimeOff(); return(true);&#125;/******写SD2403允许程序******/static uint8_t SD2403_WriteTimeOn(void)&#123; if(!SD2403_WriteOneByte(0x10,0x80))return(false); SD2403_WriteOneByte(0x0f,0x84); return(true);&#125;/******写SD2403禁止程序******/static uint8_t SD2403_WriteTimeOff(void)&#123; if(!SD2403_WriteOneByte(0x0f,0))return(false); SD2403_WriteOneByte(0x10,0); return(true);&#125; 2.2 软件IIC从机&emsp;&emsp;要实现IIC从机功能，最核心的部分就是如何精确的抓住IIC_SCL，也就是IIC主机发出来的时钟信号。只有抓住精确的时钟SCL，才能正确的读取到SDA的数据，才能真正模拟出IIC时序。 &emsp;&emsp;但是要抓住SCL信号可不容易，IIC最高速度有400K，最小有效脉宽达到1.4us(数字0/1)，最小脉冲是0.8us(应答和STOP信号产生的尖刺)，采用中断来识别SCL是不可能的做到的，因为即使在最高主频72MHZ情况下，STM32最小指令周期是1/72(us)，从SCL中断发生到STM32进入中断响应，至少要要40个指令周期，也就是40/72(us)，加上堆栈操作及变量，很可能已经错过了SCL信号。 因此根据IIC主机的速度，从机实现方法分为两种： 采用中断方式识别SCL(适用于总线速度较慢) 采用查询方式识别SCL(适用于总线速度较快) 2.3 软件SPI(主机)&emsp;&emsp;硬件上为4根线：1)MISO ：主设备数据输入，从设备数据输出。2)MOSI ：主设备数据输出，从设备数据输入。3)SCLK ：时钟信号，由主设备产生。4)CS ：从设备片选信号，由主设备控制。Ps：外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。 由上图的(硬件)SPI通信协议可知，时钟信号的相位和极性，决定了获取数据的方式；2*2=4，于是有四种模式； CPOL决定时钟空闲状态(1为空闲高电平，0为空闲低电平) CPHA决定获取数据的时钟相位(1为延迟一个相位，第二次SCLK突变为空闲状态获取数据；0为直接相位，SCLK空闲状态突变时，直接获取数据) &emsp;&emsp;以上就是软件SPI的要点；实现具体的软件SPI，需要对器件的datasheet进行查阅，看是哪种模式 模式 CPOL CPHA MODE0 0 0 MODE1 0 1 MODE2 1 0 MODE3 1 1 下面简单列一个 CPOL=1，CPHA=1的SPI写操作 1234567891011121314151617181920212223/************************************************** 函数：SOFT_SPI_RW() 描述: 根据SPI协议，写一字节数据到从机，同时从从机 读出一字节**************************************************/ u8 SOFT_SPI_RW(u8 byte) &#123; u8 i,Temp=0; for(i=0;i&lt;8;i++) // 循环8次 &#123; SPI1_SCK = 0 //拉低时钟 if(byte&amp;0x80) SPI1_MOSI = 1;//若最到位为高，则输出高 else SPI1_MOSI = 0;//若最到位为低，则输出低 byte &lt;&lt;= 1; //低一位移位到最高位 SPI1_SCK = 1; //拉高时钟 Temp &lt;&lt;= 1; //数据左移 if(SPI1_MISO) Temp++; //若从从机接收到高电平，数据自加一 SPI1_SCK = 0; //拉低时钟 &#125; return (Temp); //返回数据 &#125; 2.3.1 FRAM_FM25L256为例&emsp;&emsp;FM25L256支持SPI模式的0和3，下面为CPOL=1，CPHA=1 基本的字节读写操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************** * 函数名 : FRAM_Write8bits* 功 能 : 向存储器中写入一个字节**************************************************/ static void FRAM_Write8bits(uint8_t u8Data)&#123; uint8_t i; for(i = 0; i &lt; 8; i++) &#123; FRAM_SCLK_L; if(u8Data &amp; 0x80) FRAM_SDI_H; else FRAM_SDI_L; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; u8Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L;&#125;/************************************************** * 函数名 : FRAM_Read8bits* 功 能 : 从存储器中读出一个字节的数据**************************************************/ static uint8_t FRAM_Read8bits(void)&#123; uint8_t i; uint8_t u8Data=0; for(i = 0; i &lt; 8; i++) &#123; FRAM_SCLK_L; u8Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; if(FRAM_SDO_READ) u8Data |= 0x01; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L; return u8Data;&#125; 程序扩展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/************************************************** * 函数名 : FRAM_Write16bits* 功 能 : 发送16位数据**************************************************/ static void FRAM_Write16bits(uint16_t u16Data)&#123; uint32_t i; for(i = 0; i &lt; 16; i++) &#123; FRAM_SCLK_L; if(u16Data &amp; 0x8000) FRAM_SDI_H; else FRAM_SDI_L; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; u16Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L;&#125;/************************************************** * 函数名 : FRAM_Write32bits* 返 回 : 写入的32位数据**************************************************/ static void FRAM_Write32bits(uint32_t u32Data)&#123; uint32_t i; for(i = 0; i &lt; 32; i++) &#123; FRAM_SCLK_L; if(u32Data &amp; 0x80000000) FRAM_SDI_H; else FRAM_SDI_L; DelayTime(SPI_DELAY_TIME); FRAM_SCLK_H; u32Data &lt;&lt;= 1; DelayTime(SPI_DELAY_TIME); &#125; FRAM_SCLK_L;&#125;/************************************************** * 函数名 : FRAM_Read4Bytes* 功 能 : 读取指定地址的4字节数据* 入 参 : address : 读取数据的首地址* 返 回 : uint32_t : 读出的32位数据**************************************************/ uint32_t FRAM_Read4Bytes(uint32_t address)&#123; uint32_t i = 0; uint32_t temp = 0; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_READ); FRAM_Write16bits((uint16_t)(address)); for(i = 0; i &lt; 4; i++) &#123; temp = temp &lt;&lt; 8; temp |= FRAM_Read8bits(); &#125; FRAM_SCLK_L; FRAM_CS_H; return temp;&#125;/************************************************** * 函数名 : FRAM_Write4Bytes* 功 能 : 写入指定地址的4字节数据* 入 参 : address : 写入数据的首地址* FramData : 写入的32位数据**************************************************/ void FRAM_Write4Bytes(uint32_t address, uint32_t FramData)&#123; uint8_t u8Temp = 0; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_WREN); FRAM_SCLK_L; FRAM_CS_H; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_WRITE); FRAM_Write16bits((uint16_t)(address)); FRAM_Write32bits(FramData); FRAM_SCLK_L; FRAM_CS_H; while(1) &#123; FRAM_SCLK_L; FRAM_CS_L; FRAM_Write8bits(FRAM_CMD_RDSR); //读取状态寄存器 u8Temp = FRAM_Read8bits(); FRAM_SCLK_L; FRAM_CS_H; //该位表示写入启用状态(为0时，WPEN和 /WP 寄存器标志位不起作用) //防止软件误改动铁电芯片寄存器配置 if(!(u8Temp &amp; 0x02)) &#123; break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>Flash</tag>
        <tag>ROM</tag>
        <tag>SRAM</tag>
        <tag>IIC通信</tag>
        <tag>SPI通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCD驱动]]></title>
    <url>%2F2019%2F12%2F14%2FLCD%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这里以 （分辨率为:192*64)的 数据8线并口液晶屏 举例 一、基础知识1.1 分辨率&emsp;&emsp;分辨率指的是屏幕点阵可显示 行和列 点阵的数量；例如我这款192*64分辨率屏幕，它的行显示点数是 192 、列显示点数是 64;分辨率的大小 跟 屏幕的大小 是没有任何关系的；有些屏幕很大但是它显示(点阵)的最小像素是真的大(像我手头这个)，因此分辨率并不大，显示的东西也不多。ASCII码的最小字体是0508(点阵)，汉字的最小字体则是1616(点阵)举例：分辨率192*64&emsp;&emsp;单行可显示最多汉字为：192/16 = 12 个&emsp;&emsp;汉字最多显示行数: 64/16 = 4 行因此，该屏最多只能显示 4行(每行)12个的汉字 1.2 驱动代码思路&emsp;&emsp;以该屏为例；一个好的（不带EWWIN）嵌入式LCD驱动应该分为三大块：1）底层，LCD硬件驱动（一般由该屏的原本数据手册和源码例程提供）2）中间层，提供字库和字体写入驱动、框体、阴影、图片等3）应用层，提供封装界面轮询方式等，用于主程序调用 举例： Lcd_drv.c Lcd_dev.c lcd_user.c font.h (该字库文件只会被Lcd_dev.c所调用) 二、高级应用&emsp;&emsp;在显示的过程中，无非就是 1)残影 2)显示方式 残影是在Lcd显示中经常出现的问题；例如之前显示 “28”，后面再显示 “6”，但是实际效果会显示“26”，这个“2”就是残影 当你要显示一串数字，带有小数点、单位，甚至(正)负号；而实际上，在Lcd显示的均为字符串，它并不是一组数字，你无法让一个float类型变量(数值)直接显示在Lcd上；如果数字和符号分开显示，又容易形成头疼的残影 2.1 消影&emsp;&emsp;消影的要点，无非就是要根据屏的分辨率，以及规划好 数据显示区，并且把数据显示区分成每一个最小显示具体字符单位；对要显示的数据位数进行判断，然后从右到左，逐渐挪最高位显示位置；然后将剩下的空白单位格子，用空白显示填充 2.2 数字和字符串转换&emsp;&emsp;这个最重要的就是sprintf函数了；sprintf函数主要功能是把格式化的数据写入某个字符串中，但需要为正整数(不然符号位会被当成数值)。 数值转换字符串主要为两种：1)单个数字转换成字符串，用于界面需要具体调整单个数字(不常用到)2)一个带正负号、小数点、单位等的数值，转换成字符串 以下代码实现 数值进行转换成字符串：(不带符号和单位，可根据下面思路添加) 123456789101112131415161718192021222324252627282930static const char *cSprintf[]=&#123; "%d", "%d.%01d", "%d.%02d", "%d.%03d", "%d.%04d", "%d.%05d",&#125;;static uint32_t uiPowVal[] = &#123;1,10,100,1000,10000,100000&#125;;uint32_t _valSprintf(uint32_t uiVal,uint8_t ucShift,char *pucFrame)&#123; uint32_t uiLen = 0; switch(ucShift) &#123; case 1: case 2: case 3: case 4: case 5: uiLen = sprintf(pucFrame,cSprintf[ucShift],(uiVal/uiPowVal[ucShift]),(uiVal%uiPowVal[ucShift])); break; default: uiLen = sprintf(pucFrame,cSprintf[0],uiVal); break; &#125; return uiLen;&#125; 2.3 界面显示划分 采用回调函数，将每个界面都分割成两块实现：(界面初始化)InitGUI 和 (界面刷新)UpdateGUI；方便查看各个界面功能代码 采用 switch轮询方式显示页面，页码作为switch参数；再用enum枚举页码，可以使得页面扩展时 增加和删减页面变得更简单，而且可随意更改序号； 构造一个结构体能够用来记录 当前页码 和 缓存页码 ；缓存页码会在进入某个页面就一直保存对应的值，当前页码则是会根据操作可能发生变化；两个页码对比，就可以知道页面是否要重新进入初始化；]]></content>
      <categories>
        <category>驱动编写</category>
      </categories>
      <tags>
        <tag>LCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南瓜]]></title>
    <url>%2F2019%2F11%2F16%2F%E5%8D%97%E7%93%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;纪念一只小小的、瘦瘦的，但并不勇敢反而很胆小并且还很挑食的 南瓜 从一开始的老姐说“它可是折尾招财猫”，到后面实际在火锅店前抱走的流浪猫 从一开始的敢抓人不认人躲在高处吠，到后面温顺认人 吃东西一直很挑，被我们戏称猫精 当阉割手术完，狂吐舌头并撞笼子的时候，曾对它偷偷说：忍住了，以后就能多陪伴我们几年啦，让你再陪陪我们这些人未来的孩子 时不时地发烧无精神，到最后发现是猫传腹 开始疯狂地瘦下来，瘦到皮包骨头，但却肚子越来越来大 到后面连眼睛都睁不开，但还能进食 甚至有带它去安乐的想法 病情却在老姐坚持下慢慢好转，肚子开始慢慢变小 但是也变成了一只瘦骨嶙峋的、嗜睡的猫 每天仍旧痛苦着，我们却不知道怎么做才是对的 最后一天带着去安乐的时候，别人却以为是我们抱着一只很可爱的小猫 殊不知你已经陪伴了将近半年，只不过你真的太瘦了 当去宠物医院的时候，看到别人的猫，头大得跟个大毛球一样 等你走后，去同学家撸猫，3个月大的，个头跟你6个月一样大 才知道你是真的很瘦，开始后悔没让你多吃几口 &emsp;&emsp;希望你在另外一边，不要总是那么挑食，你个流浪猫那么挑，是要干嘛呢？不要那么怕生，长点志气啊。下次要是能够再过来，就不切了，将就点和我们一起活下去把 &emsp;&emsp;当我没事再想起你的时候，我会稍微再加把劲吧]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>南瓜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil版本号]]></title>
    <url>%2F2019%2F10%2F08%2FKeil%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇详细介绍keil版本管理 一、__DATE__和__TIME__简介&emsp;&emsp;经常都需要手动添加版本号或者生成时间会很繁琐。这个时候，C语言中的两个宏__DATE__和__TIME__可以帮到我们。__DATE__用于获取系统日期，而__TIME__用于获取系统时间，我们可以根据该两个宏获取到的信息将其保存于程序变量中，在程序运行过程中直接调用。 __DATE__的格式为 “Aug 27 2013” | “Sep 3 2019”__TIME__的格式为 “14:01:32” 二、版本管理源码&emsp;&emsp;根据上面获取的格式，也可以自己写出Version版本管理；这里的源码（内有注释）如下 2.1 数值输出2.1.1 Version.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include "Version.h"/********************************************************************************块注释 : 获取系统编译日期********************************************************************************/unsigned int GetBuildDate(void)&#123; const unsigned char *StrD=__DATE__; unsigned int u32DateBuf=0; u32DateBuf+=(StrD[10]-'0')*10000; u32DateBuf+=(StrD[9] -'0')*100000; if(StrD[4]!=' ')u32DateBuf+=(StrD[4]-'0')*10; u32DateBuf+=(StrD[5]-'0'); switch(StrD[0]) &#123; case 'J': switch(StrD[1]) &#123; case 'a':u32DateBuf+=100;break; //January case 'u': switch(StrD[2]) &#123; case 'n':u32DateBuf+=600;break; //June case 'l':u32DateBuf+=700;break; //July default:break; &#125; break; default:break; &#125; break; case 'F':u32DateBuf+=200;break; //February case 'M': switch(StrD[2]) &#123; case 'r':u32DateBuf+=300;break; //March case 'y':u32DateBuf+=500;break; //May default:break; &#125; break; case 'A': switch(StrD[1]) &#123; case 'p':u32DateBuf+=400;break; //April case 'u':u32DateBuf+=800;break; //August default:break; &#125; break; case 'S':u32DateBuf+=900;break; //September case 'O':u32DateBuf+=1000;break; //October case 'N':u32DateBuf+=1100;break; //November case 'D':u32DateBuf+=1200;break; //December default:break; &#125; return u32DateBuf;&#125;//这样得出来的数据为：190903/********************************************************************************块注释：获取系统编译时间********************************************************************************/unsigned int GetBuildTime(void)&#123; const unsigned char *StrD=__TIME__; unsigned int u32DateBuf=0; u32DateBuf = 0; u32DateBuf+=(StrD[0] - '0')*100000; u32DateBuf+=(StrD[1] - '0')*10000; u32DateBuf+=(StrD[3] - '0')*1000; u32DateBuf+=(StrD[4] - '0')*100; u32DateBuf+=(StrD[6] - '0')*10; u32DateBuf+=(StrD[7] - '0'); return u32DateBuf;&#125;//这样得出来的数据为：140132/***************************************The End Of This File***************************************/ 2.1.2 Version.h1234567891011121314151617181920#ifndef _VERSION_H#define _VERSION_H#include &lt;stdint.h&gt;#include &lt;string.h&gt;/*******************************************************************************块注释：版本信息*******************************************************************************/#define SFVERSION (10112UL) // 通讯显示版本号：01.01.12/*******************************************************************************块注释：对外接口*******************************************************************************/unsigned int GetBuildDate(void); // 获取系统编译日期unsigned int GetBuildTime(void); // 获取系统编译时间#endif/***************************************The End Of This File***************************************/ 2.2 字符串输出2.2.1 Version.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include "Version.h"/********************************************************************************块注释 : 获取系统编译日期********************************************************************************/void SetBuildDate(char *pBuildDate)&#123; const char *StrD = __DATE__; // if(0 == LanguageMode) &#123; pBuildDate[0] = StrD[7]; pBuildDate[1] = StrD[8]; pBuildDate[2] = StrD[9]; pBuildDate[3] = StrD[10]; pBuildDate[4] = '/'; switch(StrD[0]) &#123; case 'J': &#123; switch(StrD[1]) &#123; case 'a': pBuildDate[5] = '0'; pBuildDate[6] = '1'; break; case 'u': switch(StrD[2]) &#123; case 'n': pBuildDate[5] = '0'; pBuildDate[6] = '6'; break; case 'l': pBuildDate[5] = '0'; pBuildDate[6] = '7'; break; default:break; &#125; break; default:break; &#125; &#125; break; case 'F': pBuildDate[5] = '0'; pBuildDate[6] = '2'; break; case 'M': &#123; switch(StrD[2]) &#123; case 'r': pBuildDate[5] = '0'; pBuildDate[6] = '3'; break; case 'y': pBuildDate[5] = '0'; pBuildDate[6] = '5'; break; default:break; &#125; &#125; break; case 'A': &#123; switch(StrD[1]) &#123; case 'p': pBuildDate[5] = '0'; pBuildDate[6] = '4'; break; case 'u': pBuildDate[5] = '0'; pBuildDate[6] = '8'; break; default:break; &#125; &#125; break; case 'S':pBuildDate[5]='0';pBuildDate[6]='9';break; case 'O':pBuildDate[5]='1';pBuildDate[6]='0';break; case 'N':pBuildDate[5]='1';pBuildDate[6]='1';break; case 'D':pBuildDate[5]='1';pBuildDate[6]='2';break; default:break; &#125; pBuildDate[7] = '/'; if(StrD[4] == ' ')pBuildDate[8] = '0'; else pBuildDate[8] = StrD[4]; pBuildDate[9] = StrD[5]; pBuildDate[10] = '\0'; &#125; /*英文格式显示 else &#123; pBuildDate[6] = StrD[7]; pBuildDate[7] = StrD[8]; pBuildDate[8] = StrD[9]; pBuildDate[9] = StrD[10]; pBuildDate[10] = '\0'; switch(StrD[0]) &#123; case 'J': &#123; switch(StrD[1]) &#123; case 'a': pBuildDate[0] = '0'; pBuildDate[1] = '1'; break; case 'u': &#123; switch(StrD[2]) &#123; case 'n': pBuildDate[0] = '0'; pBuildDate[1] = '6'; break; case 'l': pBuildDate[0] = '0'; pBuildDate[1] = '7'; break; default:break; &#125; &#125; break; default:break; &#125; &#125; break; case 'F': &#123; pBuildDate[0] = '0'; pBuildDate[1] = '2'; &#125; break; case 'M': &#123; switch(StrD[2]) &#123; case 'r': pBuildDate[0] = '0'; pBuildDate[1] = '3'; break; case 'y': pBuildDate[0] = '0'; pBuildDate[1] = '5'; break; default:break; &#125; &#125; break; case 'A': &#123; switch(StrD[1]) &#123; case 'p': pBuildDate[0] = '0'; pBuildDate[1] = '4'; break; case 'u': pBuildDate[0] = '0'; pBuildDate[1] = '8'; break; default:break; &#125; &#125; break; case 'S':pBuildDate[0]='0';pBuildDate[1]='9';break; case 'O':pBuildDate[0]='1';pBuildDate[1]='0';break; case 'N':pBuildDate[0]='1';pBuildDate[1]='1';break; case 'D':pBuildDate[0]='1';pBuildDate[1]='2';break; default:break; &#125; pBuildDate[2] = '/'; if(StrD[4] == ' ')pBuildDate[3] = '0'; else pBuildDate[3] = StrD[4]; pBuildDate[4] = StrD[5]; pBuildDate[5] = '/'; &#125; */&#125;//这样得出来的数据为：2019/09/03 2.2.2 Version.h123456789101112131415161718#ifndef _VERSION_H#define _VERSION_H#include &lt;stdint.h&gt;#include &lt;string.h&gt;/*******************************************************************************块注释：版本信息*******************************************************************************/#define VERSION ("v1.01.02") // 通讯显示版本号：01.00.12/*******************************************************************************块注释：对外接口*******************************************************************************/void SetBuildDate(char *pBuildDate);// 获取系统编译日期 /***************************************The End Of This File***************************************/#endif 三、注意要点&emsp;&emsp;编译方面需要注意有个别差异：局部编译：不会再编译未改动位置；局部编译后，虽然 .bin文件生成的时间是 对应编译时间（准确）的，但因为该工程内获取版本时间代码未改动，因此导致局部编译未更新获取内部版本时间（和 .bin文件更新时间没关系）。该工程内部显示获取的版本时间仍为 你上一次 全局编译的时间。提交版本时候需要全局编译一次]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>keil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红警2标准版+尤里版 （彩蛋）攻略]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%BA%A2%E8%AD%A62%E6%A0%87%E5%87%86%E7%89%88-%E5%B0%A4%E9%87%8C%E7%89%88-%EF%BC%88%E5%BD%A9%E8%9B%8B%EF%BC%89%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这款怀旧游戏并不难打，不管什么难度，上手后都能很轻松就通关，主要还是分享一些剧情、彩蛋和攻略的 一、红色警戒2_标准版&emsp;&emsp;二战后爱因斯坦发明了时间机器，他为了避免（二战）战争惨剧发生，便利用了自己发明的时间机器回到战争爆发前，刺杀了希特勒.这一举动成功防止了德国走上纳粹道路，但却让苏联国力大幅膨胀。战争最终依然没能避免，苏联发动了世界大战，英美等国则组成盟军与之对抗(一款从细节里黑化苏联的游戏)。下面开始介绍作为苏联和盟军两条线的剧情任务攻略。 1.1 苏联 红色黎明：工程师快速修桥，（动员兵）伞兵进攻五角大楼即可（任务空降坦克支援，白给通关）；彩蛋：五角大楼附近有隐藏坦克小队 危机四伏：登陆作战，发展经济，快速憋出坦克中队 直接横扫过去 大苹果：直接憋出坦克中队直接中路碾压过去，记得占领后需要防空；彩蛋：可用尤里控制中立单位（大巴车可载人）看地图；整个地图盟军除主基地外有额外的一个兵营和车工厂；左上角有个防空维修厂 家乡前线：卖掉船厂出经济，少量动员兵守家拖时间，大量动员兵、磁暴、犀牛直接推进破坏盟军登陆作战（地图最右边），清理剩余海上船支部队 灯火之城：占领油厂，动员兵进房攻进去；彩蛋：一路向左直到靠近海岸，可获得三波隐藏小支援单位 划分：小兵进房子苟拖时间，动员兵混合磁暴守家，憋出潜艇（数量）中队直接攻入造船厂 超时空防御战：（苏联中任务难度No.2）部分（好）位置可以先用围墙卡住，然后哨戒炮在外（防狙击手：主要来源于基地正下方），拖出坦克支援时间；间谍放狗，蜘蛛全图，防空炮4门+；至少产出四队（1队：3-4只）天启，其中1队作为游走火力支援部队，光陵坦克主要是右侧进攻；彩蛋：使用恐怖机器人直接过去清理广播车可获得全地图（低难度情况），地图最右侧有油井和大片金矿 首都之辱：前期敌方两波伞兵偷袭；正常部队断桥离开基地，辐射兵开大守家清伞兵；强制推进并建筑占领前面矿厂，稳住后矿区直接建立就地兵工厂，堆出天启中队直切目标 狐狸与猎犬：狙击手清掉部分海豹，3级多功能步兵车（这局核心单位，该图只有两艘坦克，完全不虚）可开围墙，断电清图；彩蛋：难度决定任务提供的尤里人数；地图右下角有修车厂、并有经济箱；地图右上角有狙击手、直升机；该局有个迷之触发条件，当你杀多个海豹部队时，全体部队会开始走动集火处理尤里，容易游戏失败，最好先处理掉外围兵力 残兵败将：防守防空，进攻，核弹打击 红色革命（尤里叛乱）：（苏联中任务难度No.1）该局是苏联最难玩的一局，敌方有大量尤里、天启、V3远程火箭、无敌暗牧，固定双基洛夫推进；而且是三基地兵力合伙进攻，光是发展防守已经是头皮发麻；在两艘敌方基洛夫生成地，两者连线，该位置是一条只有一个入口点的悬崖峭壁，上面固定 2门防空炮1门磁暴线圈 沿着悬崖多组防守；因此，你无法使用（特别是左侧进攻）天启中队进行推进（敌方尤里会进行支援），数量不多的基洛夫推进又会被悬崖防线和流动支援打下；该图对于不清楚全图构造的玩家，难度是颇大的；那么如何通关呢？当然是反过来利用天然的悬崖峭壁防线。前期游戏开局会送两艘基洛夫空艇，前方有个小高地，两艘基洛夫刚刚好能够拿下前方高地（留下发电厂）；然后动员兵占领左上侧房子和基洛夫防守左侧；高地占领后，两边加强防守，+兵营，多哨戒炮磁暴线圈（无人）就地势击杀（大量尤里），少量防空炮防空（V3火箭），坦克部队附近支援（主要击杀天启坦克）；该高地是这场游戏防守的核心，高地和悬崖峭壁之间的羊肠小道，是进攻我们左侧的必经之路，高地右侧也是右侧进攻我方的基本路径，采用主无人化防守+坦克对射，就可以稳定下来；基本稳定后建立核弹，成立两小队防空履带车，每队各8只，防守左右各3只基洛夫，2-3发核弹或者从右侧逐步推进就能结束游戏了 北极风暴：（苏联中任务如果是常规推进，难度No.3）防守，占领海面（敌方海豹部队），准备防空（敌方火箭飞行兵和战机）；发展完成后，渡河进攻占领车厂，建立苏联兵营购买大量工程师，进行常规堵口防守；占领盟军基地车（期间会被一直被高地光陵塔攻击，工程师抢修），生成闪电风暴，打防守；过段时间核弹+闪电风暴直接摧毁超时空核心；彩蛋：登撸盟军主基地旁边的金矿，定时有超时空传送9单位多功能步兵车（用尤里控制后占住传送地形就不再生成）；推进路途有1个伞兵指挥部、3艘基洛夫空艇（开局残血，等你推进过去已经是满血了）；基洛夫空艇正下方有个金矿，定时超时空传送9单位光陵坦克； 结局：罗曼诺夫表面上与盟国交好，但是暗地里却重建了军队，并任用尤里为科学部长，为苏联研发心灵控制相关的黑科技。由于盟国采取了绥靖政策，苏联的军备越来越强，最后终于抓住机会向盟国发动全面袭击。盟国试图组织反抗，但是这些行动都被玩家扮演的苏联指挥官逐一挫败；尤里在战争中尝试造反并杀害了罗曼诺夫（黑苏联），可最终还是在玩家的运筹帷幄中败下阵来。在消灭了最后一批敢于反抗苏联的残余势力后，苏联统一了地球，玩家成为苏联最高领导人 1.2 盟军 孤独守卫：谭雅救人留在敌方伞兵处支援，大兵进攻苏联基地，LV3远距离除掉哨戒炮 危机黎明：多线推进；火箭飞行兵处理盟军基地的路障哨戒炮后，清理右侧苏联基地绕后（弱点位置）；同时谭雅占领盟军基地，产出大量坦克，围墙保住谭雅 为长官欢呼：守住敌方进攻双桥，有空拿（建筑物）钱，大量空军目标轰炸；彩蛋：基本每一个名建筑物，都有小部队提供支援 最后机会：清理巨炮，巡洋舰清理岸边，援军记得叫过来（小心被击沉），空军（数量）中队轰炸目标 or 坦克推进 暗夜：地图左侧间谍，右侧深处有小队士兵；左侧往上走可救奶牛；第一个苏联基地入侵，墙体右侧有油桶，进去后有工程师单位，占领第一个核弹后进行轰炸第二个（游戏结束）；第二个核弹位置有小队精英部队 自由：防守，定时清空左上侧方敌人骚扰采矿，建立空军（数量）中队，定点基地、兵营、车厂 轰炸两个，敌人会直接卖掉所有建筑单位，快速通关 深海：主火箭飞行兵防守，本岛上侧定时伞兵，岛右侧部分定时伞兵，家里定时伞兵工程师，左上随机水路艇援兵（V3，防空兵）；敌方核弹随机摧毁海军或车厂；最好围墙防住（敌方步兵、工程师单位），占领房子；地图中最上方占领163，建立空军中队，定点轰炸基地、兵营、车厂、核弹，快速通关 自由门户：直接摧毁心灵信标，谭雅坐船跑海岸（不要再出来）；守家，三级大兵建筑+光陵+防空守住，空军中队定点轰炸，清理残余；彩蛋：左下角有废弃的矿厂、车厂 太阳神殿：海豹分两批：图左上角163，坦克+海豹守住；大兵进房子阻止巡线，海边绕后苏联采矿位置，海豹队员完成任务 海市蜃楼：基地车回后方实验室建成，多产出幻影埋伏守三路，守住实验室；空军编队定点轰炸三基地，快速结束；彩蛋：右下角废弃矿厂；地图左侧中间处，有修理建筑和一片矿区；左上角有个工具箱，只能海豹部队去收集 核尘爆辐射：开局，卖掉小孤岛采矿基地；优先出海豹（巡洋舰）断掉所有桥，定时断掉上侧桥梁（固定上侧岛屿伞兵坦克，上侧右海岸定时工程师伞兵）；发展起来后去清理再开路；敌方核弹会针对船厂 or 车厂，可以考虑两发电厂卖掉，空军编队定期轰炸3核弹，目标达成 超时空风暴：（盟军中任务难度No.1）敌方核弹会针对我方车工厂（建筑远离点），坚守住前两波基洛夫空艇，大兵占领建筑，用于拖住铁幕单位；攒出两空指部空军走位躲防空，轰炸左右侧车厂兵营（不再生成），产出超时空军团断四核电站（具体位置在精英部队附近）和偷掉附近车厂兵营，再处理掉精英（包括建筑）部队，目标达成 结局：战争爆发后，盟军并没有迅速溃退，而是在玩家扮演的指挥官领导下逐步稳住阵脚，最终还发起了反击。在战争后期，盟军利用超时空传送技术运输军队突袭莫斯科，攻进克林姆林宫活捉了罗曼诺夫。然而尤里却逃脱了抓捕，并在暗地里酝酿着一个更大的阴谋 二、红色警戒2_尤里版&emsp;&emsp;延续红警2的盟军胜利路线剧情；尤里在逃脱盟国抓捕后，启动了大战期间悄悄搭建在全球各地的心灵控制器，企图控制全人类的心灵。不论是盟军还是苏联，此时反抗已经为时已晚，唯一的办法就是利用时间机器回到大战初期改写历史 2.1 苏联 时空转移：英雄任务，无畏战舰打巨炮；英雄超时空返回 似曾相识：（原版盟军的海市蜃楼任务，换为苏联进攻方）右下第三波攻击要优先（可获得盟军兵营），均匀分布战斗碉堡防止敌方超时空部队偷袭；火箭飞行兵+基洛夫去左上绕后攻击，火箭飞行兵吸收伤害，基洛夫攻击 洗脑行动：英雄任务，吸引左下角爆桥，恐怖机器人+履带车（装英雄）+坦克去左上角桥边登陆，快速击毁控制器，动员兵占领前面豪华建筑，坦克和英雄+步兵车完成任务 北非谍影：总统在右侧不可进人的建筑，左上角有敌方兵营车厂，会固定出现一个尤里只为控制总统，自爆卡车攻击各类地图建筑炸毁地图中间，最好占领该兵营，自爆卡车+铁幕进场，收割清场 脱离地心引力：该图地势相当不好，大量采矿车前来抢矿，守住后，使用建筑卡上（附近）高地，多使用磁爆项圈，卡上第二层高地时可获得尤里基地，运用（尤里科技）狙击手+磁能坦克+天启坦克通关 飞向月球：建立防空炮减少损失（生命防空单位被击杀、控制）(可在间隙中穿插辐射工兵进行辐射地板击杀磁能坦克)，地图中间：左侧基地为盖特炮外围控制塔中间一个，右侧为心灵塔外围盖特炮中间一个，主攻：（特种）激光飞行兵+天启坦克 首脑游戏：使用战斗堡垒保住基地后，增加防空履带车对抗飞行兵+（盟军）飞机+基洛夫；快速建立核弹，用核弹击打控制器即可，先攻击（占领）盟军，再攻击苏联，中间最后随意打 结局：苏军将抢夺时间机器回到过去，挫败尤里的阴谋，逆转了苏联战败的命运（又黑苏联），最终征服地球，开始向外太空发展 2.2 盟军 光阴似箭：时空穿梭，英雄任务 好莱坞梦一场：巨炮防守，堆光陵坦克，几只要塞（狙击）辅助；彩蛋：地图左上角有敌方科技的兵营、车厂 集中攻击：获取电源，敌方无主基地，风暴摧毁车厂兵营；右偏下有个无人车厂，狙击手进步兵车防止对狙和加机动性，开场核弹会攻击车厂（瞬间卖了回点血），准备买步兵车，买点狙击手，最上面开始提供的小波部队往下拉和下方部队汇合吃掉中间敌方单位，占领电厂后，敌方不定期会空投工程师返回去占领，留部分狙击手单位狙击工程师，狙击完离电厂远一点，核弹会攻击发电厂 古墓奇袭：英雄角色无法被控制，主力核心；海岸边左上角，金字塔位置固定有人运输偷袭，谭雅先行去右边断两桥占领油井，右上海岸光陵塔断水上运输兵（尤里基本没有空中单位）；发展经济，谭雅直接过去对面金字塔解救爱因斯坦，占领发电厂，买车厂，堆光陵坦克编队推进 or 飞机中队推进 纽澳复制战：小兵占领各建筑，尤其上边角落（第一波运输兵），潜水艇火箭飞行兵防住；彩蛋资源：地图左下角有一个医院+矿守住；地图右中有修车厂；一批火箭兵可保护右上角矿区 万圣节：（盟军中任务难度No.2，前期坚守）小兵占领附近建筑，占领左上角桥对面一栋建筑拖住作战时间，中间碉堡围墙（可重装大兵对抗飞碟，后期敌方精神车吃亏）加光陵塔，火箭飞行兵机动守护，右侧为关键，使用围墙围住，并用光陵塔和碉堡守护，桥对面不可太多占领建筑，盖特坦克可在建筑攻击范围外射击建筑。多功能步兵车或者爱国者守住飞碟；彩蛋：成功守护住后，地图左上角一片矿区+1油井；地图右侧中间有3油井；地图中间中间有一家医院和修车厂，可占领并堆光陵坦克编队 or 飞机编队攻击 脑死：（盟军中任务难度No.1，盟军战场太狠了）开场双基地，分为主战场岛（盟军）和孤岛守卫岛（苏联），两者无法相通；两岛使用少量苏联碉堡守住前期（防止心灵控制+基因突变的连招）；大部分生产建筑应放在苏联战场，盟军作为主战场只需要兵工厂；尤里飞碟只会定期进攻苏联左边，苏联至少5门防空炮放置在 基地正下方（只是一块高地），苏联基地开场左右各一个苏联堡垒（外加两门巨炮）；苏联战场局势稳定后，清理岛上残留部队，守住海岸线，苏联右侧海岸定时来兵，然后放心生产；其余（尤其盟军战场）均需要大量（无人单位）巨炮防守。苏联战场，孤岛地图左上角有修车厂，右上角有矿+建筑；可采用超时空敌人后方建立基地，巨炮和光陵坦克编队从后方开始推进 结局：最终能在南极活捉尤里，并将他终身囚禁在心灵隔离室 三、红色警戒3&emsp;&emsp;游戏故事还是紧接《红色警戒2：尤里的复仇》盟军线结局；在苏联战败前夕，苏联的 阿纳托利·查丹科上校和库可夫将军 利用时间机器回到过去1927年，刺杀爱因斯坦（这个剧情笑死我了），使爱因斯坦消失于时间长河中，历史又一次被大幅改写（平行宇宙原理）。失去爱因斯坦后，盟军相对于苏联的科技优势不复存在，因此在和苏联的正面对抗中节节败退；该行动还造成了一个新的国家崛起：旭日帝国（日本）。在新时间线中，旭日帝国崛起为一个超级大国并同时向盟军和苏联发起挑战 3.1 苏联&emsp;&emsp;苏联任务从抵御帝国入侵，夺回被帝国占领的领土，到进攻整个欧洲，除掉“叛徒”库可夫将军，反击帝国并杀死天皇芳郎，最终战胜帝国；并且与总理反目，打败总理，摧毁自由女神像，击败美国为止。最后指挥官当上了苏联的总理，领导苏联走上新时代（黑化苏联，反正前苏联总理没一个好结局） 3.2 盟军&emsp;&emsp;盟军起初在英国拼死抵抗进攻的苏军，并逐渐夺回欧洲，然后联合苏联对付帝国。其间杀死以极端方式（将一架卫星攻击器瞄准莫斯科）反共的总统阿克曼，在东京摧毁了帝国的军事总部，使帝国不再成为威胁，而后因为叛逃的泽林斯基博士而发现了苏军的阴谋，其后又与苏联重新对立并在列宁格勒决战，终于打败苏俄。最后原副总统担任新总统，规划了建立自由平等的新世界的宏伟蓝图（在盟军就别想当总统了） 3.3 旭日&emsp;&emsp;旭日帝国起初突袭苏联，利用将军刽子手摧毁敖德萨，再到抵御盟军（后来对抗苏盟联军），最后反击苏联，利用将军刽子手摧毁克里姆林宫和时间机器，击败叛逃盟军的泽林斯基博士，摧毁未来科技总部。最终指挥官被授予“超级将军”荣誉(天皇之子达朗所主持建造的超级机器人“将军刽子手” 科幻色彩十足，威力够猛） 3.4 总结&emsp;&emsp;红色警戒3对同时微操的要求更加高，特殊的技能也提供了更多的进攻措施，地图需要重复探索也提高了可玩性；英雄单位和超级武器的特效也是十分惊叹；也是值得推荐的一款游戏]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[They are bilions 攻略]]></title>
    <url>%2F2019%2F10%2F03%2FThey-are-bilions-%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇主要针对遭遇战模式（我玩的时候还没出剧情模式），但是也能对剧情通关提供科技点升级思路和建造思路。玩RTS游戏还是少看点攻略，自己摸索，即使过程硬核被毒打（崩溃），也是趣味满满 一、前言&emsp;&emsp;该游戏如果是（我）第一次玩就直接开玩遭遇战（不看攻略），且不进行花式存档，难度是变态难的，究极硬核。我连续玩了三天（游戏时间基本满实际两天），中途会了花式存档和看点基础单位的介绍，才撑到最后一波，然而最后一波真的是超乎我想象，结果又是推倒重来（三天才过第一关了解一下）。因此推荐玩这个游戏的时候，从剧情模式开始玩起；而且还是要学下如何存档，倘若是直接打就要补充点基本常识。这个游戏真正地（不存档，前期N+1次重开）教会了我什么叫做：“千里之堤,溃于蚁穴” 二、备份存档&emsp;&emsp;存档(菜鸡的必备技能)：备份存档 我的文档\My Games\They Are Billions 把这个”They Are Billions” 文件夹拷贝走;记住是第几天，最好是备注下第几天的档!需要读档的话 就先将游戏退出至主界面，ALt+table切换画面至桌面 把你备份的存档文件夹复制回mygames文件夹，并选择覆盖已有文件就行了。这样你点继续的话，就算是读取了之前的存档。这样操作是不需要完全退出游戏的!只退至主菜单，节省了时间 三、游戏介绍&emsp;&emsp;往往开局随机生成的地图，往往能够决定你前中后期的繁荣速度 3.1 布局思路&emsp;&emsp;开局，游戏开始附赠4游侠+1士兵；1士兵可用于站岗也可以清小群僵尸，4游侠快速在基地周围转一圈，整体估摸一下以后的布局。4游侠清理周边僵尸（走位反复横跳，不深入），扩大发展范围，稍后进行站岗 如何估摸以后的布局： 明确规划好（整块）居民区（尽可能2间为1层*2层形成收益最高的包围圈，两层间差一条街流动）+市场+银行的地块；最好每条路都留相通，防止（不智能）支援堵路（和美观）；争取形成一个以市场、银行为中心，包裹两层民居（每层2间民居，半径为4间民居）的繁荣区域。因此开始发展的时候也要靠往该区域发展 确保留有（树林）伐木场和（绿地）农场的未来地块；以及未来缺木材、草地时，要偏往地图哪个方向发展 在生产重地留有置放仓库的地块，以便提高产量 兵营、木头科技、石头科技、钢铁科技，都应该建立在前面规划剩下来的偏僻废地（无法发展民居、采集资源），也可以见缝插针建风力发电为未来繁荣发展节省地块（建立民居、农场等） &emsp;&emsp;当你玩多后基本就知道这盘游戏开局的好坏；有只需要防守两道口的天选之局，也有真就耳听四方守八方的开局，或者开局就有多面（方向）僵尸城镇压在你隔壁问候你的，这种开局，不要想老是重读档防突击苟活，读档只会减少你的游戏体验，还不如重开局，找到普通一点的生成地图，越少读档能玩得更开心、更有成就感 3.2 资源产出比&emsp;&emsp;有些地块产出资源比也不尽相同；要考虑土地和（土地转换出各种）资源的平衡，以及每个发展阶段的所需资源 伐木场，每个木材点产出12+就是好的 菜市场，每个石材点产出4+就是好的 钓鱼小屋产出大概是10-15的食物（尽可能沿海岸线建立钓鱼小屋；在锯木厂旁建立狩猎小屋（节省地块）） 农场，大概产出是30-50（最高64）性价比太低的点可以舍弃，留地块建设其他建筑（风力，兵营等） 3.3 资源需求&emsp;&emsp;资源堆着并非能发家致富，所有资源（除了钱）都是有容量限制的（建仓库可扩容），一旦超出容量，就是浪费人力物力电力。 木材科技升级，优先升级：农场、民居、市场、狙击手等（市场可以及时出售交易多余的资源） 开场优先 1-2个木材厂，主要需要用于建立防线（围墙和高塔）和游侠；前期过渡中期需要大量木材升级居民区帐营，准备好第3-4个开采木材地点 开场可缓段时间再建造采石场，需求量少，主要用于 高级建筑研究所、市场 石头科技升级，优先升级：民居，银行（400人）等 前期转中期后，需要准备大量（3个以上）采石场，用于居民区升级石屋；同时需要2个（左右）采铁场，保证兵营按时生产狙击手（多个兵营） 根据情况，可以出一个仓库 石材资源变成抢手资源（用于发电），多考虑延展布局采石材 银行可以优先考虑比石屋先憋出来，快速回收经济成本（此时应该是要有仓库的） 整个城镇建设尘埃落定后，考虑延长多带多路（沿路修建防御工事，并在旁边修建采集资源点） 3.3 敌人攻势&emsp;&emsp;明面上的进攻并不可怕，可怕的往往是偷家佬 3.3.1 自找死路&emsp;&emsp;开局清图（建造）太深、推僵尸城镇，会吸引出大量CEO（西装男）和女巫/胖子，此时基本上是毫无还手之力；要立马回缩防线（拆掉显眼建筑），实在来不及，就只能准备重开或者读档 3.3.2 只身立头功&emsp;&emsp;前中期要很注意小地图和听声音，入侵的僵尸哪怕一个，他的声音也是很大，一个不起眼的偷家僵尸只要进了生产区、居民区，基本就是要重来的 3.3.3 随机小波进攻&emsp;&emsp;地图会时不时有小波尸潮进攻，看不出来，但是数量是有点少的，稍微注意防一下还是很容易的 3.3.4 定时尸潮&emsp;&emsp;定时进攻的尸潮，往往是该时期最猛的一波攻击 1层木墙+1个(3个游侠)的木塔可以轻松顶住第1波进攻（1个游侠在外边疯狂引诱） 2层木墙+2个站了4个游侠的木塔可以顶住第2波进攻（1个游侠在外边疯狂引诱） 从第3波进攻开始， 就增加弩车AOE、木拒马和狙击手 前期防守时，可以让1个游侠在木墙外边走位，勾引尸潮拖住进攻时间 木拒马和铁丝网，是这个游戏的神器；木拒马，成本低，不仅减缓僵尸速度，多个还直接杀死僵尸，前中期对抗尸潮神器3.4 兵种推荐： 前期堆游侠防止尸潮和个别偷家 前中期，靠游侠，不出士兵；攒资源，直接憋出狙击手海（中期可多加兵营） 中期开始，可出死神搭配防守 中后期，小部分泰坦和狙击中队出去清图 四、最后一天：四面八方的尸潮&emsp;&emsp;没错，第一次玩疯狂坚守，读过档后，终于坚持到这里；结果这波尸潮数量那时候远远超出我的想象，又得是推倒重来，读档都救不了我（不想读太早的档）。下面讲一下一些方法（推荐的和不推荐的）： 推荐的方法： 把所有路全部防好，不要有侥幸心理，哪怕任何一条缝，尸潮都会进攻； 放弃部分难守的地块，收缩防守圈；3 狙击手（+死神），机枪塔，震荡波塔进行组合防守，震荡波塔（中后期）需要两层石城墙防守毒液僵尸远程攻击 ； 铁丝网准备就绪，铁丝网和木拒马都很有用，能多布置一点是一点； 塔上的狙击队选择厚血的优先攻击；震荡波塔+铁丝网（拖住充能时间）能清理大量杂碎僵尸； 根据之前发展的多带多路，考虑必经路线上边缘一点沿线火力支援，造1-2个炮塔（高塔）配合几层墙（+拒马），可以小部分尸潮（控制好距离，不要引诱太多直接被拆），有效减缓最后一波的尸潮进攻压力 不推荐的方法（要玩当然是光明正大地赢）： 用不上的资源建筑改卖的卖。例如：农场等； 拆除各类建筑补充对应资源； 五、心得&emsp;&emsp;游戏自己摸索才是真的好玩，游戏体验不单单是游戏提供的，也有部分是自己选择的；诚然有那些资源破解器或者高产版，过关会十分轻松，但是只会减少你的游戏体验；少读点档（毕竟技术还是菜），规划出自己心目中的城镇，并通关，这整个过程就是这款RTS游戏的魅力所在]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[他们 死在了祖国胜利的前夜]]></title>
    <url>%2F2019%2F10%2F02%2F%E4%BB%96%E4%BB%AC-%E6%AD%BB%E5%9C%A8%E4%BA%86%E7%A5%96%E5%9B%BD%E8%83%9C%E5%88%A9%E7%9A%84%E5%89%8D%E5%A4%9C%2F</url>
    <content type="text"><![CDATA[各位:&emsp;&emsp;我们以一个后人的视角回看历史时，原来已经不知不觉间忘记了，当时的志愿军们并不知道中国真的能取得最终的胜利，能再度成为一个完全独立自主的国家。在那样国土沦丧的背景下，最终胜利，现在红红火火的70周年国庆大阅兵，才更像是痴人说梦。 &emsp;&emsp;原来我们今天所习以为常的一切，并不是历史进程的必然结果。 &emsp;&emsp;当汉奸的人想不到会有今天。 &emsp;&emsp;而成为英雄，成为烈士的那些人，其实，他们大约也是想不到的。 &emsp;&emsp;到那一天我才突然明白，原来“不做亡国奴”不是必然结果，“抗争胜利”并不是必然结果，“建立独立自强的中国”也并不是必然结果…… &emsp;&emsp;原来那些人说着“我们一定会获得最终胜利”时，并不真正的知道，他们真的能成功。 &emsp;&emsp;原来他们前赴后继地牺牲的时候，也并不真正的确定，他们的牺牲是不是能换来他们想要的结果。 &emsp;&emsp;原来“坚定的信仰”，是这个意思。 &emsp;&emsp;原来我们一直知道他们伟大，却依然低估了他们的伟大。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小学生农药rank速上分攻略]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E5%86%9C%E8%8D%AFrank%E4%B8%8A%E5%88%86%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这篇主要是个人对农药游戏的理解，每个人的理解都不同，你可以从这份个人攻略提高自己的游戏理解，反过来也可以看出我的意识程度如何。截止20200115之前，不过这份攻略已经有些变动老旧了，大体没变，具体改动放到最后一节。 一、前言&emsp;&emsp;首先要讲一下对这个游戏的看法。与英雄联盟相比，不是同个难度层次的游戏，如果王者荣耀是2D难度，那么英雄联盟的难度是3D。观赏性天差地别，我看主播和赛事也只是看英雄联盟的。但是架不住香还是手游香：节奏（一局时间）短、配置需求低，随手一抄直接群体开黑等优势。英雄联盟久没玩就越不敢玩，农药靠点意识还是能随便打的。但是不管怎样，两者的rank和赛事就是两种不同游戏，这里只讲农药的rank速上分攻略 二、上分基本知识&emsp;&emsp;同样也是5V5,不过地图更小、支援更快；少一个召唤师技能,没有特殊天赋，笨比英雄秀不出多秀的操作。因此影响游戏胜负的判定因素也更少，更能看出这盘游戏的走势；打了这么久,我的理解就是假如一盘游戏中(不考虑某些特殊英雄)各个位置的影响胜负程度分为以下占比:&emsp;&emsp;胜负 = 40%中路 + 40%打野 +20%上下辅先说好，是一组中路决定，而不是单个中路决定的；10个人的游戏，实际上最后只有一种结果，10个人，分为5个对称组；也就是说这盘游戏决定输赢的核心位置只有两个:中路（*2） 和 打野（*2）（下面会有分析），其他三个人（*2）在这盘比赛的作用顶多只是擦屁股。 因此rank上分的话,尽可能多选中路或者打野即可快速上（掉）分。反而言之，当你rank常据这两个位置的时候，你一直卡在某个（钻石）水平，这就说明你水平很菜还坑队友。 2.1 游戏节奏（常规英雄）分析&emsp;&emsp;游戏节奏分为三部分：前期、中期、后期 前期：从全局的资源初始化来看：大家没有等级差距，中路兵线是最早可清的，其次是野怪的生成。因此影响前期的走向一共有三个位置：中路 &gt; 辅助 &gt; 打野。 中路一旦获得线权打出压制力，就能快速地入侵/防守野区。而且打野前期往往具有很大的缺点：1级刷红（蓝）开始，更换野区，2级刷蓝（红），4级准备gank抓人 or 拿龙团战，动态是可以探野区预知的；&emsp;&emsp;中路，一个优秀的中路可以通过前期反野（猪），得知对面打野（1级-&gt;4级）几分钟内动态走向，预见对面的打野（4级）可能gank哪一路，提醒队友被抓；同时根据（预估）对面打野动态，如果抓上/下路，压制对面中路兵线，火速gank另外（对面打野不在）一路 or 反掉 对面打野刚（快要）刷新的野区（1级刷野区域）。；如果是抓中，就假装不知道，一直在危险线徘徊，引诱对面打野蹲人，浪费时间。这样，队友被你的信号警告撤退，只要对面打野强杀或者折返，会失去一片野区的控制或者另外一路的爆炸；也可以根据英雄强度，配合自家打野辅助+（上/下 路）反蹲对面打野，打一波小团拿龙；相对来讲，反向支援不进行硬碰硬，收益会来得更稳定，比较推荐 反野 &gt; 抓单 &gt; 反蹲。&emsp;&emsp;打野，前期对打野也是异常重要，反而言之，是决定反野，还是守自家野区，又或者是互换野区，5级之前的时间都是十分珍贵，不要乱蹲人来浪费时间。&emsp;&emsp;辅助，辅助在这段时期也是尤为重要，这段期间，例如对方中单是 米莱狄/周瑜 这种前期压线能力很强但中后期较弱的英雄，需要在1-2级帮忙中路压制、威吓一下，减缓中单的兵线压力，换取中单支援能力；跟着打野反野/防守也会起到较大的作用。&emsp;&emsp;这段期间，上下路基本无作为，但是上、下路需要注意3级不要起杀心，不要想着秀操作，首先根据中单前期作为，第一判断对面打野路线；如果确认对方打野不在，才第二开始秀操作；尤其是上路（元哥）三级秀操作，能看到 结果很多对方残血打不死，打野插一刀的场景。 中期：这段时间，大家开始有一定的等级、装备差距压制，打野位的选择将会多了许多：‘清野、反野、控龙、抓人（三条）’；中路开始不能盲目gank，出去支援也要推断对方打野位置；因此影响中期的有两个： 打野 &gt; 中路。&emsp;&emsp;打野，中期往往是打野在掌控雷电，游戏时间的每一分每一秒都是资源：：‘清野、反野、控龙、抓人（三条）’；蹲人往往收益少于立马决策做其他事，无异于慢性死亡；该止损的止损，该入侵的入侵；配上会入侵的中路更佳。顺风的打野基本在这个时候基本接管比赛。中路，中期也是中路实力的分水岭，如何对线有压制力、甚至单杀，然后预判对方打野动向，做到防gank和gank别人，同时在gank过程中，平衡中路一塔血量和gank之间的平衡。顺风的中路基本在这个时候也基本接管比赛。&emsp;&emsp;辅助，这段时间的辅助往往不能乱带节奏，打野中路不跟的话，辅助没有伤害也只是在浪费时间；因此要根据三路和打野的动向，来决定下一波帮助哪里（擦屁股），至于如何判断，就要根据己方的等级装备和前期的操作，假如这波gank，命中总体3/4技能伤害加起来的不足杀人，就要考虑另换其他地方。&emsp;&emsp;上下路，虽然伤害起来了（崩了），但还不足够接管比赛（输掉比赛），打团的时候不忘保上/下塔，分推兵线给予对方压力又及时参团（就是个劳苦命）。 后期：在后期，已经差不多是各路神仙（笨比）英雄都能乱秀的时期了。这个时候不存在哪个位置影响力不大的情况了。但是还是有个比较关键的点：中路；廉价又高伤害的poke能力影响后期的比赛情况，而这种能力往往是中单英雄，当然也存在其他路英雄出色的poke能力。 &emsp;&emsp;一盘较高水平的比赛，往往拖不到后期；因此综上所述，中路和打野往往决定了一盘比赛的输赢，当你玩其他路的时候看着队友崩，自己无能为力就明白这种感受了，所以推荐中路、打野快速上分。 2.2 位置分析和英雄选择&emsp;&emsp;位置分为5个：上单，打野，中单，下单，辅助 2.2.1 上单&emsp;&emsp;如何作为一个t1-t0级别的上单呢？ 出色的抗压能力。能够单人对（射手）线中在四级前（三分钟内）抗压守塔，甚至让他不敢多摸一下塔 出色的支援能力。打团支援能够十分及时 出色的分推能力。持续的分推给予对方压力，以便打野趁机控龙 出色的一打多能力。能够拖时间，甚至反杀gank你的人 另类的干扰野区能力。能够带惩戒，一级抢河蟹，前中期过渡期间控制（反）对方野区，导致对方打野崩盘 以上有满足几个条件的，就可以当一个上分的上单了；当然不是选了好英雄就能上分，一些基础的分推塔、守塔、打团意识还是要有的。 举例：刘邦（斩杀），孙策（闪现/眩晕），狂铁（闪现），元哥（闪现）；后面会详细讲解英雄特性 2.2.1 打野&emsp;&emsp;打野其实主要分成3类：物刺、法刺、物战；他们其中各有各的优缺点和特点，并会有一定互克性。 物刺：荆轲、玄策、娜可露露、李白、花木兰、兰陵王、猴子 法刺：露娜、司马懿、芈月 物战：赵云、典韦、杨戬、耀 2.2.2 中路&emsp;&emsp;如何作为一个t1-t0级别的中单呢？ 前i期中路对线有足够的压制力 足够的游走能力。在有压制力的同时，能够前往gank且及时回中路一塔（位移/移速加成） 前中后期有（越）廉价的poke能力 较高的技能命中率（参照反例：安琪拉） 另类的干扰野区能力。可以在（不）带惩戒的情况下，敌方打野gank其他路，趁机入侵对面新生成的野区 以上有满足几个条件的，就可以当一个carry型中单了；当然不是选了好英雄就很强了。 举例：沈梦溪（闪现），小乔（闪现），干将莫邪（闪现），武则天（闪现），嫦娥（闪现） 2.2.3 下单&emsp;&emsp;这个位置一般是射手，脆且下路支援能力差，擦屁股位置；在这里就推荐几个 举例：狄仁杰（真正的战士），公孙离，孙尚香，马可波罗 2.2.4 辅助&emsp;&emsp;在整盘游戏中carry和擦屁股摇摆不停的位置，主要还是前期能力、开团能力、保队友能力为主 举例：东皇（闪现），牛魔，鬼谷子，张良（惩戒） 等等 2.3 个别英雄特定分析&emsp;&emsp;在这里逐个分析一些英雄的特性，用他还是对抗他都可以更好的发挥 2.3.1 上单（刘邦）&emsp;&emsp;上单刘邦目前是rank中排名t0第一（我封的）的上单；出色的一二技能 能够压制敌方射手推塔，并且能够反打消耗，多次消耗还能够配合斩杀将对面击杀，在四级开始就有扭转战局的能力（给打野中下路擦屁股）。例如：你家射手鲁班脸探红区，花木兰窜出来一套，此时你是可以改写人头变化的。他之所以能够这么强势不单单因为技能缘故，也与铭文出装有关系。装备推荐：抵抗之靴+冰拳之握+极寒冰心+不祥征兆+魔女斗篷+复活甲铭文：10%移速|10%攻速（蓝）+ 10% CD冷却（绿）+ 红（我是叠护甲和攻速） 强度原因分析： 正常情况下，前期直接裸出两个220布甲（可以防止敌方铭文百穿直接压回家），然后开始合成抵抗之靴；这段时间抗压能力已经是可以反打的那种了；那么如何进行反打呢？之所以两个布甲顺滑合成冰泉是为了（磨血）击杀敌方 用来补充伤害的（是的没错，就是这么强势），需要打2-3套 （1+2）技能+（1-2次）普攻，（此时对面被吓到）及时拉开距离防止被消耗；这样轮回不止，我们生，他们死。当然也不要过分想要线上击杀，换血消耗，让他龟缩塔下不能支援，而我去支援也是一种胜利法。 前中期间，按照装备合成路线，此时是 抵抗之靴+冰拳之握+极寒冰心（+ …）；抵抗靴防止对面中单 法术双穿，大大减少中单对你的伤害；冰泉+冰心，这护甲在该期阶段（对方没有破甲）跟个爹一样，除了特殊（娜可露露的一技能比例伤害）之外，其他打野是抓不动你的；而且现在40%的CD冷却，可以频繁消耗、分推带线、参团 根据对方情况，先合成 不祥or魔女 均可；有人可能就会问，要出霸者线上分推回血吗？当你出这个的时候，说明你对游戏和该英雄的理解不行。玩刘邦，不仅分推，还需要多观察小地图，预判打团的时间；例如我在残血推线，预判是再过15秒开团，火速清线，（确保安全）原地回城，此时团是要基本打起来的，利用提前回城剩余时间和 大招传送时间（大招传送时间将近回2/3血）进行参团；这样的刘邦就能靠自己的意识，自带一件高配版霸者重装了。 对局细节分析： 该英雄会被武则天counter，要让对面先选或者ban掉 深推兵线，能够gank你（你就是中期 高护甲带减速的爹）的打野基本只有一个：荆轲；荆轲那 廉价（真不要钱）的减速，让你回不了塔，但是有一点，她没有控制，可以立马加盾传送走人；其余打野轻松走路回家；走的过程中，二技能要看好时机放，最好不要被打断 一定要多看地图，用大招划队友头像观看（记得划掉）战局分析也可以 &emsp;&emsp;讲完刘邦，看孙策；就有一种异曲同工之妙，不过支援是另外一种方式，一样有扭转战局（擦屁股）的能力。&emsp;&emsp;讲一下剩下的上单英雄。上单往往前期要叠 1-2件护甲背心抗压（效果俱佳，防对方百穿开局的蜜汁伤害）正例： 吕布，抗压能力好，分推一般，容易附魔上头，大招释放要求较高，没有射手局会比较吃香； 狂铁，控好能量轻松1V2，不能上头，铭文出装有要求（铭文：回血|移速（蓝） 百穿（绿、红） || 出装：抵抗之靴+黑切+极寒冰心+名刀+不死鸟+复活甲），前期也要考虑出下两件护甲背心； 元哥，1级 第一个兵控好不要被反控兵线丢掉（我一般二技能等第一个兵快没了才第一次放），3级起杀心小心被打野（4级）抓；其他就花里胡哨自己秀吧 亚瑟，黑切冰拳出了，打拉扯走位，该是你（脆皮）爹还是你爹 李信，带闪现光信看操作；带惩戒黑科技暗信，一级抢河蟹，偷野推线偷塔（经济压制）反例： 程咬金，版本更换的失败者，被无数射手counter，举例：狄仁杰（爸爸）、虞姬（新版专克）、鲁班（这都能被克）；又无法携带惩戒脱胎换骨，前期打野必会被 自身被动 耗危险；分推能力有限，当对面来个辅助庄周守线，就好比上等马（上单）对下等马（辅助） 庄周，等同于放弃这条路 梦奇，对质量变换要求很高，需要多练，但是上限不高 花木兰，会玩的射手往往不会给很多机会，脸探红区就更少了；能够在红区击杀射手的，换个其他上单也能够实现压制对面 2.3.2 打野&emsp;&emsp;这里只讲一些英雄特性裴擒虎：1级必定反野，小心红区草丛跳出来抢野；不反野，这个英雄没有翻身的余地百里玄策：2级gank，尤其是中路，一定要小心，玄策学到1-2技能带个辅助会快速gank获取优势，经典案例：中路草丛链中单拉回去三人配合击杀一血司马懿：同理2级gank，2级是他的强势期露娜：开场刷蓝李白：往往红开，李白二技能释放位置、时机决定了一个李白的操作水平，同时你如何应对李白的二技能也反映了你的水准；李白是很需要百穿铭文的，同时2技能伤害是有破甲效果，然后增加大招伤害效果；那么你被抓，要冷静站在圈内互怼，即少受到李白的二技能伤害、也不会受到加强（破甲）伤害的李白大招，伤害对你来讲不够致命，此时李白要么走，要么被击杀；由上面所述，当对面打野是李白，可能考虑前期出220布甲小背心，在不被李白二技能刮到（坚持在圈内）的情况下，大大减少李白gank你造成的伤害；好的李白当然是控好位移1技能距离，2技能开启刚刚好能刮到你，然后大招伤害最大化。韩信：往往蓝开芈月：很注重红buff，要求敌方打野灵活性较低，方便正面刚入侵野区杨戬：有一定counter打野战士（赵云、典韦）和脆皮刺客（荆轲），虽是笨比，但反打其他笨比能力强兰陵王：这个英雄前期英雄，伤害还有点低，容易被秀，还是不要选了吧；当辅助还行 游戏的前中期对打野尤为重要，时间就是优势，节奏就是要点，不要盲目反野，要根据对方打野动向来判断哪片野区有野，切记不要无所事事逛街、蹲人；在做现在的事情时，要计划好到后面几步是要怎么做，不要迟疑直接去做；gank过程死亡，or 遇到对面厉害的 断节奏大佬（惩戒上单，清野中单），重新把握节奏，判断游戏的走向，不要被牵着鼻子走（例如；红区被反，就直接上线抓人，然而不是为了抓人，而是为了蹭线赖在那里，且赖的时间久，赶不回蓝区的刷新，对面入侵蓝区，节奏就爆炸了） 2.3.3 中路&emsp;&emsp;压线能力、poke能力、走位（位移、移速）能力为中路最重要的能力压线能力是 英雄+操作得出来。有的人能米莱狄压诸葛亮，反手诸葛亮压制米莱狄，操作是要多练的；poke能力则是与生具备的；走位也是 英雄+操作需要多练。举例： 我 小乔 ， 敌方 诸葛亮一级的时候，如果我选择快速支援或者（早）入侵，则需要赶紧出门堵在前面一技能推线，但是这样会出现什么情况？你没有一技能，诸葛亮可以光明正大叠三层被动，你必需要干扰他叠出5层被动来对你压线；如果我不入侵而是要压制诸葛亮，就捏着一技能，导致他怕被我消耗，逼迫他一技能只能打出1-2被动后，（CD的缘故）开始清线消耗他，这样的诸葛亮基本就是会被压线，毫无反抗能力（其中要穿插普攻消耗诸葛亮），这个时候你可以（晚）入侵或支援 举例： 我 诸葛亮 ， 敌方 小乔一级的时候，可以稍微贴近己方靠后兵线，引诱对方一技能推线并躲开，然后光明正大靠前叠出三层被动，cd下一波就能够压制对面兵线了（其中要穿插普攻消耗）；要找机会叠三层被动，走位躲技能压制对方（其中要穿插普攻消耗），被动一出就可以入侵、支援了 英雄推荐： 沈梦溪，作为一个1-2级不讲理的英雄，控好炸弹数量和穿插普攻，能够同时实现清线和消耗，堪比中路的东皇；入侵野区刷野的速率也很快，支援控2技能cd还很快，counter部分中路英雄，是中路t0英雄。缺点：大招cd极慢，对大招释放要求高；因次也有英雄counter他：带吸血刀开大的黄忠，能够长距离吸血防止沈梦溪开大打团收割，其他射手c位需要更谨慎走位吸血才行。沈梦溪支援往往是 大 招+1技能+2技能+普攻+1技能+普攻+2技能 ，或者是 大招+2技能+1技能+普攻+2技能。要明确自己击杀对方的血量斩杀线，再决定gank手法；例如我大招消耗一波，2-3秒立即2技能跟上1技能带普攻直接击杀对面，要对自己的伤害做出详细的估算 小乔：前期一个比较弱势的英雄，根据自己操作提高压线能力入侵野区。这个英雄的特性就是技能移速加成，打拉扯则是小乔的操作关键点；无论是满血还是快死的人，最好都要打拉扯，不要掉以轻心。我的出装： 法穿鞋+吸血书+回响+帽子+法穿+金身 ，铭文： 10%移速|10%攻速（蓝）+ 法穿（绿、红））；前期的法穿鞋可以起到双穿提高伤害和回蓝，吸血书虽然降低伤害，但是能够提供良好的血量，能够更好得走位、拉扯（个人认为前期弱势单纯提高一点伤害意义不大，有血量的拉扯能有更多走位选择）。小乔中后期就是 廉价（真不要钱）的poke能力|拉扯能力的经典代表。 干将莫邪：1-4级均为强势中单，需要多练插得准，1技能在1-3级野区拉扯的时候，可以配合闪现反推，然后配合队友击杀；1级可以躲草偶遇对平A，带点暴击铭文（清线）舒服一点；机动性较差，不能乱入侵野区；有时候可以在中路塔边缘引诱对方打野、辅助，反推1技能进塔收拾。 嫦娥：1级除 对线沈梦溪外 敢快速清线的人，要对野区的掌控力高，尽可能对面蓝开反猪，红开等2-3波后去红区反角落小鸟；当然也有可能快速2级反野遇见对面打野+辅助+中单支援，两下就瘸，不要吝啬闪现（这时候闪现不是很重要），靠特殊回城技能快速回线，基本就是在反野的路上和警告队友被gank；也可以引诱对面，然后草里一技能出来快速反；时不时看机会（几率较大）再gank其他路；不要 乱放大招（加速死亡），能不能大招收拾的尽可能少用大招，准备接下来的团战；铭文需要带吸血，不能出吸血书；要对野怪刷新有很深刻的认知才能驾驭这个英雄，这个英雄不是用来打崩对面中路，而是用来打崩对面打野的。 武则天：人民币英雄，只有免费的时候玩过，大招配合强化1技能的击飞，或者打团大招，还就真的香 其他英雄简介： 诸葛亮：前中期英雄，poke能力差一点，操作走位要求高，闪现是用来杀人 不是用来逃跑的；前期会被 王昭君counter（前中期强势这就是喂了屎嘛），你会发现，王昭君的盾刷新速度+回血包比你消耗的要快，而你被反过来消耗血。反过来也可以预判对方诸葛亮的（经典案例：中路草丛 闪现 到中路野区间小道）操作，及时扭一下位置，能够防止诸葛亮：闪现+1技能+2技能+（穿插普攻）3技能，当你扭开导致诸葛亮的 1技能空掉或者少被动，往往都是能反应过来，而且击杀不了你，你还可以反杀他。 上官婉儿：垃圾英雄，不推荐使用。前期一般的压线能力，4级前的零支援能力，鸡肋的大招效果。看似很强，其实伤害少得可怜；4级，双方接近满血的情况下，上官婉儿想要击杀对面，就必须要在大招行进路程中打出被动碰到对面，统计一下 伤害来源 = 生成的被动（1/2 技能 + 3技能 ）+ 3技能 + 强化普攻 （+ 二技能） 也就是说，我方中路闪现（或走位）及时躲开被动，这个上官婉儿就击杀不了人，甚至心浮气躁搭上闪现也发现击杀不了你。她的一二技能较慢，如果她大招放完你没死，残血的你这时候就更要冷静、把控好距离；在她二技能范围内，左右走位，躲开她的缓慢一技能，二技能就更好躲了，然后距离内 拼技能、平a反杀（边打边走也行）上官婉儿；切莫拉开距离的时候，走a停留在“刚刚好”（上官婉儿有意为之）拉扯到她的二技能点上，要及时走位躲开二技能点。单对单的时候，上官婉儿不怕（菜鸡）金身的，对线别妄想金身就克制上官婉儿。主要还是这个英雄容错率低，招式杀心明显，大优势容易贴身送回去，这也是她的最大痛点。上官婉儿连招基本就是 2技能+3技能+ （强化普攻）1技能+3技能（强化普攻、2技能），那么如何看出她有杀心，关键就在她的 1技能，假如她清线不用1技能，说明她动了杀心，如果用了1技能，就能够放心清线，3-4秒（查技能cd）是安全的。沈梦溪是上官婉儿的couter，他可以连闪现都不用来躲上官婉儿大招、强化的一技能打断大招 和 二技能反过来追击反打；只要她开大，沈梦溪立马开二技能跑，后面准备反打；但是也有种特殊情况，沈梦溪开二技能被上官二技能减速，这种会被追到且8成会死，这就是你的拉扯问题，你菜不怪英雄。如果你操作有点菜，也可以出个小斗篷加强防消耗能力，因为上官是cd鞋，她铭文需要穿透，装备还需要出一个小穿透来达到对脆皮的伤害最大化；出个小斗篷，降低上官对线消耗能力，被刷大后残留更多的血量能走更多位来反杀上官。 高渐离：需要出半肉（前期出个220布甲背心降低对方百穿伤害有奇效），且在未出吸血书前较为弱势，这段时期要谨慎gank；对线他的时候，两个c位要分开站好，往往是闪现大招人群开团；我玩的时候是团战发动机,因此对线他，很顾忌自己的站位，例如：小乔，我都会脱离团队，等（预判）他闪现进场（位置），放一个二技能打出控制，再poke一下，这个高渐离就算是完了。 其他的笨比：安琪拉、王昭君、妲己、扁鹊、米莱狄（前期给他压力，推不了中塔，她就算完了），我就不多介绍了 中路一塔对中路前中尤为重要，可以放弃gank来守塔，中塔是核心点；中路塔只要是在前期掉了，那么这盘游戏的前中期局势就跟（被推塔方）中单没有关系了，基本沦落成辅助（擦屁股）的位置，所以一定要注重兵线对中塔的影响。 2.3.4 辅助&emsp;&emsp;辅助就百花齐放了，牛魔辅助第一是因为他的容错率高，现在也开始双惩戒局，可以考虑下类似 惩戒辅助张良（二技能快速清野；惩戒（肉打野刀：层数少）快速帮打野清野防守 or 入侵野区；强化辅助石 开启移速弥补闪现位移抓人；两个硬控保队友的辅助特性）这些操作 2.3.5 下路&emsp;&emsp;讲一些射手英雄特性 马可波罗：前期单线不需要辅助（关键点），因为推塔能力差，是秀是死看自己操作 虞姬：鸡肋英雄，最好不要用，区分虞姬的操作，只需要看她的一技能释放时机和准确度，因为她的一技能前摇巨大，容易在这个时间点被反杀、被gank击杀（我就是这种）；遇到那种一技能被人突到脸上秒了的，就不要管她生死，帮忙其他路吧 狄仁杰：你爹还是你爹，要注意一下他的发育情况，遏制一下他的发育；不要被他一路压完二塔 三、心态总结&emsp;&emsp;心态很重要，心态往往会影响你的操作。你可能觉得你心态很好，但是如果发现自己的操作开始变形，其实就是你的心态发生了改变（累了），要及时退出rank。不要起杀心和贪心，这点也很关键；当你起了杀心，你的操作将会十分明显（变成一条线，甚至变形），预读起来十分轻松；当你起了贪心，也会让你的操作变形。 举例：对线 达摩（闪现）、高渐离（闪现）、诸葛亮（闪现）、上官婉儿； 一个起杀心（心态不好）的 达摩 玩家，你只要稍微靠一下墙引诱一下离开，就可能出现 达摩一闪大空 然后被人反杀； 一个起杀心（心态不好）的高渐离玩家，你靠一下队友又撤出来，他就会闪现进场，因为你撤出来，他会发现对方有个c位在旁边控制和poke他，高渐离就基本没多少作为 诸葛亮，会玩这个英雄的闪现往往是用来杀人的，闪现+(贴脸)一技能+二技能+三技能；但是反过来，你引诱一下，然后及时往左或右扭开，就能够 让他闪现（贴脸）一技能空掉 上官婉儿，不预估伤害量，和对方其他人位置，直接刷大，甚至闪现跟进，互换甚至敌方残血跑掉 &emsp;&emsp;只要是起了杀心、贪心，心态不行，都会影响到操作变形。该拿的拿，不贪多，人头迟早会有的；输了一盘rank，如果自己是中路 or 打野，要反思一下自己，哪里还能进行更细节的操作，这盘哪个点自己做得不好，以便后面越打越提高自己的意识操作；如果自己是其他位置，哪里带了队友一波节奏，不该送哪个人头，不过是擦屁股的位置，心态放宽点。 练习游戏内的拉扯，可以考虑练习：橘右京（rank别用）、小乔、马克波罗 这几个英雄；练习意识的话，可以考虑练习：刘邦（上路）、中路、打野；中路其实和打野的意识是互通的，往往你打野好，中路也会打得比较好。另祝各位上分愉快！！ 四、版本更新&emsp;&emsp;版本永远是大爹啊！！！ 4.1 截止20200115之前&emsp;&emsp;由于之前的分析可能比较好吧，分析到的基本都砍了(泪) 胜负 = 35%中路 + 45%打野 +20%上下辅 视野的实际视距缩小，大概缩小了1/3，防gank将更需要意识，反应要求更高；暗地削的，可能是这个煞笔游戏想让人注重看人物模型吧 中路法装的削弱，回响(加成0.5 -&gt; 0.3)和面具(法强140 -&gt; 100) 兵线的后期强化，兵线将会越来越难清，伤害越高，速度越快 中路增加河道怪 前期龙的选择变成了两个 部分英雄的削弱：耀、荆轲、扁鹊、嫦娥等 改了点召唤师技能 &emsp;&emsp;中路是最近版本综合削得最惨的 视野的实际视距缩小，导致游走和防gank有了更高的难度；让混子法师(一直呆中路)反而收益 回响和面具的削弱，导致中单滚雪球的能力更差 兵线的后期强化；这个要分两个点来分析：1) 对于一些中后期的法师，基本是要害；因为如果队友前期劣势(而且菜)，由于自己是中后期发力，前期只能提供有限的帮助；这样的话，很容易出现前期劣势；只要前期劣势的，其实中路法师是比较难吃到兵线的，而且兵线加强了，中后期更难清线，(脑瘫)队友就开始抢线了；这样的局势，你中路再会玩，也要拖到比之前版本更加后期才能打举例：小乔2) 有些法师由于技能的特殊性，即使是前期很猛的英雄，由于限制导致，中后期兵线清理将会十分艰难举例：沈梦溪 其他中单法师的削弱1)嫦娥：前期真的太猛了，被比赛因素直接砍伤害；中后期缺少poke能力，现在是下水道了2)扁鹊：砍了大招范围；谁用谁知道，直接下水道了 应运而生的新强势中单1)诸葛亮：随着之前的其他T0、T1(沈梦溪、嫦娥、小乔)削弱，外加中路野的加成，现在是T0中单了2)干将莫邪：变化不多，虽然是被砍了，但是是大家都被砍，反而由于 视野被砍+大招被动，反向加成(大家都削了嘛)，外加中路野的加成，；不过由于本身玩法机制，他一直是T0中单3)高渐离：前期稍微地弱势，中后期发力，但是清兵 和 反打(半肉)能力强，外加中路野的加成，再外加 小乔 削了，所以上位为 T1中单(召唤师技能可替换成狂暴)4)嬴政：人名币英雄不解释，回响和面具(被砍)不出，要出的巫妖(没有被砍)，反向加强5)武则天：人名币英雄，玩法机制仍旧强势，大家都懂 &emsp;&emsp;上路的版本变动不大 仍旧以 刘邦、孙策 为首的 T0、T1上单 边路惩戒(肉打野刀)入侵型上单的崛起1)李信：暗影模式，惩戒；T0上单，被count的只有：狂铁2)孙策：一三技能连贯逃跑，惩戒；T1上单，容易集火就跑不掉，需要出黑切+宗师（+冰心），提高刷野速率3)夏侯惇：大招霸体走，惩戒；T1上单，惩戒用于减速敌人，二技能真伤反野4)耀：各种方式走，惩戒；T1上单，原本还能更强，但是由于对大招伤害削弱，故为T1上单 &emsp;&emsp;打野的版本不大，主要是对个别英雄的削弱和加强 荆轲：技能的削弱，战士打野的崛起，导致她和兰陵王的尴尬位置不远 杨戬：史诗级加强，一技能的范围和机制都改动，战士打野的大部分克星 百里玄策：钩到任何物品的30%免伤，我真的佩服，防gank一流 打野的前期，将更需要辅助度过难关(尤其入侵) &emsp;&emsp;辅助几乎是没有变动，不过这里推荐两个隐藏英雄 惩戒张良：带惩戒出二技能的辅助张良，基本上是反野克星，而且还能入侵，中期需要出奔狼纹章用于 走位 和 团队gank；1)缺点：长手法师无法触发打野刀额外伤害效果，故前期出辅助石(300)即可；对意识的要求更高，不能乱走位探视野，本身前中期很脆2)优点：张良自带真伤，法术加成低，注重出法穿，出两件法强(面具+帽子/回响)等就能刚好秒脆皮，而且携带惩戒，能留住敌人在二技能范围内更久，伤害更多；辅助张良是辅助东皇的究极克星，从前中后期都能完爆对面辅助东皇，实属count关系3)出装方式: 肉打野刀+奔狼纹章+法穿鞋+冰心+面具+回响/帽子4)铭文：法穿88+法术吸血16% 金身钟馗：钟馗这英雄自带仇恨值，体积又大，中期带金身能够大量吸收伤害和躲开控制技能，打团时候，能把对面牵制将近3秒1)缺点：钩子太差就别玩了;大招机制可被逃跑，不能单走，且没有对线能力；被动的问题，很少推塔，只要推塔，别人冲过来打你触发被动，你就要挨防御塔的打了；2)优点：法术加成不高，出1-2件法装，能刚好秒掉一个C位；金身中期能吸引大批火力反打；出小极影(价格又低)混被动；3)出装方式： (1)小极影+CD鞋+防弹背心(220布甲)+金身；(2)小极影+CD鞋+金身+冰心+霸者+振奋；(3)大极影+法穿鞋+金身+冰心+霸者+振奋4)铭文：88法穿+法术吸血8%+移速5%+攻速5%(可把吸血替换成移速)]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建自己的hexo博客]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文不讲详细搭建，小白只是记录一下自己主题是如何（有手就行）配置 一、搭建基于Github和hexo的个人博客&emsp;&emsp;如何搭建最基础的hexo博客，可以参照这位博主，他写的很详细：GitHub+hexo搭建个人博客 二、博客基础配置&emsp;&emsp;配置主要修改的是站点配置文件和主题配置文件（均为_config.yml文件），后面“站点”、“主题”内容均指对应配置文件；安装文件若没有特殊说明均在站点（博客）根目录下安装。 2.1 基本配置&emsp;&emsp;打开myblog根目录下的_config.yml文件（站点配置文件），找到Site模块修改如下基本信息（注意：冒号后面带有空格） 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 2.2 Next主题安装&emsp;&emsp;进入到生成的博客路径，安装一个next主题 12cd mybloggit clone https://github.com/iissnan/hexo-theme-next themes/next &emsp;&emsp;修改站点_config.yml中的theme 1theme: next 做完记得清除Hexo的缓存：hexo clean&emsp;&emsp;安装完next主题，进入 根目录/themes/next 同样也会有一个_config.yml（主题配置文件）。 2.3主题样式&emsp;&emsp;在 主题 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist scheme: Pisces#scheme: Gemini 一共有四种主题风格可以选，对应的侧栏设置也不同。在 主题 找到sidebar 12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 2.5 菜单，标签，分类，关于&emsp;&emsp;在 主题 找到Menu Setting 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 以archives: /archives/ || archive为例：||之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去 Font Awesome 中查看或修改，Next主题所有的图标都来自Font Awesome 。 &emsp;&emsp;这个时候，菜单中的标签、分类、关于是进不去的，需要自己另外新建页面。创建标签 1hexo new page tags 在站点路径的source会生成对应页面文件,只时候才能进去菜单的标签页面；其他页面同理；页面标题可修改title，关闭页面评论可修改comments。 123456---title: some tagsdate: 2019-09-22 15:19:49type: &quot;tags&quot;comments: false --- 增加一些自己特有页面，还要修改其对应的翻译文本，翻译文本放置在 Next主题 目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 2.6 头像设置+旋转&emsp;&emsp;在 主题 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg放入themes/next/source/images中就好了。实现头像旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 2.7 添加搜索功能1.安装 hexo-generator-searchdb 插件 1npm install hexo-generator-searchdb --save 2.修改 站点 ,找到Extensions 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3.修改 主题 ，找到Local search，将enable使能 true。 三、博客高级配置3.1 浏览量 访客量 阅读数&emsp;&emsp;在 主题 写入代码如下： 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 有 site_uv_footer: 人看过我的博客啦 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 本站总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 次阅读 修改统计规则及busuanzi失效修复&emsp;&emsp;打开\themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话：代码如下： 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 3.2 字数统计 阅读时长 总字数&emsp;&emsp;在站点根目录安装 1npm i --save hexo-wordcount 然后再进入 主题 修改如下： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true #字数统计 min2read: false #预览时间 totalcount: false #总字数，显示在页面底部 separated_meta: false #无作用 3.3 文章发表 更新时间&emsp;&emsp;打开 主题 ,搜索关键字updated_at 123456# Post meta display settingspost_meta: item_text: true created_at: true updated_at: true #文章发表 更新时间 categories: true 3.4 友链、社交网站&emsp;&emsp;友链可以在 主题 Blog rolls参照注释 1234567# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: inlinelinks: 火影.青春.梦想: https://www.bilibili.com/video/av42311652 FATE.士郎: https://www.bilibili.com/video/av45828728 &emsp;&emsp;社交网站同理在 主题 social参照注释，不过需要配置social_icons 1234567#是否启用社交链接图标social_icons: enable: true#匹配图片名称，在 Font Awesome 查询 GitHub: github Twitter: twitter 微博: weibo 3.5 博客运行时间&emsp;&emsp;打开next\layout_partials路径中的footer.swig,加入下面代码段（我加在了最后面）： 1&lt;span id=&quot;timeDate&quot; title=&quot;网站运行时间&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot; title=&quot;网站运行时间&quot;&gt;载入时分秒...&lt;/span&gt; 在next\layout_layout.swig中插入下面代码块： 1234567891011121314151617&lt;!--此处为建站时间 --&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;09/13/2019 12:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML =&quot;(ㆆᴗㆆ)本站建立了&quot;+dnum+&quot;&amp;thinsp;天&quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot;&amp;thinsp;时&quot; + mnum + &quot;&amp;thinsp;分&quot; + snum + &quot;&amp;thinsp;秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 3.6 评论功能&emsp;&emsp;打开来必力官网： https://livere.com按套路注册,点击上方的安装，选择免费的city版本。并点击现在安装，复制其中的uid字段。打开 主题 ，定位到livere_uid，粘贴上刚刚复制的UID。 四、美化配置4.1 隐藏网页底部 Hexo 强力驱动&emsp;&emsp;打开 主题 ,搜索关键字 copyright ，如下: 12# Footer `powered-by` and `theme-info` copyrightcopyright: false 4.2 浏览器恶搞标题&emsp;&emsp;在目录 \Hexo\themes\next\source\js\src 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617&lt;!--浏览器搞笑标题--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/trhx2.png&quot;); document.title = &apos;(*/ω＼*)我藏好了&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/trhx2.png&quot;); document.title = OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 然后在 \Hexo\themes\next\layout\layout.ejs 文件中添加如下代码(我放在最后)： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/FunnyTitle.js&quot;&gt;&lt;/script&gt; 4.3 鼠标点击特效（颜文字）&emsp;&emsp;也是 在目录 \Hexo\themes\next\source\js\src 下新建一个 emoji.js 文件，在里面填写如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 onload = function() &#123; var click_cnt = 0; var $html = document.getElementsByTagName(&quot;html&quot;)[0]; var $body = document.getElementsByTagName(&quot;body&quot;)[0]; $html.onclick = function(e) &#123; var $elem = document.createElement(&quot;b&quot;); $elem.style.color = &quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;;/*点击效果颜色*/ $elem.style.zIndex = 9999; $elem.style.position = &quot;absolute&quot;; $elem.style.select = &quot;none&quot;; var x = e.pageX; var y = e.pageY; $elem.style.left = (x - 10) + &quot;px&quot;; $elem.style.top = (y - 20) + &quot;px&quot;; clearInterval(anim); switch (++click_cnt) &#123; case 1: $elem.innerText = &quot;&lt;(￣3￣)&gt; 表！&quot;; break; case 2: $elem.innerText = &quot;ʅ（´◔౪◔）ʃ&quot;; break; case 3: $elem.innerText = &quot;(๑•́ ₃ •̀๑)&quot;; break; case 4: $elem.innerText = &quot;(๑•̀_•́๑)&quot;; break; case 5: $elem.innerText = &quot;（￣へ￣）&quot;; break; case 6: $elem.innerText = &quot;(╯°口°)╯(┴—┴&quot;; break; case 7: $elem.innerText = &quot;Ψ(￣∀￣)Ψ&quot;; break; case 8: $elem.innerText = &quot;╮(｡&gt;口&lt;｡)╭&quot;; break; case 9: $elem.innerText = &quot;( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃&quot;; break; case 10: $elem.innerText = &quot;(ノへ￣、)&quot;; break; case 11: $elem.innerText = &quot;o(￣ε￣*)&quot;; break; case 12: $elem.innerText = &quot;(ꐦ°᷄д°᷅)&quot;; break; case 13: $elem.innerText = &quot;٩(●´৺`●)وbiu&quot;; break; case 14: $elem.innerText = &quot;(ꐦ°᷄д°᷅)&quot;; break; // case 15: /*此处可以按照上面的格式添加表情*/// break; default: $elem.innerText = &quot;(*/ω＼*)&quot;; click_cnt=0; break; &#125; $elem.style.fontSize = &quot;bold&quot;; var increase = 0; var anim; setTimeout(function() &#123; anim = setInterval(function() &#123; if (++increase == 150) &#123; clearInterval(anim); $body.removeChild($elem); &#125; $elem.style.top = y - 20 - increase + &quot;px&quot;; $elem.style.opacity = (150 - increase) / 120; &#125;, 8); &#125;, 70); $body.appendChild($elem); &#125;; &#125;; 然后 也是 在 \Hexo\themes\next\layout\layout.ejs 文件中添加如下代码(我放在最后)： 12&lt;!-- 页面点击颜文字表情 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/emoji.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;颜文字选取网站：http://www.yanwenzi.com/chihuo/，可以根据自己的喜好增加表情✧٩(ˊωˋ*)و✧ 4.4 更换背景&emsp;&emsp;在 themes/next/source/css/_custom/custom.styl 中添加如下代码： 1234567891011121314151617181920// Custom styles.@media screen and (min-width:1200px) &#123; body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; -webkit-background-size: cover; -o-background-size: cover; -moz-background-size: cover; -ms-background-size: cover; /*这是设置底部文字, 看个人需要修改*/ #footer &gt; div &gt; div &#123; color:#eee; &#125; &#125;&#125; 上面图片链接是我的配置，也可以自己切换成本地图片链接（替换https）：/images/bg.jpg 4.5 背景动态粒子&emsp;&emsp;该功能已经嵌入到新版本 next主题 配置，所以只要使能就行；canvas_nest是一种（很常见）随机线条在鼠标位置凝聚；我的配置选的是canvas_nest: true。 12345678# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false 4.6 加入live2D看板娘1npm install --save hexo-helper-live2d 还需要选择下载自己喜欢的模型，如我的看板娘为live2d-widget-model-koharu ，则 1npm install live2d-widget-model-koharu 其他live2D模型预览查看：https://github.com/xiazeyu/live2d-widget-models 在站点添加以下内容 12345678910111213# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true scriptFrom: local model: use: live2d-widget-model-koharu #模型选择 display: position: right #模型位置 width: 180 #模型宽度 height: 360 #模型高度 mobile: show: false #是否在手机端显示 五、优化配置5.1 解决页面过小问题&emsp;&emsp;文章宽度过小，而两边宽度过大；修改themes\next\source\css_schemes\Pisces_layout.styl &emsp;&emsp;以下是Mayfly大佬的_layout.styl配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131.header &#123; position: relative; margin: 0 auto; //width: $main-desktop; width: 80%; +tablet() &#123; width: auto; &#125; +mobile() &#123; width: auto; &#125;&#125;.header-inner &#123; position: absolute; top: 0; overflow: hidden; padding: 0; width: 240px; background: rgba(255,255,255,0.8); box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +desktop-large() &#123; .container &amp; &#123; width: 240px; &#125; &#125; +tablet() &#123; position: relative; width: auto; border-radius: initial; &#125; +mobile() &#123; position: relative; width: auto; border-radius: initial; &#125;&#125;.main &#123; clearfix(); +tablet() &#123; padding-bottom: 100px; &#125; +mobile() &#123; padding-bottom: 100px; &#125;&#125;.container .main-inner &#123; //width: $main-desktop; width: 80%; +tablet() &#123; width: auto; &#125; +mobile() &#123; width: auto; &#125;&#125;.content-wrap &#123; float: right; box-sizing: border-box; padding: $content-desktop-padding; //width: $content-desktop; width: calc(100% - 260px); background: white; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; +tablet() &#123; width: 100%; padding: 20px; border-radius: initial; &#125; +mobile() &#123; width: 100%; padding: 20px; min-height: auto; border-radius: initial; &#125;&#125;.sidebar &#123; position: static; float: left; margin-top: 300px; width: $sidebar-desktop; background: $body-bg-color; box-shadow: none; +tablet() &#123; display: none; &#125; +mobile() &#123; display: none; &#125;&#125;.sidebar-toggle &#123; display: none; &#125;.footer-inner &#123; //width: $main-desktop; padding-left: 260px; +tablet() &#123; width: auto; padding-left: 0 !important; padding-right: 0 !important; &#125; +mobile() &#123; width: auto; padding-left: 0 !important; padding-right: 0 !important; &#125;&#125;.sidebar-position-right &#123; .header-inner &#123; right: 0; &#125; .content-wrap &#123; float: left; &#125; .sidebar &#123; float: right; &#125; .footer-inner &#123; padding-left: 0; padding-right: 260px; &#125;&#125; 5.2 设置透明背景1.内容板块透明&emsp;&emsp;博客根目录 themes\next\source\css_schemes\Pisces_layout.styl 文件 .content-wrap 标签下 background: white修改为： rgba(255,255,255,0.7);link1232.菜单栏背景&amp;emsp;&amp;emsp;博客根目录 themes\next\source\css\_schemes\Pisces\_layout.styl 文件 .header-inner 标签下 background: white修改为：```background: rgba(255,255,255,0.7); //0.7是透明度 3.站点概况背景&emsp;&emsp;博客根目录 themes\next\source\css_schemes\Pisces_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为： rgba(255,255,255,0.7);link12&amp;emsp;&amp;emsp;然后修改博客根目录 themes\next\source\css\_schemes\Pisces\_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：```background: rgba(255,255,255,0.7); //0.7是透明度 4.按钮背景&emsp;&emsp;博客根目录 themes\next\source\css_common\components\post\post-button.styl 同上修改对应位置为 background: transparen 5.3 博客压缩加速访问在站点的根目录下执行以下命令： 12npm install gulp -gnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在根目录新建 gulpfile.js ，并填入以下内容 123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 注意， 修改上面的各个目录为你的真实目录， **代表0或多个子目录(需要注意一下自己的路径是否正确)&emsp;&emsp;在每次执行完 hexo g 之后，在执行 gulp 命令，就会压缩一次静态文件，例如： 1hexo clean&amp;&amp;hexo g&amp;&amp;gulp&amp;&amp;hexo d 六、写博客6.1 去掉文章目录标题的自动编号&emsp;&emsp;打开 主题 ，找到Table Of Contents,将number失能 6.2 主页文章添加阴影效果&emsp;&emsp;打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678/*主页文章添加阴影效果*/ .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 6.3 主页显示 阅读全文&emsp;&emsp;在文章中使用&lt; !–more–&gt; 手动进行截断 6.4 文章结尾–加入感谢阅读&emsp;&emsp;在\themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body字样之后,post-footer字样之前添加如下代码（post-footer之前两个DIV）： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开 主题配置文件,在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 6.5 文章加密访问&emsp;&emsp;打开themes/next/layout/_partials/head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 123456---title: 如何搭建自己的hexo博客date: 2019-09-27 23:17:10tags: [hexo,next,博客]password: password--- 6.6 文章中插入代码&emsp;&emsp;在 站点 中，找到hightlight: 12345highlight: enable: true line_number: true auto_detect: true tab_replace: 再到 主题 ，找到highlight_theme: normal;注释显示有五种显示主题可用，我的配置为night blue。如何插入则如下图所示： 6.7 代码复制按钮 下载插件clipboard.js； 将下载的clipboard.js文件下的dist文件夹中的文件拖到.\themes\next\source\js\src 文件夹下 也是在.\themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下： 1234567891011121314151617/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = &apos;&apos;; copyHtml += &apos;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&apos;; copyHtml += &apos; &lt;i class=&quot;fa fa-globe&quot;&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;&apos;; copyHtml += &apos;&lt;/button&gt;&apos;; $(&quot;.highlight .code pre&quot;).before(copyHtml); new ClipboardJS(&apos;.btn-copy&apos;, &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode();&#125;(window, document); 在.\themes\next\source\css_custom\custom.styl文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在.\themes\next\layout_layout.swig文件中（我加在最后）： 123&lt;!-- 代码块复制功能 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard-use.js&quot;&gt;&lt;/script&gt; 6.8 博客插入本地图片 把 主页 的post_asset_folder这个选项设置为true2 .在根目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 把图片放进去后，在博文中插入图片如下：1&#123;% asset_img image.jpg This is an image %&#125; 七、总结&emsp;&emsp;以上就是我的hexo配置了，其实我也是个小白，上面都是从一个个大佬采集过来的，但是数量太多且杂，就不一一放对应链接了；网上也有很多搭建hexo的教程，其他的配置可以自己去找。到现在我自己还有些搞不明白的，例如在新建page插入图片这种基操都不会（![]这种makedown语法显示图片貌似已经不能用了），一些别人花里胡哨的特效也搞不出来，如果有大佬能指导一下就好了；如果你是小白，当然还是小白一起共勉啦✧٩(ˊωˋ*)و✧]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil软件配置]]></title>
    <url>%2F2019%2F09%2F17%2FKeil%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、Keil5 背景主题安装&emsp;&emsp;keil5背景主题在网上有很多，直接从网上下载，安装方法如下： 找到安装Keil路径(X:\Keil_v5\UV4); 在UV4目录下的global.prop文件; 将网上下载的.prop文件覆盖原有文件，建议覆盖前备份原文件。 当然也可以细点配制出自己想要的风格（我比较懒），详细的配色方法可以参照这位博主：Keil软件配置 二、Configuration配置&emsp;&emsp;在工具栏中找到小扳手图标或者在菜单栏中打开 Edit-Configuration，大多数功能都在这改。 2.1 缩进和编码设置&emsp;&emsp;如下图设置将编码格式设置为国标，Tab固定缩进为4格 ASCII编码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。 UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。 GBK编码：方式是中文占两个字节，英文占1个字节。 &emsp;&emsp;从上面可知，假如是做嵌入式前端界面时，不要采用我们编程通用的 UTF-8格式，因为它的中文储存字节相对更大。前端界面要储存较多的汉字字库等，因此界面不会采用UTF-8编码格式。 2.2 代码自动补全&emsp;&emsp;进入Text Completion，勾选如下图并填入你需要在输入第几个字符后开启补全提示。 2.3 快捷键的设置&emsp;&emsp;查询某句代码时候，往往会使用ctrl+F跳到Find选项进行查询，如下图所示 Look in:有两个选项：&emsp;&emsp;1)Current Document 只查询当前文档&emsp;&emsp;2)Current Project 查询整个工程Find选项，查询到的时候，是要一直点击next查看下一个的；而Find in Files则是可以在下面列出一个所有能查询到的列表，实际上更常用的是这个（每次都要动下鼠标改成Find in Files）。 因此，在Configuration找到Shortcut Keys选项 1)将Edit：Find快捷键去掉，将Edit：Find in Files快捷键补上ctrl+F；2)顺便加一下注释的快捷键 Edit：Advanced ：Comment Selection和Edit：Advanced ：Uncomment Selection为ctrl+shift+ c|v（个人喜好）；3)顺便将Edit：Advanceed:Go toDefinition of current Word设置为ctrl+d，这样后面进入具体参数位置就ctrl+d或F12都可以用。 2.4 快速浏览 .c文件的函数位置&emsp;&emsp;先在view选项把基本没用的books和Templates功能给隐藏掉。如下图所示 然后进入在Configuration找到Scan funtion names in project files 给关掉 关掉它有什么好处呢？我们可以在Project旁边的｛｝Functions只会显示你在右边的框打开的.c文件，然后 你就可以.c文件打开查看函数，假如没有关掉它的话，它会把项目所有的 .c和.h文件都放出来，到时候别说找函数了，你可能连 .c文件都找不到。 三、Options for Target配置&emsp;&emsp;这里讲下Options for Target配置里面需要注意的内容 3.1 Target选项&emsp;&emsp;Target界面主要分为两块 3.1.1 FPU浮点处理器&emsp;&emsp;基于Cortex-m4（例如：STM32F407）最大的特色就是加入了一个FPU浮点处理器，能支持DSP运算。更高版本的甚至能够支持double类型处理（例如：STMH7）。 &emsp;&emsp;如果只是写裸机程序的话，就无需在意；&emsp;&emsp;假如是写实时操作系统（例如UCOSIII）需要注意的是：UCOS III官方的移植版本竟然不支持FPU浮点运算；如果在MDK的设置选项中,使能FPU， 运行的时候会出现奇怪的错误，有时候直接跑飞（例如：程序如果进行打印浮点型数据就会进入硬件错误；甚至有时候程序量大的时候，一编译，你根本不知道bug在哪？而且还会报错）。逐步调试会发现：只要运行打印浮点数就会程序跳转到硬件fault；1）可能是字节对齐问题，修改字节对齐即可解决问题；2）或者你移植的RTOS本来就不支持，需要修改底层配置函数；解决方法：ucosii中调用Printf打印浮点型数据就进入硬件错误，STM32F4&emsp;&emsp;个人建议：移植UcosIII的时候，程序运行暂时先不启用FPU，等到程序跑得稳定、需要优化的时候，再启用FPU，明确不是原有程序版本带有的bug。 3.1.2 IROM&emsp;&emsp;如果不涉及bootloader在线升级的情况下，采用一般的例程的配置IROM即可；倘若涉及到，可详细看这篇博文：STM32开发 3.2 Output Browse Information选项是可以查看函数具体内容和位置；但是这里有点经验，就是当你编译类似stm32H7系列那种大容量RAM的芯片的时候，往往它自带的库也是很大，里面有很多函数要编译；当你编译工程的时候，那速度你会怀疑人生，这个时候你可以关闭这个选项，可以大大减少你需要的编译时间，但是缺点是不能跳转函数，可以用ctrl+F替代找到你要的函数位置。 Create HEX File选项，是生成hex文件&emsp;&emsp;烧录程序方式分为两种：1） .bin文件进行烧录2） .hex文件进行烧录我们常用的串口、J-link（SW模式，直接在项目工程）烧录程序进芯片，均是采用hex文件；.bin文件只会在脱机烧录和在线升级的时候才会用到。 更多相关.bin文件和.hex文件知识，可详细看这篇博文的bootloader章节：STM32开发 3.3 User &emsp;&emsp;这里是运行keil脚本的地方，是要在编译前调用执行脚本，还是编译后调用执行脚本。如 *3.2 Output *所示，Output选项中只有生成.hex文件，没有生成.bin文件的选项；一般情况下，就有人在 编译后选项 里调用keil自带的脚本fromelf.exe，用于生成.bin文件。&emsp;&emsp;由于每个人的电脑的Keil安装路径不同，因此别人安装的脚本位置也就不同；有时候你编译别人的代码，会出现非代码的Error：显示你找不到对应路径的fromelf.exe；这个就是找(错)不到脚本位置而报错，这个时候可以将上图红色地方选项，勾选给取消掉就可以用了，当需要对应的bin文件再进行更改具体路径即可。 3.4 C/C++ 3.4.1 芯片库选择Stm32芯片型号移植的时候，最重要的就是这个位置；在这里举例一下F10x系列 &emsp;&emsp;至于要使用哪个宏，则需要根据具体的芯片来进行选择。如果是STM32F105xx和STM32F107xx，是Connectivity Line Devices，则宏定义选择的是STM32F10X_CL；如果是别的型号，则根据FLASH的容量来进行选择。可能文字写的有点不太清楚，还是以表格来说明： &emsp;&emsp;宏定义更换的时候，也好同时把启动文件给换掉，例如：startup_stm32f10x_hd.s修改为startup_stm32f10x_md.sPs：其实到这里基本移植完了，不过有时候会出现程序跑的非常慢，有些工程在汇编底层启动文件调用Systeminit();再跳转到main()，有些则无配置时钟树，这个时候在系统初始化时调用 SystemInit();，后面就正常了 3.4.2 优化等级&emsp;&emsp;在上图所示，中间有一个Optimization选项，是对程序优化的等级；一般我们调试的时候，采用最低的Level 0，因为如果我们进行仿真调试，优化等级太高，程序无法跳转运行到设置的断点；当程序调试稳定后，再根据需求提高其代码优化等级即可。 四、技巧用法&emsp;&emsp;这里讲一些自己在用的实用小技巧 4.1 仿真精确测量代码运行时间&emsp;&emsp;为什么需要精确测量代码运行时间？其实往往之所以需要其精确的运行时间，主要分为两种情况： 上电初始化，某些芯片模块本身的器件性质，导致MCU不能上电立马 初始化(通信进行软件配置)该芯片；根据初始化函数放的位置，MCU初始化的指令执行够快，上电快速与其芯片立马通讯后，导致会出现不可预知且随机的bug；并且这种bug是隐性的，如果你其他的功能所需的初始化时间够长，这个bug就会(偶然)消失掉。因此需要测出时间，并在该芯片初始化通讯前增加延时(死循环) 需要知道整个程序循环一遍需要多长时间。往往串口通讯、开关扫描、AD采样等的数据处理往往是通过 轮询 的方式实现的。例如，AD采样频率是 960次/秒 ，如果你的程序的循环次数 达不到至少(冗余) 1000次/秒 ，那么就算是使用 ADC采样（外部）中断 及时获取到数据，但是由于程序循环速度太慢，AD采样数据无法及时进行处理换算，实际上 AD采样频率 &lt; 程序循环次数 &lt; 960次/秒 。因此 程序循环所需时间大小，也决定了轮询处理响应速度的慢快。 Ps：获取数据的方式有两种：轮询 和 中断 。一般情况下，最好是使用中断方式，能够及时获取到数据；采用轮询方式来获取数据，当没有数据来临时，也会进入轮询。当你的程序量比较少的时候，你的程序循环速度会很快，这样的话，轮询将会占用较多的CPU(内存)资源，而中断如果不触发，则不会进入，单位时间内程序循环将会相对来讲会优化一些。 &emsp;&emsp;实际上有很多种方法可以实现测量运行时间 4.1.1 采用Keil仿真的 Trace 功能&emsp;&emsp;首先要先配置好仿真的时钟：在Target进入Debug，然后设置成J-link（或者ST-link，大同小异），进入setting，再选择Trace选项 SW模式：先勾选Enable，调成对应时钟（例：72MHz），再使能Autodetect max SWO ClkJTAG模式（不常用）：设置时钟，然后不勾选Enable（JTAG不支持Trace，会报错，容易出现SW切换JTAG时忘记关掉Trace） 仿真的时候找下有个时间窗口 上面两个是复位“t1”和“t2”的，下面3个是选择在状态栏上显示哪个时间。 “t0”表示程序开始运行到现在的时间，是不能复位的。另外两个可以随便复位，就可以用来测具体某一个函数或某一行程序的运行时间。 &emsp;&emsp;具体操作为：在要测试的代码前加一个断点，当程序运行到目标行时会停下，然后复位“t1”或“t2”，并在下一行代码前加断点，然后继续运行程序，程序会停在下一行代码前，这个时候“t1”的值就是目标行程序的运行时间。 Ps：Keil仿真 全速运行时 观察窗口变量没刷新；解决方法：在仿真时点击工具栏里的view选择下面的periodict window update，勾选完后数据开始动态更新。 Ps：Cortex-M0不支持Trace功能，因为是ARM V6结构，比较旧，所以无论你用J-link，还是ST-Link，都不能用到Trace。Keil会提示TRACE HW not present 4.1.2 采用定时器计时&emsp;&emsp;配置好一个定时器，具体计算配置操作可以看STM32开发思路：获取 进入程序段的当前时间，退出程序段后再获取当前时间，两个时间之差就是其运行时间(* 定时器计时基数)。 4.2 程序跑飞跳转&emsp;&emsp;有时候你会在工程看到这段汇编的函数. 123456789__asm void wait()&#123; BX lr&#125;void HardFault_Handler(void)&#123; /* Go to infinite loop when Hard Fault exception occurs */ wait();&#125; &emsp;&emsp;HardFault_Handler栈溢出检查机制，适用于所有CM3芯片，造成主栈(MSP)溢出的原因有很多，如过多的定义局部变量，递归调用，中断嵌套等都有可能会导致主栈溢出，stm32不具备MPU，没有对内存进行保护的硬件机制，而软件检测栈溢出又有其局限性。 STM32出现HardFault_Handler故障的原因主要有两个方面： 内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。 堆栈溢出。增加堆栈的大小。大多数是因为中断嵌套寄存器均是32位，且STM32是小端模式(参考Cortex-M3权威) 1)出现问题时排查的方法：DEBUG，下断点单步看程序停在哪2)另一种方法：默认的HardFault_Handler处理方法为：内部是一个 汇编 或者 C语言 形式的死循环；将它改成如上面代码的 BX LR直接返回的形式。然后在这条语句打个断点，一旦在断点中停下来，说明出错了，然后再返回，就可以找到程序跑飞出错的位置的语句在哪。 4.3 自动生成版本号（编译时间和编译日期）&emsp;&emsp;经常都需要手动添加版本号或者生成时间会很繁琐。这个时候，C语言中的两个宏__DATE__和__TIME__可以帮到我们。__DATE__用于获取系统日期，而__TIME__用于获取系统时间，我们可以根据该两个宏获取到的信息将其保存于程序变量中，在程序运行过程中直接调用。 我们在程序中可以按以下所示使用： 1234const unsigned char cRevisionDate[12] = __DATE__;const unsigned char cRevisionTime[16] = __TIME__;printf("Rev Info: %s %s\r\n", cRevisionDate, cRevisionTime); 运行结果如下所示： 1Rev Info: Sep 8 2018 17 51 26 更复杂的使用方法可以看这篇：Keil版本号生成 4.4 仿真动态显示&emsp;&emsp;点击仿真后，如果Watch窗口数据不能动态显示，可在仿真状态下点击tool栏的view，观察periodict window update是否勾选，确保勾选即可。此时数据动态更新。Ps：退出仿真状态下，工具栏的view没有periodict window update选项。 4.5 如何上传github&emsp;&emsp;首先新建一个批处理，用于清除掉keil工程的编译文件： 12345678910111213141516171819202122232425262728293031323334353637::删除Keil编译产生的一些垃圾文件::删除Code Warrior编译产生的一些垃圾文件del *.bak /sdel *.ddk /sdel *.edk /sdel *.lst /sdel *.lnp /sdel *.mpf /sdel *.mpj /sdel *.obj /sdel *.omf /s::del *.opt /s ::不允许删除JTAG的设置del *.plg /sdel *.rpt /sdel *.tmp /sdel *.__i /sdel *.crf /sdel *.o /sdel *.d /sdel *.axf /sdel *.tra /sdel *.dep /s del JLinkLog.txt /sdel *.iex /sdel *.htm /sdel *.sct /sdel *.map /sdel *._2i /sdel *.L2P /sdel *.FED /sdel *.elf /sdel *.args /sdel *.mk /sdel *.local /sexit &emsp;&emsp;具体的批处理操作解读，可以看另外一篇文章Window的简易bat处理 4.6 搭配推荐&emsp;&emsp;推荐一些自己在用的实用搭配 4.6.1 Astyle&emsp;&emsp;Astyle是keil的一个插件，关于Astyle看另外一篇博客：Keil格式化工具_Astyle 4.6.2 Snipatse&emsp;&emsp;Snipatse是一个超级方便的截图软件 4.6.3 Compare&emsp;&emsp;Compare是一个比较代码的软件，特别好用。你可以比较现在版本和之前版本的区别；或者是你的版本和别人的版本，能很快找到差别]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>keil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)Keil代码格式化工具_Astyle]]></title>
    <url>%2F2019%2F09%2F15%2FKeil%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7-Astyle%2F</url>
    <content type="text"><![CDATA[一、前言&emsp;&emsp;在用Keil5编写程序的时候，很多情况要参考别人写的程序来完成开发，在这过程中，看到了很多代码编写风格不一、代码编写不规范的情况。有时候看的头都大了，在一次偶然的情况下，认识了 Astyle 这一代码格式工具，就根据帖子上的教程配置在了 Keil 上，后面在使用的过程中，发现这款插件的高效性，所以特意拿出来分享 二、Astyle2.1 Astyle 官网&emsp;&emsp;Astyle 官网链接：http://astyle.sourceforge.net/ 2.2 Astyle 介绍&emsp;&emsp;我直接搬官网两句话来介绍，官网的介绍已经十分详细了，文档等信息都可以在官网上获取到。&emsp;&emsp;Artistic Style is a source code indenter, formatter, and beautifier for the C, C++, C++/CLI, Objective-C, C# and Java programming languages.&emsp;&emsp;Artistic Style是 C, C++, C++/CLI, Objective-C, C# 和 Java 等编程语言的代码缩进器、格式化器和美化器。&emsp;&emsp;Artistic Style是适用 C, C++, C++/CLI, Objective-C, C# 和 Java 等编程语言的免费、快速和小型自动格式化软件。 2.3 Astyle 下载&emsp;&emsp;进入官网,在官网下方点击 Download 进入下载页面. &emsp;&emsp;下载页面直接下载最新版本即可. &emsp;&emsp;等待弹出下载后保存到你的电脑. 2.4 Astyle 保存&emsp;&emsp;Astyle 下载完后，根据自己的需求和方便，解压并保存好就可以了。这里我是直接丢在了 keil5 的根目录下。 三、Keil5 增加 Astyle 插件3.1 Keil5 使用 Astyle 效果&emsp;&emsp;使用前: &emsp;&emsp;使用后: 3.2 Keil5 配置 Astyle&emsp;&emsp;打开 Keil5 ,然后在菜单栏中找到 Tools-Customize Tools Menu… &emsp;&emsp;打开后,增加两个内容,分别命名为: Astyle All FilesAstyle Current File &emsp;&emsp;命名可以自己需求，不一定和我一样。&emsp;&emsp;然后位置都选择你解压 Astyle 文件中 bin 文件夹下的 Astyle.exe&emsp;&emsp;在 Arguments 参数中对应填入:Astyle All Files -n "$E.c" "$E.h"Astyle Current File -n !E &emsp;&emsp;如图: &emsp;&emsp;设置好后我们点 OK 应用。 3.3 Keil5 使用 Astyle 格式代码&emsp;&emsp;配置好后，我们可以在Tools-Customize Tools Menu...中看到我们新增加的两个自定义工具。 &emsp;&emsp;格式化整个工程的 .c 与 .h 文件就选择 Astyle All Files。&emsp;&emsp;格式化当前文件则选择 Astyle Current File.&emsp;&emsp;格式化可以在 keil 的输出窗口看到格式情况。 3.4 关于配置参数上的解释我们在 keil5 中填入了两行参数值： Astyle All Files-n "$E.c" "$E.h" Astyle Current File-n !E-n，格式化文件时，新的缩进的文件将保留原始文件，创建原始文件的副本，并在原始文件名后附加 .orig ，可以通过 -n 来取消设置备份副本。 "$E.c" "$E.h",$E是 Keil 的指令，表示工程内的全部文件，加上 .c 与 .h ，表示工程内 .c 文件与 .h 文件，Astyle 也会只格式化工程里的全部的 .c 与 .h 文件。 !E,!E 是 Keil 的指令，表示当前文件, Astyle 在操作时就只格式化当前的文件。 四、Astyle 的其他配置4.1 括号格式化风格 &emsp;&emsp;具体的可以参照 Astyle文档,不过多叙述。 4.1.1 allman 风格--style=allman / --style=bsd / --style=break / -A1 Allman style uses broken braces. 12345678910int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; 4.1.2 java 风格--style=java / --style=attach / -A2 Java style uses attached braces. 1234567int Foo(bool isBar) &#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; 4.1.3 kr 风格--style=kr / --style=k&r / --style=k/r / -A3 Kernighan &amp; Ritchie style uses linux braces. Opening braces are broken from namespaces, classes, and function definitions. The braces are attached to everything else, including arrays, structs, enums, and statements within a function. Using the k&amp;r option may cause problems because of the &amp;. This can be resolved by enclosing the k&amp;r in quotes (e.g. –style=”k&amp;r”) or by using one of the alternates –style=kr or –style=k/r. 12345678int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; 4.1.4 其他&emsp;&emsp;还有很多的风格,可以在对应的文档看，总共有15种风格任君挑选，如 python、google、linux 风格等。&emsp;&emsp;因为我用 Keil 开发是 C 语言，所有我选了 A1 的风格，所以相应的在 Keil 上我就配置了: -n -A1 "$E.c" "$E.h" &emsp;&emsp;不生成副本，用 A1 风格，来格式化整个工程的 .c 与 .h 文件。 4.2 格式化缩进长度4.2.1 空格缩进&emsp;&emsp;这里我就不在截图了，具体的可以看文档，默认我们不配置缩进选项的话，默认是4个空格，如果你想要更改缩进的空格长度，你可以通过:--indent=spaces / --indent=spaces=# / -s# &emsp;&emsp;-s4，就是缩进 4 个空格，那么相应的，要改缩进 x 个空格就更改 -sx 就可以了. 4.2.2 制表符缩进&emsp;&emsp;同上，--indent=tab / --indent=tab=# / -t / -t# &emsp;&emsp;-t4，就是缩进 4 个制表符，那么相应的，要改缩进 x 个制表符就更改-tx就可以了。 4.2.3 其他&emsp;&emsp;还有另外两种缩进方式，我觉得很少使用，就不列举了，有兴趣了解同样的访问官方文档即可。 4.3 其他&emsp;&emsp;还有许多格式化的形式，我也不多加叙述，例如缩进’switch’块、’case’块、注释、’class’和’struct’块、预处理程序缩进等许许多多的格式化方式，官方文档列举的说明十分详细，针对自己需要的、想要的格式化需求，针对性的在文档中寻找并利用，制作一个自己的高效率工具。 五、个人心得(非转)&emsp;&emsp;注意格式化之前需要保存，否则不会进行格式化；Astyle Current File是格式化当前文件，Astyle All File不是格式化整一个工程，而是格式化当前文件所在的文件夹中所有.c和.h文件；倘如你写的驱动或者实现功能.c文件是封装成独立文件夹时，需要多次单独处理。&emsp;&emsp;给两个处理模板： Astyle Current File：-n !E –style=ansi -s4 -K -W -p -H -xC80 -S -m0 -M40 -c Astyle All File：-n ”$E.c” “$E.h” –style=ansi -s4 -K -W -p -H -xC80 -S -m0 -c 本文转自来源：贴吧偶遇，分享博客制作心得的路人，Keil5代码格式化工具]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>keil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F12%2FHello-World%2F</url>
    <content type="text"><![CDATA[放弃不难，但坚持一定很酷]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
