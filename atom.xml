<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>道简顿悟，法深渐修</title>
  
  <subtitle>It&#39;s not hard to give up, but it must be cool to stick to it.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shatang.github.io/"/>
  <updated>2020-08-12T14:32:53.692Z</updated>
  <id>http://shatang.github.io/</id>
  
  <author>
    <name>Shatang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IAP升级 &amp; Bootloader制作</title>
    <link href="http://shatang.github.io/2020/08/12/IAP%E5%8D%87%E7%BA%A7-Bootloader%E5%88%B6%E4%BD%9C/"/>
    <id>http://shatang.github.io/2020/08/12/IAP升级-Bootloader制作/</id>
    <published>2020-08-12T14:31:32.000Z</published>
    <updated>2020-08-12T14:32:53.692Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇主要讲基于Stm32的IAP升级(即Bootloader升级)。主要是讲解Bootloader制作思路(该思路不只是用于该系列的芯片)。此篇文章内容较多，需要慢慢消化，部分内容可以先跳着看。</p><a id="more"></a><h1 id="一、IAP-amp-Bootloader"><a href="#一、IAP-amp-Bootloader" class="headerlink" title="一、IAP &amp; Bootloader"></a>一、IAP &amp; Bootloader</h1><h2 id="1-1-IAP-amp-ISP"><a href="#1-1-IAP-amp-ISP" class="headerlink" title="1.1 IAP &amp; ISP"></a>1.1 IAP &amp; ISP</h2><ul><li>ISP：In System Programing，在系统编程</li><li>IAP：In applicating Programing，在应用编程</li></ul><p>&emsp;&emsp;ISP是指可以在板级上进行编程，也就是不用拆芯片下来，写的是整个程序，一般是通过ISP接口线来写。</p><p>&emsp;&emsp;IAP虽然同样也是在板级上进行编程，但是是自已对自已进行编程，在应用中进行编程，也即可以只是更改某一部分而不影响系统的其它部分，另外接口程序是自已写的，这样可以进行远程升级而不影响应用。</p><p>&emsp;&emsp;ISP即是我们平常编程下载的方法，每次烧录程序都要把MCU的Flash全部都擦除一遍；IAP下载，则是擦除部分Flash(APP)，另外部分未擦除部分(Bootloader)可以根据自己祖传留下的代码搞一些骚操作，例如把自己的活(擦写存储APP代码的Flash)搞完就跑去执行被擦除(刷新)过Flash程序(APP)。常见的方法就是在Bootloader擦除APP程序，擦除完再跳转到新的APP程序继续运行，实现不需要烧录线进行ISP下载就能升级。</p><h2 id="1-2-Bootloader"><a href="#1-2-Bootloader" class="headerlink" title="1.2 Bootloader"></a>1.2 Bootloader</h2><p>&emsp;&emsp;源自linux上的BootLoader的概念，在linux上，BootLoader是首先执行的程序，BootLoader启动之后初始化CPU、RAM、Flash等设备，然后从Flash中读取Linux程序数据到RAM中去，最后跳转到RAM中Linux的起始地址中去启动Linux系统。除了从Flash中读取系统启动之外，BootLoader还能通过网络NFS协议从服务器上读取Linux并启动。BootLoader还能够更新Linux内核、配置Linux启动信息、测试系统等等。</p><p>&emsp;&emsp;在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像Window自带BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。</p><hr><p>&emsp;&emsp;简单理解的话，Bootloader就是我们常见的计算机开机操作，而我们则是想要打开自己想用的软件Keil(APP)。我们没办法秒开机直接运行Keil(APP)，需要等待一段时间；计算机需要做底层软、硬件的配置(Bootloader)。</p><p>&emsp;&emsp;我们要做的STM32的BootLoader也是类似的工作原理，但是没有Linux系统的BootLoader功能那么强大。我们要做的STM32的BootLoader只有两个主要目的：</p><ol><li>跳转到应用程序并执行；</li><li>更新应用程序(App)；</li></ol><p><strong><font color="red">Ps：</font></strong> 因此，下载新(App)程序后并不擦除bootLoader程序，下次启动依然先运行BootLoader程序，可以选择性更新或者不更新程序，所以STM32的BootLoader作用往往就是用来管理单片机程序的更新。</p><h2 id="1-3-Bootloader-amp-App"><a href="#1-3-Bootloader-amp-App" class="headerlink" title="1.3 Bootloader &amp; App"></a>1.3 Bootloader &amp; App</h2><p>&emsp;&emsp;其实IAP升级，就需要将原有APP，分割成Bootloader和新APP。Bootloader负责检查更新APP，新APP则是继续执行原有APP功能，但是在MCU的Flash上，会产生地址分块(Bootloader+App)。</p><p>Bootloader里面主要是</p><ol><li>设置规划bootloader和app的空间</li><li>接收编译好的app的bin文件，写入flash</li><li>实现跳转至APP</li></ol><p>App里面主要修改的地方是</p><ol><li>ROM起始地址和分配的空间大小</li><li>中断向量表 重定向</li><li>生成bin文件</li></ol><hr><p><strong><font color="red">Ps：</font></strong><br>由于Bootloader可以对接收bin文件方法有多种多样，因此常见的升级方式为: </p><ul><li>串口升级(私有协议或者X-Modem、Y-Modem) </li><li>USB升级(DFU)</li><li>U盘升级(OTG) </li><li>网络升级 </li><li>无线升级(OTA,例如蓝牙)</li></ul><h1 id="二、IAP升级的预备知识"><a href="#二、IAP升级的预备知识" class="headerlink" title="二、IAP升级的预备知识"></a>二、IAP升级的预备知识</h1><h2 id="2-1-复位序列"><a href="#2-1-复位序列" class="headerlink" title="2.1 复位序列"></a>2.1 复位序列</h2><p>&emsp;&emsp;M3单片机复位后，从0x00000000取栈指针（SP）， 从0x00000004取复位向量（PC），<strong>有了栈指针和复位向量后，单片机就按照正常流程运行了</strong>；在BootLoader里面，我们更新完程序后需要做的步骤之一就是设置栈指针，跳转复位向量。</p><h3 id="2-1-1-栈指针"><a href="#2-1-1-栈指针" class="headerlink" title="2.1.1 栈指针"></a>2.1.1 栈指针</h3><p>&emsp;&emsp;CPU 按照 MSP 指针，到ROM存取地址或数据。</p><h3 id="2-1-2-pc指针"><a href="#2-1-2-pc指针" class="headerlink" title="2.1.2 pc指针"></a>2.1.2 pc指针</h3><p>&emsp;&emsp;CPU 按照 PC 指针，到ROM去取指令代码。PC，是 program calculate 的缩写,即程序计数器；</p><p><strong><font color="red">Ps：</font></strong> 当前PC在ROM的位置就是程序执行到的位置；在涉及到操作系统(ucOS)原理的时候，PC指针就扮演着十分重要的角色。</p><p>&emsp;&emsp;<strong>有了栈指针和复位向量后，单片机就能够运行了！</strong></p><h2 id="2-2-重定位中断向量表"><a href="#2-2-重定位中断向量表" class="headerlink" title="2.2 重定位中断向量表"></a>2.2 重定位中断向量表</h2><p>&emsp;&emsp;中断向量表里面到底是什么，它放在哪里？到底有什么用？</p><ol><li>中断向量表实际上就是存放在 code区 0地址开始的一个数组，数组的成员为4个字节，而且这些数组在启动文件的时候已经初始化好，既然初始化好，那里面存放的是什么？</li><li>STM32根据内核和外设中断优先级，统一标号，标号越小，优先级越大。然后把内核和外设的中断服务函数的地址放到这个数组里面，数组的下标跟中断的优先级对应，我们也把这个中断的编号叫做中断向量。</li><li>在启动文件执行的时候，内核和每个外设的中断服务函数的地址都是已经确定好的，地址就存放在中断向量表中，而且在启动文件里面已经写好了中断服务函数，只是这些中断服务函数为空，而且带[weak]弱定义，那么我们就需要在C文件里面重新实现这个中断服务函数，用户写这个中断服务函数的时候，函数名必须跟启动文件里面写的中断函数名对应，因为函数名对应的就是中断服务函数的地址，如果名字搞错了，那么在响应中断的时候，就默认响应启动文件里面预先写好的空的中断服务函数，而且是一个死循环。</li></ol><hr><p>那内核是是如何响应中断的呢？</p><p>&emsp;&emsp;当中断来临的时候，首先取向量，每个中断的中断向量不一样，然后根据向量查询中断向量表，根据表里面的地址找到中断服务函数，从而实现整个中断的响应过程。</p><hr><p>如果你真正理解了什么是中断向量表</p><ol><li>那么你在C文件里面写中断服务函数的时候就知道为什么要这样写中断服务函数的名字，而且你也可以修改启动文件里面的中断向量表里面的地址（即修改函数名字即可）。</li><li>在后面移植ucosiii等os的时候，也知道PendSV要怎么移植和修改</li></ol><hr><p>&emsp;&emsp;BootLoader是一个完整的程序，更新用的App也是一个完整的程序。一个嵌入式程序都包含中断向量表，用于响应中断；两者当然无法共用一套中断处理(用法可能不同)，因此需要两个中断向量表，第一个中断向量表可以使用默认，而另外一个中断向量表则需要重定位(映射)。</p><h2 id="2-3-ROM的起始地址"><a href="#2-3-ROM的起始地址" class="headerlink" title="2.3 ROM的起始地址"></a>2.3 ROM的起始地址</h2><p>&emsp;&emsp;STM32的Flash在MDK里被设置为起始地址 0x08000000 ，也就是说如果上面的中断向量表要重定义向到Flash上，是以基地址 0x08000000 计算偏移的(也可以重定向到RAM)；程序所有函数的地址默认都在以0x08000000为基地址的一段ROM里面了。</p><hr><h3 id="2-3-1-奇怪的程序起始地址0x08000000"><a href="#2-3-1-奇怪的程序起始地址0x08000000" class="headerlink" title="2.3.1 奇怪的程序起始地址0x08000000"></a>2.3.1 奇怪的程序起始地址0x08000000</h3><p>&emsp;&emsp;STM32的Flash在MDK里被设置为起始地址0x0800 0000，而CM3手册规定芯片复位时要从0x0000 0000地址开始取出中断向量，那STM32怎么样执行代码呢？是地址重映射？或者在0x0000 0000里有对应有实际存储器？</p><p>&emsp;&emsp;不是在0x00000000是因为STM32的重映射技术（不符合Cortex-M3的设计，有点搞另类的感觉）；仔细阅读手册，发现这件事是因为STM32设计的Flash起始地址是在0x0800 0000位置开始的。全部代码都只能从这里开始存储。详见STM32 referenc manual手册第54页。</p><p>那既然从这里才能存储代码，就必须在MDK里设置Flash地址为0x0800 0000，下面是MDK设置页面，这个应该都看到过。</p><p>&emsp;&emsp;这样就还有一个问题，理论上，CM3中规定上电后CPU是从0地址开始执行，但是这里中断向量表却被烧写在0x0800 0000地址里，那启动时不就找不到中断向量表了？既然CM3定下的规矩是从0地址启动，SMT32当然不能破坏ARM定下的“规矩”，所以它做了一个启动映射的过程，就是和芯片上总能见到的BOOT0和BOOT1有关了，当选择从主Flash启动模式后，芯片一上电，Flash的0x0800 0000地址被映射到0地址处，不影响CM3内核的读取，所以这时的CM3既可以在0地址处访问中断向量表，也可以在0x0800 0000地址处访问中断向量表，而代码还是在0x0800 0000地址处存储的。这就是最难理解的地方，其实，这是基本上所有ARM芯片采用的启动映射方法。ARM7，ARM9没有内部Flash的通常都是这样做的。这个过程出自STM32 referenc manual手册，里面是有说明的。</p><h3 id="2-3-2映射中断向量表"><a href="#2-3-2映射中断向量表" class="headerlink" title="2.3.2映射中断向量表"></a>2.3.2映射中断向量表</h3><p>&emsp;&emsp;还要注意，<strong>这个中断向量表是可以在程序中再次被映射的</strong>。控制它的就是CM3已经规定的 NVIC寄存器 <code>SCB->VTOR</code> 。在STM32库中给出的启动代码里，startup_stm32f10x_hd.s文件里，第146行，是上电后读取中断向量表中的复位中断位置，并执行复位中断处理代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0               </span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意复位后第一个被执行的是SystemInit代码，这个代码在库目录下的 system_stm32f10x.c 文件里，它初始化了时钟，NVIC等一系列操作；这里摘要与中断向量有关的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VECT_TAB_SRAM</span></span><br><span class="line">  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal SRAM. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal FLASH. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出中断向量重映射是一个选择性编译，通常宏定义 <code>VECT_TAB_SRAM</code> 都没有被定义，所以这里执行结束后， <code>SCB->VTOR</code> 就是 FLASH_BASE 了，值为 0x08000000 。以后CM3再取中断向量里，就会根据 <code>SCB->VTOR</code> 的设置，从这里取向量执行了。中断向量自此终于转正。</p><p><strong><font color="red">Ps：</font></strong> 这时连__main函数都还没进，中断向量的重映射位置还是够早的。</p><h2 id="2-4-hex文件和bin文件"><a href="#2-4-hex文件和bin文件" class="headerlink" title="2.4 hex文件和bin文件"></a>2.4 hex文件和bin文件</h2><p>&emsp;&emsp;Bootloader程序升级，往往是采用写入bin文件；那hex文件和bin文件有什么关系呢？</p><ul><li><p><strong>hex文件</strong></p><ul><li>hex文件是以ASCII文本形式保存编译后的二进制文件信息。Hex文件使用ASCII文本的形式保存Bin文件的内容和Bin文件的一些配置信息。hex文件可以由下载器（比如jlink）烧写到MCU的ROM中。</li><li>平时用J-LINK或者串口ISP下载程序，都是下载hex文件的;因为hex文件包含地址信息，下载程序的时候知道程序下载到ROM的哪个区域。反过来讲，hex文件是不能直接写进ROM的，一边写需要一边转换(解码出地址信息，将对应内容写入ROM)。</li></ul></li><li><p><strong>bin文件</strong></p><ul><li>Bin文件是MCU固件烧写的最终形式，也就是说MCU的ROM中烧写的内容完全就是Bin文件的内容。</li></ul></li><li><p>hex &amp; bin 区别</p><ul><li>Hex文件有更好的可读性，最重要的是hex文件能够保证固件在保存与传输时的完整性。因此hex文件更适用于保存与传输。</li><li>Bin文件是纯二进制文件，内部只包含程序编译后的机器码和变量数据。当文件损坏时，我们也无法知道文件已损坏。不过Bin文件作为固件的最终形式，在使用串口下载程序或者远程升级时，是不可替代的。</li></ul></li></ul><hr><blockquote><p><strong>bin文件生成</strong></p></blockquote><p>&emsp;&emsp;默认情况下编译后生成的是hex文件，没有生成bin文件。keil的Bin文件生成方式有很多种，可以另外下载一个hex2bin工具，然后用Keil脚本执行；这里，介绍使用Keil自带的工具fromelf.exe。在Keil的安装目录下，例如：<code>E:\Keil\ARM\ARMCC\bin\fromelf.exe</code></p><ul><li><p>第一种方式：设置绝对路径(不建议这样做，别人用你工程需要再次修改路径)</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">MDK516</span>\<span class="title">ARM</span>\<span class="title">ARMCC</span>\<span class="title">bin</span>\<span class="title">fromelf.exe</span>" --<span class="title">bin</span> -<span class="title">o</span> ./<span class="title">obj</span>/<span class="title">test_app.bin</span> ./<span class="title">obj</span>/<span class="title">test_app.axf</span></span></span><br></pre></td></tr></table></figure></li><li><p>第二种方式：相对路径，直接复制下面的路径就能直接使用</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$K\ARM\ARMCC\bin\fromelf.exe --bin --output=@L.bin !L</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;bin文件生成在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下你可看到一个test1.bin（名字是根据你的hex文件名字一样）。</p><p>希望生成.bin文件输出在当前工程下的指定目录，比如Bin文件夹，可如下操作：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$K\ARM\ARMCC\bin\fromelf.exe --bin --output=Bin\@L.bin !L</span><br></pre></td></tr></table></figure><p>生成的文件也是在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下，可看到一个新生成的Bin文件夹，里面是test1.bin。</p><h1 id="三、IAP升级的具体实现"><a href="#三、IAP升级的具体实现" class="headerlink" title="三、IAP升级的具体实现"></a>三、IAP升级的具体实现</h1><p>&emsp;&emsp;这次的例子采用的是串口X-modem协议进行IAP升级。</p><h2 id="3-1-Bootloader程序的编写"><a href="#3-1-Bootloader程序的编写" class="headerlink" title="3.1 Bootloader程序的编写"></a>3.1 Bootloader程序的编写</h2><p>程序编写主要几件事：</p><ol><li>编写串口X-modem协议，接收bin文件</li><li>把串口接收的bin文件缓存块，写入Stm32的flash指定地址</li><li>通过工程的 .map文件，大致规划好Bootloader和APP的Flash储存块地址(这肯定不能重叠了)</li><li>Bootloader执行程序能跳转到APP去</li></ol><p>&emsp;&emsp;对X-modem协议进一步了解的，可以看这篇博文： ==1==<a href></a></p><p>&emsp;&emsp;对Stm32的flash如何写数据，可以看这篇博文： ==1==<a href></a></p><p>&emsp;&emsp;放出源码：<a href></a></p><p>注意看完 .map文件后，在编译器限制一下Bootloader程序的大小。</p><h2 id="3-2-APP程序编写要求须知"><a href="#3-2-APP程序编写要求须知" class="headerlink" title="3.2 APP程序编写要求须知"></a>3.2 APP程序编写要求须知</h2><h3 id="3-2-1-编译工具链"><a href="#3-2-1-编译工具链" class="headerlink" title="3.2.1 编译工具链"></a>3.2.1 编译工具链</h3><p>&emsp;&emsp;STM32中ARM系列编译工具链的编译宏选择（__CC_ARM、__ICCARM__、__GNUC__、__TASKING__）。这里简单介绍一下。</p><ol><li><p>在 core_cm3.h 文件中，有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined ( __CC_ARM   )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM            __asm        <span class="comment">/*!&lt; asm keyword for ARM Compiler        */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE         __inline     <span class="comment">/*!&lt; inline keyword for ARM Compiler     */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined ( __ICCARM__ )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM           __asm         <span class="comment">/*!&lt; asm keyword for IAR Compiler        */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE        inline        <span class="comment">/*!&lt; inline keyword for IAR Compiler. Only avaiable in High optimization mode! */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined   (  __GNUC__  )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM            __asm        <span class="comment">/*!&lt; asm keyword for GNU Compiler        */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE         inline       <span class="comment">/*!&lt; inline keyword for GNU Compiler     */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined   (  __TASKING__  )</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __ASM            __asm        <span class="comment">/*!&lt; asm keyword for TASKING Compiler    */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> __INLINE         inline       <span class="comment">/*!&lt; inline keyword for TASKING Compiler */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>这几个宏都是什么含义呢？分别对应什么平台呢？</p></li></ol><ul><li>__CC_ARM对应的平台是：ARM RealView：<ul><li>RealView，是一套包含编译、调试和模拟的开发工具，需结合开发环境如uvision、eclipse或者CodeWarrior，形成集成开发环境来使用。</li></ul></li><li>__ICCARM__对应的平台是：IAR EWARM：<ul><li>Embedded Workbench for ARM 是IARSystems 公司为ARM 微处理器开发的一个集成开发环境(下面简称IAR EWARM)。比较其他的ARM 开发环境，IAR EWARM 具有入门容易、使用方便和代码紧凑等特点</li></ul></li><li>__GNUC__对应的平台是：GNU Compiler Collection:<ul><li>GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。</li></ul></li><li>__TASKING__对应的平台是：Altinum Designer;<ul><li>Altium Designer 是原Protel软件开发商Altium公司推出的一体化的电子产品开发系统，主要运行在Windows操作系统。这套软件通过把原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线、信号完整性分析和设计输出等技术的完美融合，为设计者提供了全新的设计解决方案，使设计者可以轻松进行设计，熟练使用这一软件使电路设计的质量和效率大大提高。  </li></ul></li></ul><h3 id="3-2-2-attribute-at-绝对定位"><a href="#3-2-2-attribute-at-绝对定位" class="headerlink" title="3.2.2 __attribute__ ((at()) 绝对定位"></a>3.2.2 <code>__attribute__ ((at())</code> 绝对定位</h3><ul><li><code>__attribute__</code> ，这个是用来指定变量或结构位域的特殊属性,该关键字后的双括弧中的内容是属性说明。 </li><li><code>at</code> ，该关键字可以用来设置变量的绝对地址,也就是你可以通过这个关键字,指定某个变量处于内存里面的某个给定的地址. </li></ul><hr><p>&emsp;&emsp;<code>__attribute__( at(绝对地址) )</code>  的用法分两种，一个是绝对定位到Flash，另个一是绝对定位到RAM。</p><ol><li><p>定位到flash中，一般用于固化的信息，如出厂设置的参数，上位机配置的参数，ID卡的ID号，flash标记等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> u16 gFlashDefValue[<span class="number">512</span>] __attribute__((at(<span class="number">0x0800F000</span>))) = &#123;<span class="number">0x1111</span>,<span class="number">0x1111</span>,<span class="number">0x1111</span>,<span class="number">0x0111</span>,<span class="number">0x0111</span>,<span class="number">0x0111</span>&#125;;<span class="comment">//定位在flash中,其他flash补充为00</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> u16 <span class="title">gflashdata__attribute__</span><span class="params">((at(<span class="number">0x0800F000</span>)))</span> </span>= <span class="number">0xFFFF</span>;</span><br></pre></td></tr></table></figure></li><li><p>定位到RAM中，一般用于数据量比较大的缓存，如串口的接收缓存，再就是某个位置的特定变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8 USART2_RX_BUF[USART2_REC_LEN] __attribute__ ((at(<span class="number">0X20001000</span>)));<span class="comment">//接收缓冲,最大USART_REC_LEN个字节,起始地址为0X20001000.</span></span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ol><li>绝对定位不能在函数中定义，局部变量是定义在栈区的，栈区由MDK自动分配、释放，不能定义为绝对地址，只能放在函数外定义。</li><li>定义的长度不能超过栈或Flash的大小，否则，造成栈、Flash溢出。</li></ol></li></ol><p>==以下部分是Bootloader的==</p><h3 id="3-2-3-跳转代码的理解"><a href="#3-2-3-跳转代码的理解" class="headerlink" title="3.2.3 跳转代码的理解"></a>3.2.3 跳转代码的理解</h3><blockquote><p>if (((*(__IO uint32_t*)ApplicationAddress) &amp; 0x2FFE0000 ) == 0x20000000)</p></blockquote><p>//判断栈定地址值是否在0x2000 0000 - 0x 2000 2000之间</p><ol><li>在程序里 <code>#define ApplicationAddress    0x8003000 </code></li><li><code>*(__IO uint32_t*)ApplicationAddress) </code> ，即取0x8003000开始到0x8003003 的4个字节的值</li><li>因为我们的应用程序APP中设置把 中断向量表 放置在0x08003000 开始的位置；而中断向量表里第一个放的就是栈顶地址的值</li></ol><p>&emsp;&emsp;也就是说，这句话即通过判断栈顶地址值是否正确（是否在0x2000 0000 - 0x 2000 2000之间）来判断是否应用程序已经下载了，因为应用程序的启动文件刚开始就去初始化化栈空间，如果栈顶值对了，说应用程已经下载了启动文件的初始化也执行了。</p><hr><blockquote><p>JumpAddress = *(__IO uint32_t*) (ApplicationAddress + 4);</p></blockquote><p>&emsp;&emsp;ApplicationAddress + 4  即为0x0800 3004 ,里面放的是中断向量表的第二项“复位地址”。</p><hr><blockquote><p>Jump_To_Application = (pFunction) JumpAddress;</p></blockquote><p>&emsp;&emsp;<code>void (*pFunction)(void);</code>    是声明一个函数指针。将复位地址作为函数指针，当其执行对应函数时，就是执行复位函数。</p><hr><blockquote><p>__set_MSP(*(__IO uint32_t*) ApplicationAddress);  //设置主函数栈指针</p></blockquote><p>&emsp;&emsp;顾名思义，从上面可知，就是取 ApplicationAddress 开始到 ApplicationAddress+3 的4个字节的值，设置为栈顶地址。</p><p><strong><font color="red">总结：</font></strong> 因此Bootloader跳转到App，最核心的点就只有两个：1)设置新复位地址，并跳转执行；2)设置新栈顶地址，并将主函数栈指针指向该地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本篇主要讲基于Stm32的IAP升级(即Bootloader升级)。主要是讲解Bootloader制作思路(该思路不只是用于该系列的芯片)。此篇文章内容较多，需要慢慢消化，部分内容可以先跳着看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="IAP" scheme="http://shatang.github.io/tags/IAP/"/>
    
      <category term="Xmodem" scheme="http://shatang.github.io/tags/Xmodem/"/>
    
      <category term="bootloader" scheme="http://shatang.github.io/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>Xmodem协议</title>
    <link href="http://shatang.github.io/2020/08/12/Xmodem%E5%8D%8F%E8%AE%AE/"/>
    <id>http://shatang.github.io/2020/08/12/Xmodem协议/</id>
    <published>2020-08-12T14:22:43.000Z</published>
    <updated>2020-08-12T14:30:00.452Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;常用于嵌入式IAP串口升级。</p><a id="more"></a><h1 id="一、什么是Xmodem协议？"><a href="#一、什么是Xmodem协议？" class="headerlink" title="一、什么是Xmodem协议？"></a>一、什么是Xmodem协议？</h1><p>&emsp;&emsp;XMODEM协议是一种串口通信中广泛用到的异步文件传输协议。分为标准Xmodem和1k-Xmodem两种，前者以128字节块的形式传输数据，后者字节块为1k即1024字节，并且每个块都使用一个校验和过程来进行错误检测。在校验过程中如果接收方关于一个块的校验和与它在发送方的校验和相同时，接收方就向发送方发送一个确认字节(ACK)。由于Xmodem需要对每个块都进行认可，这将导致性能有所下降，特别是延时比较长的场合，这种协议显得效率更低。</p><p>&emsp;&emsp;除了Xmodem，还有Ymodem，Zmodem协议。他们的协议内容和Xmodem类似，但是进行了拓展。</p><ul><li>Ymodem允许批处理文件传输，效率更高；</li><li>Zmodem则是改进的了Xmodem，它只需要对损坏的块进行重发，其它正确的块不需要发送确认字节。减少了通信量。</li></ul><h1 id="二、Xmodem协议相关控制字符"><a href="#二、Xmodem协议相关控制字符" class="headerlink" title="二、Xmodem协议相关控制字符"></a>二、Xmodem协议相关控制字符</h1><table><thead><tr><th>命令字符</th><th>命令码</th></tr></thead><tbody><tr><td>SOH</td><td>0x01 (Modem数据头)</td></tr><tr><td>STX</td><td>0x02</td></tr><tr><td>EOT</td><td>0x04 (发送结束)</td></tr><tr><td>ACK</td><td>0x06 (应答)</td></tr><tr><td>NAK</td><td>0x15 (非应答)</td></tr><tr><td>CAN</td><td>0x18 (取消发送)</td></tr><tr><td>CTRLZ</td><td>0x1A</td></tr></tbody></table><h1 id="三、Xmodem数据包格式"><a href="#三、Xmodem数据包格式" class="headerlink" title="三、Xmodem数据包格式"></a>三、Xmodem数据包格式</h1><blockquote><p>标准Xmodem协议（每个数据包含有128字节数据）帧格式</p></blockquote><p>| SOH | 信息包序号 | 信息包序号的补码 | 数据区段(128个字节) | 校验和 |</p><img src="/2020/08/12/Xmodem协议/1.png"><blockquote><p>标准XModem传输流程</p></blockquote><img src="/2020/08/12/Xmodem协议/2.png"><p>&emsp;&emsp;1k-Xmodem 只是在Xmodem协议基础上，进行了数据包长度的改进，从原有的128字节更改为1k字节。同时每个信息报的第一个字节的SOH变成了STX，STX定义为 <code><stx> 0x02</stx></code> ，能有效的加快数据传输速率。</p><h1 id="四、校验方式和传输流程"><a href="#四、校验方式和传输流程" class="headerlink" title="四、校验方式和传输流程"></a>四、校验方式和传输流程</h1><h2 id="4-1-校验方式说明"><a href="#4-1-校验方式说明" class="headerlink" title="4.1 校验方式说明"></a>4.1 校验方式说明</h2><p>&emsp;&emsp;Xmodem协议支持2种校验和，它们是累加和与CRC校验。</p><ul><li>当接收方一开始启动传输时发送的是NAK，表示它希望以累加和方式校验；</li><li>当接收方一开始启动传输时发送的是字符“C”，表示它希望以CRC方式校验。</li></ul><p>&emsp;&emsp;可能有人会问，接收方想怎么校验发送方都得配合吗，难道发送方必须都支持累加和校验和CRC校验？事实上Xmodem要求支持CRC的就必须同时支持累加和。如果发送方只支持累加和，而接收方用字符“C”来启动，那么发送方只要不管它，当接收方继续发送“C”，三次后都没收到应答，就自动会改为发送 NAK；因为它已经明白发送方可能不支持CRC校验，现在接收方改为累加和校验和发送方通讯。发送方收到NAK就赶紧发送数据包响应。 </p><h2 id="4-2-启动传输"><a href="#4-2-启动传输" class="headerlink" title="4.2 启动传输"></a>4.2 启动传输</h2><p>&emsp;&emsp;传输由接收方启动，方法是向发送方发送”C”或者NAK （注意哦，这里提到的NAK是用来启动传输的；以后我们会看到NAK还可以用来对数据产生重传的机制）。</p><ul><li>接收方发送NAK信号表示接收方打算用累加和校验；</li><li>发送字符”C”则表示接收方想打算使用CRC校验</li></ul><p>举例，接收方要求发送方以校验和方式发送时以NAK来请求，发送方将对此做出应答。如下图：</p><img src="/2020/08/12/Xmodem协议/3.png"><h2 id="4-3-传输过程"><a href="#4-3-传输过程" class="headerlink" title="4.3 传输过程"></a>4.3 传输过程</h2><p>&emsp;&emsp;当接收方发送的第一个”C”或者NAK到达发送方，发送方认为可以发送第一个数据包，传输已经启动。发送方接着应该将数据以每次128字节的数据加上包头，包号，包号补码，末尾加上校验和，打包成帧格式传送。</p><p>&emsp;&emsp;发送方发了第一包后就等待接收方的确认字节ACK，收到接收方传来的ACK确认，就认为数据包被接收方正确接收，并且接收方要求发送方继续发送下一个包；如果发送方收到接收方传来的NAK （这里，NAK用来告诉发送方重传，不是用来启动传输） 字节，则表示接收方请求重发刚才的数据包；</p><p>&emsp;&emsp;如果发送方收到接收方传来的CAN字节，则表示接收方请求无条件停止传输。</p><h2 id="4-4-结束传输"><a href="#4-4-结束传输" class="headerlink" title="4.4 结束传输"></a>4.4 结束传输</h2><p>&emsp;&emsp;如果发送方正常传输完全部数据，需要结束传输，正常结束需要发送方发送EOT 字节通知接收方。接收方回以ACK进行确认。当然接收方也可强制停止传输，当接收方发送CAN 字节给发送方，表示接收方想无条件停止传输，发送方收到CAN后，不需要再发送 EOT确认（因为接收方已经不想理它了，呵呵）。</p><h2 id="4-5-特殊处理"><a href="#4-5-特殊处理" class="headerlink" title="4.5 特殊处理"></a>4.5 特殊处理</h2><p>&emsp;&emsp;虽然数据包是以 SOH 来标志一个信息包的起始的，但在 SOH 位置上如果出现EOT则表示数据传输结束，再也没有数据传过来。</p><ul><li>接收方首先应确认数据包序号的完整性，通过对数据包序号取补，然后和数据包序号的补码异或，结果为0表示正确，结果不为0则发送NAK请求重传。</li><li>接收方确认数据包序号正确后，然后检查是否期望的序号。如果不是期望得到的数据包序号，说明发生严重错误，应该发送一个 CAN 来中止传输。</li><li>如果接收到的数据包的包序号和前一包相同，那么接收方会忽略这个重复包，向发送方发出 ACK ，准备接收下一个包。</li><li>接收方确认了信息包序号的完整性和是正确期望的后，只对 128 字节的数据区段进行算术和校验，结果与帧中最后一个字节（算术校验和）比较，相同发送 ACK，不同发送 NAK。</li></ul><h2 id="4-6-数据包特殊说明"><a href="#4-6-数据包特殊说明" class="headerlink" title="4.6 数据包特殊说明"></a>4.6 数据包特殊说明</h2><p>&emsp;&emsp;对于标准Xmodem协议来说，如果传送的文件不是128的整数倍，那么最后一个数据包的有效内容肯定小于帧长，不足的部分需要用CTRL- Z(0x1A)来填充。这里可能有人会问，我数据末尾是0x1A呢？</p><ul><li>如果传送的是文本文件，那么接收方对于接收的内容是很容易识别的，因为Xmodem协议定义的<strong>CTRL-Z(0x1A)</strong> 不是前128个ascii码中的通用可见字母等字符( 0x1A 对应 SUB[替补] )。</li><li>如果传送的是二进制文件，例如 bootloader 工程生成的.bin文件。假如我的.bin文件最末尾是0x1A，那如何区分填充的0x1A？<ul><li>例如像excel文件等，由于其数据内部会有些结构表示各个字段长度等，所以不会读取多余的填充字符。</li><li>而.bin文件，一般是不做区分的，它直接把填充码直接同样写入flash<ul><li>Flash写入是要擦除的，如果想利用填充码位置的Flash，只能用一次性，不然会损坏到IAP升级的APP文件</li><li>Mcu其实不会把填充码当作代码来执行(没有跳转到该位置的代码块)。</li><li>如果使用 1k-Xmodem ，最极端的情况下，也就浪费Mcu不到1K flash；(对于芯片Flash容量小，即扇区也小，干脆直接用Xmodem升级)</li></ul></li></ul></li></ul><h1 id="五、补充知识：128个字符的ASCII码表"><a href="#五、补充知识：128个字符的ASCII码表" class="headerlink" title="五、补充知识：128个字符的ASCII码表"></a>五、补充知识：128个字符的ASCII码表</h1><p>&emsp;&emsp;由于上面的文本文件，对编码格式有疑惑的，建议重新看一下128字符的ASCII码表。<strong>基础ascii码值最大值是0x7f=127，扩展ascii码值最大值是0xFF=255。</strong><br>&emsp;&emsp;文章的链接为：<a href="https://shatang.github.io/2020/06/28/128%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84ASCII%E7%A0%81%E8%A1%A8/#more">128个字符的ASIIC码表</a></p><h1 id="六、补充知识：CRC16校验的实现"><a href="#六、补充知识：CRC16校验的实现" class="headerlink" title="六、补充知识：CRC16校验的实现"></a>六、补充知识：CRC16校验的实现</h1><p>&emsp;&emsp;对CRC校验有疑惑、不了解的，可以看这篇博文：<a href="https://shatang.github.io/2020/08/10/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#more">CRC校验算法原理分析</a></p><h1 id="七、代码实例"><a href="#七、代码实例" class="headerlink" title="七、代码实例"></a>七、代码实例</h1><p>&emsp;&emsp;这里先放一个官方例程：<a href="https://pan.baidu.com/s/1-jREbLowNT3TbI_50aAgBg" target="_blank" rel="noopener">ST官方的IAP + Ymodem代码</a>；提取码为：aan9<br>&emsp;&emsp;再放一个超级终端方便调试升级：<a href="https://pan.baidu.com/s/1OgDHkVzkezVbZZcGGQCMZw" target="_blank" rel="noopener">超级终端(支持win10)</a>；提取码为：3ejn</p><h2 id="7-1-Ymodem协议"><a href="#7-1-Ymodem协议" class="headerlink" title="7.1 Ymodem协议"></a>7.1 Ymodem协议</h2><p>&emsp;&emsp;从上述Xmodem知识讲解后，如果你去查询 Ymodem协议概念 ，你会发现及其相似。这里我放我的实例；根据官方IAP升级例程进行修改简化，芯片是Stm32F407vgt6，支持多串口任选升级 的代码：<a href>基于Ymodem协议的IAP升级</a>。</p><p>&emsp;&emsp;<strong>标准</strong>Ymodem的特点，就是相对Xmodem能进行批文件传输。具体的实现方法就是：文件发送完以后，发送方发出一个“EOT”信号，接收方也以“ACK”回应；然后接收方会再次发出“C”开启另一次传输，若接着发送方会发出一个“全0数据包”，接收方“ACK”以后，本次通信正式结束。</p><p>&emsp;&emsp;这样的话，每次建立连接，标准Ymodem能多次传输文件，即批文件传输。</p><p><strong>Ps：</strong> 如果应用在嵌入式Bootloader的话，基本都只用一次，即接收方嵌入式固件常为非标准的Ymodem协议。</p><h2 id="7-2-Xmodem-amp-Ymodem"><a href="#7-2-Xmodem-amp-Ymodem" class="headerlink" title="7.2 Xmodem &amp; Ymodem"></a>7.2 Xmodem &amp; Ymodem</h2><p>&emsp;&emsp;根据 7.1 的实例，能够通过Ymodem协议进行IAP升级；Xmodem 和 Ymodem 极其相似，直接切换成 Xmodem协议 进行升级能不能成呢？</p><p>当然是理所当然地报错了！那么极其相似，但到底差别在哪里？</p><ul><li>文件传输的第一个数据包<ul><li>Ymodem支持文件传输，体现在了传输文件第一个包，会先发 文件名 &amp; 文件大小；</li><li>而Xmodem是直接传输数据的</li></ul></li><li>数据包报文中的 Byte2 和 Byte3，一个是数据包数，一个是数据包数补码<ul><li>Ymodem协议，他的数据包数是0x00开始(因为要多接一个文件信息)</li><li>Xmodem协议，它的数据包数是0x01开始的(= =|||)</li></ul></li></ul><p>&emsp;&emsp;通过上述的总结，因为Ymodem与Xmodem很相似，可以根据上面的不同点稍微改一下，就能得到 基于Xmodem协议的IAP升级 代码： <a href>基于Xmodem协议的IAP升级</a>。(可能残留一些Ymodem的代码)</p><ul><li>两者带来的差别：Flash的擦除<ul><li>Ymodem协议，第一包数据可以知道文件名、文件大小；如果不匹配可以不擦除旧APP的Flash，与超级终端连上后，不升级，设备是不会变成砖的</li><li>Xmodem协议，不清楚文件，故它一定会擦除旧APP存储的Flash；如果擦除程序在升级前做，那么如果连上后放弃升级，该设备自然就会变成砖(就我现在写的那个)；当然也可以改写成在确实收到(识别)第一包数据包后，再擦除Flash就能实现类似Ymodem的效果</li></ul></li></ul><h2 id="7-3-文件加密-小技巧"><a href="#7-3-文件加密-小技巧" class="headerlink" title="7.3 文件加密(小技巧)"></a>7.3 文件加密(小技巧)</h2><p>&emsp;&emsp;通过上述的Xmodem、Ymodem进行文件传输时，有时候需要文件加密安全一点。我举一个自己在用的例子：</p><ol><li>做一个简易的上位机，把bin文件拖进去；由于bin文件就是二进制文件，可以将其 异或 某条字符串，不断循环直至 整个文件异或成 新的文件</li><li>通过协议传输后，把获取到的数据，又重新异或一遍，这样的话，数据就会解密(数据异或两次就会变回原来的数据)，再写入Flash</li><li>上位机的字符串加密要可改写非固定，这样就能实现简单文件加密传输拉！</li></ol><p><strong>Ps：</strong> 上面我的代码例程就有夹杂解密的，可以去掉；不过我的代码里面没有做CRC校验，因为我看到官方Ymodem自己就没加CRC校验；我的Xmodem例程就顺带加了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;常用于嵌入式IAP串口升级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="IAP" scheme="http://shatang.github.io/tags/IAP/"/>
    
      <category term="串口协议" scheme="http://shatang.github.io/tags/%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="文件传输" scheme="http://shatang.github.io/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>stm32内部Flash基础知识</title>
    <link href="http://shatang.github.io/2020/08/12/stm32%E5%86%85%E9%83%A8Flash%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://shatang.github.io/2020/08/12/stm32内部Flash基础知识/</id>
    <published>2020-08-12T14:14:08.000Z</published>
    <updated>2020-08-12T14:19:00.756Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;由于嵌入式IAP升级时，制作的Bootloader往往会涉及到Stm32的Flash的一些操作(用于写入App程序)，因此这里讲解一下Stm32的Flash相关操作</p><a id="more"></a><h1 id="一、Stm32的Flash"><a href="#一、Stm32的Flash" class="headerlink" title="一、Stm32的Flash"></a>一、Stm32的Flash</h1><h2 id="1-1-Flash的基础原理"><a href="#1-1-Flash的基础原理" class="headerlink" title="1.1 Flash的基础原理"></a>1.1 Flash的基础原理</h2><p>&emsp;&emsp;此处内容可以看该篇博文：<a href="https://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8/">嵌入式存储器</a></p><h2 id="1-2-Stm32的Flash特性、操作"><a href="#1-2-Stm32的Flash特性、操作" class="headerlink" title="1.2 Stm32的Flash特性、操作"></a>1.2 Stm32的Flash特性、操作</h2><ul><li>已知Flash写入前需要擦除的特性</li><li>Nor Flash接口与RAM接口相同，因此往往MCU内部采用Nor Flash；即Stm32的Flash为 Nor Flash<ul><li>因此如果是擦除大块区域时，会相对较慢</li></ul></li><li>Stm32的Flash使用前后，需要 解锁 、 锁定<ul><li>在实际发布的产品中，在STM32芯片的内部FLASH存储了控制程序，如果不作任何保护措施的话，可以使用下载器直接把内部FLASH的内容读取回来，得到bin或hex文件格式的代码拷贝，别有用心的厂商即可利用该代码文件山寨产品。 </li></ul></li></ul><hr><p>&emsp;&emsp;对STM32 内部FLASH进行编程操作，一般需要遵循以下流程：</p><ol><li>Flash解锁</li><li>清除相关标志位</li><li>擦除Flash</li><li>写入Flash</li><li>锁定Flash</li></ol><h2 id="1-3-Flash的底层操作函数-仅限Stm32"><a href="#1-3-Flash的底层操作函数-仅限Stm32" class="headerlink" title="1.3 Flash的底层操作函数(仅限Stm32)"></a>1.3 Flash的底层操作函数(仅限Stm32)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FLASH_Unlock(); <span class="comment">//Flash解锁函数</span></span><br><span class="line">FLASH_Lock();   <span class="comment">//Flash锁定函数</span></span><br><span class="line"><span class="function">FLASH_Status <span class="title">FLASH_EraseSector</span><span class="params">(<span class="keyword">uint32_t</span> FLASH_Sector, <span class="keyword">uint8_t</span> VoltageRange)</span></span>;    <span class="comment">//Flash擦除函数</span></span><br><span class="line"><span class="function">FLASH_Status <span class="title">FLASH_ProgramWord</span><span class="params">(uint32_r Address， <span class="keyword">uint32_t</span> Data)</span></span>;   <span class="comment">//Flash写入函数</span></span><br></pre></td></tr></table></figure><h2 id="1-4-Flash的衍生操作函数"><a href="#1-4-Flash的衍生操作函数" class="headerlink" title="1.4 Flash的衍生操作函数"></a>1.4 Flash的衍生操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">FLASH_If_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">FLASH_If_Finish</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint32_t <span class="title">FLASH_If_Erase</span><span class="params">(<span class="keyword">uint32_t</span> StartSector)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint32_t <span class="title">FLASH_If_Write</span><span class="params">(__IO <span class="keyword">uint32_t</span>* FlashAddress, <span class="keyword">uint32_t</span>* Data ,<span class="keyword">uint32_t</span> DataLength)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">FLASH_IF_Read</span><span class="params">(<span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> *pBuffer, <span class="keyword">uint32_t</span> NumToRead)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子：Stm32F407VGT6的Flash</span></span><br><span class="line"><span class="comment">//FLASH 扇区的起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_0     ((uint32_t)0x08000000) <span class="comment">//扇区0起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_1     ((uint32_t)0x08004000) <span class="comment">//扇区1起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_2     ((uint32_t)0x08008000) <span class="comment">//扇区2起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_3     ((uint32_t)0x0800C000) <span class="comment">//扇区3起始地址, 16 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_4     ((uint32_t)0x08010000) <span class="comment">//扇区4起始地址, 64 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_5     ((uint32_t)0x08020000) <span class="comment">//扇区5起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_6     ((uint32_t)0x08040000) <span class="comment">//扇区6起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_7     ((uint32_t)0x08060000) <span class="comment">//扇区7起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_8     ((uint32_t)0x08080000) <span class="comment">//扇区8起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_9     ((uint32_t)0x080A0000) <span class="comment">//扇区9起始地址, 128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_10    ((uint32_t)0x080C0000) <span class="comment">//扇区10起始地址,128 Kbytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_FLASH_SECTOR_11    ((uint32_t)0x080E0000) <span class="comment">//扇区11起始地址,128 Kbytes</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  GetSector</span></span><br><span class="line"><span class="comment">* 功  能 :  获取某个地址所在的flash扇区</span></span><br><span class="line"><span class="comment">* 说  明 :  Stm32F407VGT6的Flash扇区分配</span></span><br><span class="line"><span class="comment">* 入  参 :  fu32_Addr：flash地址</span></span><br><span class="line"><span class="comment">* 返  回 :  0~11,即addr所在的扇区</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint16_t <span class="title">GetSector</span><span class="params">(<span class="keyword">uint32_t</span> fu32_Addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_1)<span class="keyword">return</span> FLASH_Sector_0;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_2)<span class="keyword">return</span> FLASH_Sector_1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_3)<span class="keyword">return</span> FLASH_Sector_2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_4)<span class="keyword">return</span> FLASH_Sector_3;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_5)<span class="keyword">return</span> FLASH_Sector_4;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_6)<span class="keyword">return</span> FLASH_Sector_5;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_7)<span class="keyword">return</span> FLASH_Sector_6;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_8)<span class="keyword">return</span> FLASH_Sector_7;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_9)<span class="keyword">return</span> FLASH_Sector_8;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_10)<span class="keyword">return</span> FLASH_Sector_9;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fu32_Addr&lt;ADDR_FLASH_SECTOR_11)<span class="keyword">return</span> FLASH_Sector_10; </span><br><span class="line"><span class="keyword">return</span> FLASH_Sector_11;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  FLASH_If_Init</span></span><br><span class="line"><span class="comment">* 功  能 :  stm32的内部flash初始化(解锁)</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  none</span></span><br><span class="line"><span class="comment">* 返  回 :  none</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLASH_If_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    FLASH_Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear pending flags (if any) */</span></span><br><span class="line">    FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |</span><br><span class="line">                  FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 : FLASH_If_Finish</span></span><br><span class="line"><span class="comment">* 功  能 : stm32的内部flash关闭(上锁)</span></span><br><span class="line"><span class="comment">* 说  明 : none</span></span><br><span class="line"><span class="comment">* 入  参 : none</span></span><br><span class="line"><span class="comment">* 返  回 : none</span></span><br><span class="line"><span class="comment">* 设  计 : Shatang                    时  间 : 2020.07.29</span></span><br><span class="line"><span class="comment">* 修  改 : none                       时  间 : none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLASH_If_Finish</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Clear pending flags (if any) */</span></span><br><span class="line">    FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |</span><br><span class="line">                  FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);</span><br><span class="line">    </span><br><span class="line">    FLASH_Lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  FLASH_If_Erase</span></span><br><span class="line"><span class="comment">* 功  能 :  stm32的内部flash擦除</span></span><br><span class="line"><span class="comment">* 说  明 :  只针对APP文件地址的存储内容进行擦除</span></span><br><span class="line"><span class="comment">* 入  参 :  none</span></span><br><span class="line"><span class="comment">* 返  回 :  none</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="keyword">uint32_t</span> FLASH_If_Erase(<span class="keyword">uint32_t</span> StartSector)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> UserStartSector;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the sector where start the user flash area */</span></span><br><span class="line">    UserStartSector = GetSector(StartSector);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = UserStartSector; i &lt;= GetSector(APPLICATION_END_ADDRESS); i += <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Device voltage range supposed to be [2.7V to 3.6V], the operation will</span></span><br><span class="line"><span class="comment">        be done by word */</span> </span><br><span class="line">        <span class="keyword">if</span> (FLASH_EraseSector(i, VoltageRange_3) != FLASH_COMPLETE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Error occurred while page erase */</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  FLASH_If_Write</span></span><br><span class="line"><span class="comment">* 功  能 :  stm32的内部flash写操作</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  none</span></span><br><span class="line"><span class="comment">* 返  回 :  none</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="keyword">uint32_t</span> FLASH_If_Write(__IO <span class="keyword">uint32_t</span>* FlashAddress, <span class="keyword">uint32_t</span>* Data ,<span class="keyword">uint32_t</span> DataLength)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt; DataLength) &amp;&amp; (*FlashAddress &lt;= (APPLICATION_END_ADDRESS<span class="number">-4</span>)); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Device voltage range supposed to be [2.7V to 3.6V], the operation will</span></span><br><span class="line"><span class="comment">           be done by word */</span> </span><br><span class="line">        <span class="keyword">if</span> (FLASH_ProgramWord(*FlashAddress, *(<span class="keyword">uint32_t</span>*)(Data+i)) == FLASH_COMPLETE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Check the written value */</span></span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">uint32_t</span>*)*FlashAddress != *(<span class="keyword">uint32_t</span>*)(Data+i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Flash content doesn't match SRAM content */</span></span><br><span class="line">                <span class="keyword">return</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Increment FLASH destination address */</span></span><br><span class="line">            *FlashAddress += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Error occurred while writing data in Flash memory */</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  STMFLASH_ReadWord</span></span><br><span class="line"><span class="comment">* 功  能 :  读取指定地址的半字(16位数据) </span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  fu32_Addr：读地址 </span></span><br><span class="line"><span class="comment">* 返  回 :  对应数据</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint32_t <span class="title">STMFLASH_ReadWord</span><span class="params">(<span class="keyword">uint32_t</span> fu32_Addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="keyword">uint32_t</span>*)fu32_Addr; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  STMFLASH_ReadWord</span></span><br><span class="line"><span class="comment">* 功  能 :  从指定地址开始读出指定长度的数据</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  ReadAddr：起始地址</span></span><br><span class="line"><span class="comment">            pBuffer：数据指针</span></span><br><span class="line"><span class="comment">            NumToRead：读的数据个数</span></span><br><span class="line"><span class="comment">* 返  回 :  对应数据</span></span><br><span class="line"><span class="comment">* 设  计 :  Shatang                   时  间 :  2020.06.18</span></span><br><span class="line"><span class="comment">* 修  改 :  none                      时  间 :  none</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FLASH_IF_Read</span><span class="params">(<span class="keyword">uint32_t</span> ReadAddr, <span class="keyword">uint32_t</span> *pBuffer, <span class="keyword">uint32_t</span> NumToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumToRead;i++)</span><br><span class="line">&#123;</span><br><span class="line">pBuffer[i] = STMFLASH_ReadWord(ReadAddr);<span class="comment">//读取4个字节.</span></span><br><span class="line">ReadAddr+=<span class="number">4</span>;<span class="comment">//偏移4个字节.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、详细应用实例"><a href="#二、详细应用实例" class="headerlink" title="二、详细应用实例"></a>二、详细应用实例</h1><p>&emsp;&emsp;具体实际应用：基于Xmodem协议的IAP升级，可以看这篇文章：<a href></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;由于嵌入式IAP升级时，制作的Bootloader往往会涉及到Stm32的Flash的一些操作(用于写入App程序)，因此这里讲解一下Stm32的Flash相关操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="bootloader" scheme="http://shatang.github.io/tags/bootloader/"/>
    
      <category term="stm32" scheme="http://shatang.github.io/tags/stm32/"/>
    
      <category term="Flash" scheme="http://shatang.github.io/tags/Flash/"/>
    
  </entry>
  
  <entry>
    <title>CRC校验算法原理分析</title>
    <link href="http://shatang.github.io/2020/08/10/CRC%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://shatang.github.io/2020/08/10/CRC校验算法原理分析/</id>
    <published>2020-08-10T15:20:22.000Z</published>
    <updated>2020-08-12T13:51:16.820Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里提一下各种通讯协议都经常使用的CRC校验，为后面的知识做铺垫。</p><a id="more"></a><h1 id="一、CRC分析"><a href="#一、CRC分析" class="headerlink" title="一、CRC分析"></a>一、CRC分析</h1><p>&emsp;&emsp;我只是把网上能搜到的资料根据自己的理解重新写了一遍，本文大部分内容都来自于下面的两位博主:</p><p>wchonline  ， <a href="https://www.cnblogs.com/wchonline/p/11698677.html" target="_blank" rel="noopener">CRC校验算法详解</a><br>偏执灬  ， <a href="https://blog.csdn.net/sinat_23338865/java/article/details/73549076" target="_blank" rel="noopener">CRC校验算法原理分析</a></p><h2 id="1-1-数据校验"><a href="#1-1-数据校验" class="headerlink" title="1.1 数据校验"></a>1.1 数据校验</h2><p>&emsp;&emsp;数据在传输过程（比如通过网线在两台计算机间传文件）中，由于传输信道的原因，可能会有误码现象（比如说发送数字5但接收方收到的却是6），如何发现误码呢？方法是发送额外的数据让接收方校验是否正确，这就是数据校验。</p><p>&emsp;&emsp;最容易想到的校验方法是和校验，就是将传送的数据(按字节方式)加起来计算出数据的总和，并将总和传给接收方，接收方收到数据后也计算总和，并与收到的总和比较看是否相同。如果传输中出现误码，那么总和一般不会相同，从而知道有误码产生，可以让发送方再发送一遍数据。</p><h2 id="1-2-CRC校验原理"><a href="#1-2-CRC校验原理" class="headerlink" title="1.2 CRC校验原理"></a>1.2 CRC校验原理</h2><p>&emsp;&emsp;CRC(Cyclic Redundancy Check)循环冗余校验是常用的数据校验方法。CRC校验码的基本思想是利用线性编码理论， 在发送端根据要传送的k位二进制码序列，以一定的规则产生一个校验用的监督码（既CRC码）r位，并附在信息后边，构成一个新的二进制码序列数共(k+r)位，最后发送出去。在接收端，则根据信息码和CRC码之间所遵循的规则进行检验，以确定传送中是否出错，在数据存储和数据通讯领域常用。</p><h2 id="1-3-CRC多项式-理解就行"><a href="#1-3-CRC多项式-理解就行" class="headerlink" title="1.3 CRC多项式(理解就行)"></a>1.3 CRC多项式(理解就行)</h2><p>&emsp;&emsp;一般在数据传输之前，发送端与接收端会相互约定好一个除数（也是一个二进制序列，用来进行模2除法）。这个除数就是生成多项式。</p><p><strong><font color="red">Ps：</font></strong> 这个多项式的最高位和最低位必须为1</p><p>&emsp;&emsp;生成多项式的选择是 CRC 算法实现中最重要的部分，所选择的多项式必须有最大的错误检测能力，同时保证总体的碰撞概率最小。多项式最重要的属性是它的长度，也就是最高非零系数的数值，因为它直接影响着计算的校验和的长度。</p><p>&emsp;&emsp;在构建一个新的 CRC 多项式或者改进现有的 CRC 时，一个通用的数学原则是使用满足所有模运算不可分解多项式约束条件的多项式。</p><ul><li>生成多项式的最高位和最低位必须为1。</li><li>当被传送信息（CRC码）任何一位发生错误时，被生成多项式做模2除后，应该使余数不为0。</li><li>不同位发生错误时，应该使余数不同。</li><li>对余数继续做模2除，应使余数循环。</li></ul><h2 id="1-4-CRC校验简单理解-要点"><a href="#1-4-CRC校验简单理解-要点" class="headerlink" title="1.4 CRC校验简单理解(要点)"></a>1.4 CRC校验简单理解(要点)</h2><p>&emsp;&emsp;在数据传输之前，发送方与接收方会相互约定好一个除数（多项式，进行模2算法）。</p><ul><li>发送方：生成CRC校验码。<strong>CRC校验码就是将数据除以某个固定的数（比如ANSI-CRC16中，这个数是0x18005），所得到的余数就是CRC校验码。</strong></li><li>接收方：接收到数据包+CRC校验码。由于CRC校验码是之前发送方求余出来的数据，将数据包+CRC校验码合并后再进行模2除法校验，理论上余数为0。如果是余数不为0，说明了传输的数据错误。</li><li>因此，不同协议的CRC校验码基本不一样，因为约定的除数会根据自己协议制定(例如Modbus通讯)。</li></ul><hr><p>&emsp;&emsp;如果被除数比除数小，那么余数就是被除数本身，比如说只要传一个字节，那么它的CRC就是它自己，为避免这种情况，<strong>在做除法之前先将它移位，使它大于除数</strong>，那么移多少位呢？这就与所选的固定除数有关了，左移位数比除数的位数少1。</p><p>&emsp;&emsp;关于模2除法中除数的选择，这个可以自己随意选择。但由 1.3 可知，随意选择的除数会导致帧校验的<br>正确率下降，这是不确定的，要看你选择的除数。而我们一般的除数的选择是直接去参照一些专家讲过<br>多次试验下来的一些除数，这些除法能极大的保证帧校验的正确率。</p><p>&emsp;&emsp;一般而言，crc8校验的错误率为1/256(最小单元)，crc16校验的错误率为1/65536(最小单元)，crc32校验的错误率为1/2^32(最小单元)。CRC16的错误率已经是非常小了，所以一般在数据不多的情况下用CRC16校验就可以了，而在整个文件的校验中一般用CRC32校验。</p><hr><p>下面是常用标准中的除数：</p><blockquote><p>通用CRC多项式</p></blockquote><p>&emsp;&emsp;由1.3上面要求罗列出常用的多项式如下：</p><ul><li>CRC8-Dallas/Maxim：多项式是X8+X5+X4+1，对应的数字是0x131，左移8位</li><li>CRC8-ATM：多项式是 X8+X2+X1+1，对应的数字是0x107（0x07），左移8位</li><li>CRC8-CCITT：多项式是 X8+X6+X4+X3+X2+X1，对应的数字是0x15E（0x5E），左移8位</li><li>CRC12：多项式是 X12+X11+X3+X2+1，对应的数字是0x180D，左移12位</li><li>CRC16-CCITT：多项式是 X16+X12+X5+1，对应的数字是0x11021，左移16位</li><li>CRC16-ANSI ：多项式是 X16+X15+X2+1，对应的数字是0x18005，左移16位</li><li>CRC32：多项式是X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+1，对应数字是0x104C11DB7，左移32位</li></ul><p>因此，在得到字节串对应的数字后，再将数字左移M位（比如ANSI-CRC16是左移16位），就得到了被除数。</p><p><strong><font color="red">Ps：</font></strong> 由于多项式的最高为都为1，但在代码实现的crc计算中，最高位是不使用的；使用的是上面例子中括号内的值</p><p>&emsp;&emsp;从上面可以看到，即使是同为CRC8校验，多项式也有多种；因此计算CRC校验要格外注意多项式是否相同。不同的多项式，起检错能力是不同的。<strong>例如Modbus协议就规定 0xA001 就是它CRC校验的多项式。</strong></p><h1 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h1><p>&emsp;&emsp;算术上的除法，计算机当然会做，但因为减法有借位，很耗时间和指令!所以，计算CRC是除法，但是用XOR来代替减法。除法（XOR）的目的是逐步消掉二进制数最高位的1或0！由于过程是XOR的，所以商是没有意义的，我们不要。我们要的是余数。 </p><h2 id="2-1-顺序异或-amp-反序异或"><a href="#2-1-顺序异或-amp-反序异或" class="headerlink" title="2.1 顺序异或 &amp; 反序异或"></a>2.1 顺序异或 &amp; 反序异或</h2><p>&emsp;&emsp;CRC校验算法，就是把需要校验的数据与多项式进行循环异或（XOR），但进行XOR的方式与实际中数据传输时，是高位先传、还是低位先传有关。对于数据高位先传的方式，XOR从数据的高位开始，我们就叫它顺序异或吧；对于数据低位先传的方式，XOR从数据的低位开始，我们就叫它反序异或吧。两种不同的异或方式，即使对应相同的多项式，计算出来的结果也是不一样的。</p><p>&emsp;&emsp;比如前面ccitt-crc16的正序是0x1021，如果是反转就是0x8408（就是将0x1021倒过来低位变高位）。数据传输可能是先传低位再传高位（比如串口就是低位在前高位在后）。反转的CRC算法与正序类似，只是需要注意移位的方向相反。</p><p>&emsp;&emsp;这个问题一般不是问题。因为如果是自己写的发送方，当然是可以随便写！(开玩笑的)。如果是写接收方，发送方要么会给详细说明，或者有源码，直接搬迁过来就行了。</p><h2 id="2-2-代码例子"><a href="#2-2-代码例子" class="headerlink" title="2.2 代码例子"></a>2.2 代码例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">cal_table_high_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i, crc;</span><br><span class="line"></span><br><span class="line">    crc = value;</span><br><span class="line">    <span class="comment">/* 数据往左移了8位，需要计算8次 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">8</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)  <span class="comment">/* 判断最高位是否为1 */</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* 最高位为1，不需要异或，往左移一位，然后与0x31异或 */</span></span><br><span class="line">        <span class="comment">/* 0x31(多项式：x8+x5+x4+1，100110001)，最高位不需要异或，直接去掉 */</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 最高位为0时，不需要异或，整体数据往左移一位 */</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-CRC校验表"><a href="#2-3-CRC校验表" class="headerlink" title="2.3 CRC校验表"></a>2.3 CRC校验表</h2><p>&emsp;&emsp;2.2的代码计算一个字节的crc结果，如果计算多个字节的结果也是比较简单的，先计算第一个字节的crc结果，然后把第一个字节的crc结果与第二个字节进行异或，异或后的值再进行一次crc计算就可以了，多个字节也是反复这过程就好。</p><p>&emsp;&emsp;但是需要的运行量也是不少的，每一个字节都需要进行8次判断、移位、或异或操作。但是其实每个字节异或的结果是一定的，那就可以事先算好的CRC存入数组。采用查表法，大大减少计算量，先计算出 0x00~0xFF 每一个字节的crc校验结果，后面就可以通过表来查出每个字节的crc结果，大大 减少计算量。</p><p>下面是一个表生成程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">create_crc_table</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=<span class="number">0xFF</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (i%<span class="number">16</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        j = i&amp;<span class="number">0xFF</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%.2x, "</span>, cal_table_high_first (j));  <span class="comment">/*依次计算每个字节的crc校验值*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的表整理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> crc_table[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x62</span>,<span class="number">0x53</span>,<span class="number">0xc4</span>,<span class="number">0xf5</span>,<span class="number">0xa6</span>,<span class="number">0x97</span>,<span class="number">0xb9</span>,<span class="number">0x88</span>,<span class="number">0xdb</span>,<span class="number">0xea</span>,<span class="number">0x7d</span>,<span class="number">0x4c</span>,<span class="number">0x1f</span>,<span class="number">0x2e</span>,</span><br><span class="line">    <span class="number">0x43</span>,<span class="number">0x72</span>,<span class="number">0x21</span>,<span class="number">0x10</span>,<span class="number">0x87</span>,<span class="number">0xb6</span>,<span class="number">0xe5</span>,<span class="number">0xd4</span>,<span class="number">0xfa</span>,<span class="number">0xcb</span>,<span class="number">0x98</span>,<span class="number">0xa9</span>,<span class="number">0x3e</span>,<span class="number">0x0f</span>,<span class="number">0x5c</span>,<span class="number">0x6d</span>,</span><br><span class="line">    <span class="number">0x86</span>,<span class="number">0xb7</span>,<span class="number">0xe4</span>,<span class="number">0xd5</span>,<span class="number">0x42</span>,<span class="number">0x73</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x3f</span>,<span class="number">0x0e</span>,<span class="number">0x5d</span>,<span class="number">0x6c</span>,<span class="number">0xfb</span>,<span class="number">0xca</span>,<span class="number">0x99</span>,<span class="number">0xa8</span>,</span><br><span class="line">    <span class="number">0xc5</span>,<span class="number">0xf4</span>,<span class="number">0xa7</span>,<span class="number">0x96</span>,<span class="number">0x01</span>,<span class="number">0x30</span>,<span class="number">0x63</span>,<span class="number">0x52</span>,<span class="number">0x7c</span>,<span class="number">0x4d</span>,<span class="number">0x1e</span>,<span class="number">0x2f</span>,<span class="number">0xb8</span>,<span class="number">0x89</span>,<span class="number">0xda</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x3d</span>,<span class="number">0x0c</span>,<span class="number">0x5f</span>,<span class="number">0x6e</span>,<span class="number">0xf9</span>,<span class="number">0xc8</span>,<span class="number">0x9b</span>,<span class="number">0xaa</span>,<span class="number">0x84</span>,<span class="number">0xb5</span>,<span class="number">0xe6</span>,<span class="number">0xd7</span>,<span class="number">0x40</span>,<span class="number">0x71</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,</span><br><span class="line">    <span class="number">0x7e</span>,<span class="number">0x4f</span>,<span class="number">0x1c</span>,<span class="number">0x2d</span>,<span class="number">0xba</span>,<span class="number">0x8b</span>,<span class="number">0xd8</span>,<span class="number">0xe9</span>,<span class="number">0xc7</span>,<span class="number">0xf6</span>,<span class="number">0xa5</span>,<span class="number">0x94</span>,<span class="number">0x03</span>,<span class="number">0x32</span>,<span class="number">0x61</span>,<span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0xbb</span>,<span class="number">0x8a</span>,<span class="number">0xd9</span>,<span class="number">0xe8</span>,<span class="number">0x7f</span>,<span class="number">0x4e</span>,<span class="number">0x1d</span>,<span class="number">0x2c</span>,<span class="number">0x02</span>,<span class="number">0x33</span>,<span class="number">0x60</span>,<span class="number">0x51</span>,<span class="number">0xc6</span>,<span class="number">0xf7</span>,<span class="number">0xa4</span>,<span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0xf8</span>,<span class="number">0xc9</span>,<span class="number">0x9a</span>,<span class="number">0xab</span>,<span class="number">0x3c</span>,<span class="number">0x0d</span>,<span class="number">0x5e</span>,<span class="number">0x6f</span>,<span class="number">0x41</span>,<span class="number">0x70</span>,<span class="number">0x23</span>,<span class="number">0x12</span>,<span class="number">0x85</span>,<span class="number">0xb4</span>,<span class="number">0xe7</span>,<span class="number">0xd6</span>,</span><br><span class="line">    <span class="number">0x7a</span>,<span class="number">0x4b</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0xbe</span>,<span class="number">0x8f</span>,<span class="number">0xdc</span>,<span class="number">0xed</span>,<span class="number">0xc3</span>,<span class="number">0xf2</span>,<span class="number">0xa1</span>,<span class="number">0x90</span>,<span class="number">0x07</span>,<span class="number">0x36</span>,<span class="number">0x65</span>,<span class="number">0x54</span>,</span><br><span class="line">    <span class="number">0x39</span>,<span class="number">0x08</span>,<span class="number">0x5b</span>,<span class="number">0x6a</span>,<span class="number">0xfd</span>,<span class="number">0xcc</span>,<span class="number">0x9f</span>,<span class="number">0xae</span>,<span class="number">0x80</span>,<span class="number">0xb1</span>,<span class="number">0xe2</span>,<span class="number">0xd3</span>,<span class="number">0x44</span>,<span class="number">0x75</span>,<span class="number">0x26</span>,<span class="number">0x17</span>,</span><br><span class="line">    <span class="number">0xfc</span>,<span class="number">0xcd</span>,<span class="number">0x9e</span>,<span class="number">0xaf</span>,<span class="number">0x38</span>,<span class="number">0x09</span>,<span class="number">0x5a</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x74</span>,<span class="number">0x27</span>,<span class="number">0x16</span>,<span class="number">0x81</span>,<span class="number">0xb0</span>,<span class="number">0xe3</span>,<span class="number">0xd2</span>,</span><br><span class="line">    <span class="number">0xbf</span>,<span class="number">0x8e</span>,<span class="number">0xdd</span>,<span class="number">0xec</span>,<span class="number">0x7b</span>,<span class="number">0x4a</span>,<span class="number">0x19</span>,<span class="number">0x28</span>,<span class="number">0x06</span>,<span class="number">0x37</span>,<span class="number">0x64</span>,<span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0xf3</span>,<span class="number">0xa0</span>,<span class="number">0x91</span>,</span><br><span class="line">    <span class="number">0x47</span>,<span class="number">0x76</span>,<span class="number">0x25</span>,<span class="number">0x14</span>,<span class="number">0x83</span>,<span class="number">0xb2</span>,<span class="number">0xe1</span>,<span class="number">0xd0</span>,<span class="number">0xfe</span>,<span class="number">0xcf</span>,<span class="number">0x9c</span>,<span class="number">0xad</span>,<span class="number">0x3a</span>,<span class="number">0x0b</span>,<span class="number">0x58</span>,<span class="number">0x69</span>,</span><br><span class="line">    <span class="number">0x04</span>,<span class="number">0x35</span>,<span class="number">0x66</span>,<span class="number">0x57</span>,<span class="number">0xc0</span>,<span class="number">0xf1</span>,<span class="number">0xa2</span>,<span class="number">0x93</span>,<span class="number">0xbd</span>,<span class="number">0x8c</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x79</span>,<span class="number">0x48</span>,<span class="number">0x1b</span>,<span class="number">0x2a</span>,</span><br><span class="line">    <span class="number">0xc1</span>,<span class="number">0xf0</span>,<span class="number">0xa3</span>,<span class="number">0x92</span>,<span class="number">0x05</span>,<span class="number">0x34</span>,<span class="number">0x67</span>,<span class="number">0x56</span>,<span class="number">0x78</span>,<span class="number">0x49</span>,<span class="number">0x1a</span>,<span class="number">0x2b</span>,<span class="number">0xbc</span>,<span class="number">0x8d</span>,<span class="number">0xde</span>,<span class="number">0xef</span>,</span><br><span class="line">    <span class="number">0x82</span>,<span class="number">0xb3</span>,<span class="number">0xe0</span>,<span class="number">0xd1</span>,<span class="number">0x46</span>,<span class="number">0x77</span>,<span class="number">0x24</span>,<span class="number">0x15</span>,<span class="number">0x3b</span>,<span class="number">0x0a</span>,<span class="number">0x59</span>,<span class="number">0x68</span>,<span class="number">0xff</span>,<span class="number">0xce</span>,<span class="number">0x9d</span>,<span class="number">0xac</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>采用查表法计算crc代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">cal_crc_table</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr, <span class="keyword">unsigned</span> <span class="keyword">char</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  crc = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">    &#123;</span><br><span class="line">        crc = crc_table[crc ^ *ptr++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (crc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-反序异或计算的代码"><a href="#2-4-反序异或计算的代码" class="headerlink" title="2.4 反序异或计算的代码"></a>2.4 反序异或计算的代码</h2><p>&emsp;&emsp;反序异或与顺序异或差异在数据先判断最低位，并且数据是向右移的，并且多项式数据位需要高低位反转一下。还是以多项式：x8+x5+x4+1（二进制为：100110001）为例：则计算一个字节的crc校验代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">cal_table_low_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i, crc;</span><br><span class="line"></span><br><span class="line">    crc = value;</span><br><span class="line">    <span class="comment">/* 同样需要计算8次 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">8</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x01</span>)  <span class="comment">/* 反序异或变成判断最低位是否为1 */</span></span><br><span class="line">            <span class="comment">/* 数据变成往右移位了 */</span></span><br><span class="line">            <span class="comment">/* 计算的多项式从0x31（0011 0001）变成了0x8C (1000 1100) */</span></span><br><span class="line">    <span class="comment">/* 多项式值，原来的最高位变成了最低位，原来的最低位变成最高位，8位数据高低位交换一下位置 */</span></span><br><span class="line">            crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x8C</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            crc = (crc &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、例程：Modbus的CRC16校验"><a href="#三、例程：Modbus的CRC16校验" class="headerlink" title="三、例程：Modbus的CRC16校验"></a>三、例程：Modbus的CRC16校验</h1><p>&emsp;&emsp;代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> UCHAR aucCRCHi[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> UCHAR aucCRCLo[] = &#123;</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x01</span>, <span class="number">0xC3</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0xC2</span>, <span class="number">0xC6</span>, <span class="number">0x06</span>, <span class="number">0x07</span>, <span class="number">0xC7</span>,</span><br><span class="line">    <span class="number">0x05</span>, <span class="number">0xC5</span>, <span class="number">0xC4</span>, <span class="number">0x04</span>, <span class="number">0xCC</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0xCD</span>, <span class="number">0x0F</span>, <span class="number">0xCF</span>, <span class="number">0xCE</span>, <span class="number">0x0E</span>,</span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0xCA</span>, <span class="number">0xCB</span>, <span class="number">0x0B</span>, <span class="number">0xC9</span>, <span class="number">0x09</span>, <span class="number">0x08</span>, <span class="number">0xC8</span>, <span class="number">0xD8</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0xD9</span>,</span><br><span class="line">    <span class="number">0x1B</span>, <span class="number">0xDB</span>, <span class="number">0xDA</span>, <span class="number">0x1A</span>, <span class="number">0x1E</span>, <span class="number">0xDE</span>, <span class="number">0xDF</span>, <span class="number">0x1F</span>, <span class="number">0xDD</span>, <span class="number">0x1D</span>, <span class="number">0x1C</span>, <span class="number">0xDC</span>,</span><br><span class="line">    <span class="number">0x14</span>, <span class="number">0xD4</span>, <span class="number">0xD5</span>, <span class="number">0x15</span>, <span class="number">0xD7</span>, <span class="number">0x17</span>, <span class="number">0x16</span>, <span class="number">0xD6</span>, <span class="number">0xD2</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0xD3</span>,</span><br><span class="line">    <span class="number">0x11</span>, <span class="number">0xD1</span>, <span class="number">0xD0</span>, <span class="number">0x10</span>, <span class="number">0xF0</span>, <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0xF1</span>, <span class="number">0x33</span>, <span class="number">0xF3</span>, <span class="number">0xF2</span>, <span class="number">0x32</span>,</span><br><span class="line">    <span class="number">0x36</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0x37</span>, <span class="number">0xF5</span>, <span class="number">0x35</span>, <span class="number">0x34</span>, <span class="number">0xF4</span>, <span class="number">0x3C</span>, <span class="number">0xFC</span>, <span class="number">0xFD</span>, <span class="number">0x3D</span>,</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x3E</span>, <span class="number">0xFE</span>, <span class="number">0xFA</span>, <span class="number">0x3A</span>, <span class="number">0x3B</span>, <span class="number">0xFB</span>, <span class="number">0x39</span>, <span class="number">0xF9</span>, <span class="number">0xF8</span>, <span class="number">0x38</span>, </span><br><span class="line">    <span class="number">0x28</span>, <span class="number">0xE8</span>, <span class="number">0xE9</span>, <span class="number">0x29</span>, <span class="number">0xEB</span>, <span class="number">0x2B</span>, <span class="number">0x2A</span>, <span class="number">0xEA</span>, <span class="number">0xEE</span>, <span class="number">0x2E</span>, <span class="number">0x2F</span>, <span class="number">0xEF</span>,</span><br><span class="line">    <span class="number">0x2D</span>, <span class="number">0xED</span>, <span class="number">0xEC</span>, <span class="number">0x2C</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0xE5</span>, <span class="number">0x27</span>, <span class="number">0xE7</span>, <span class="number">0xE6</span>, <span class="number">0x26</span>,</span><br><span class="line">    <span class="number">0x22</span>, <span class="number">0xE2</span>, <span class="number">0xE3</span>, <span class="number">0x23</span>, <span class="number">0xE1</span>, <span class="number">0x21</span>, <span class="number">0x20</span>, <span class="number">0xE0</span>, <span class="number">0xA0</span>, <span class="number">0x60</span>, <span class="number">0x61</span>, <span class="number">0xA1</span>,</span><br><span class="line">    <span class="number">0x63</span>, <span class="number">0xA3</span>, <span class="number">0xA2</span>, <span class="number">0x62</span>, <span class="number">0x66</span>, <span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0x67</span>, <span class="number">0xA5</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0xA4</span>,</span><br><span class="line">    <span class="number">0x6C</span>, <span class="number">0xAC</span>, <span class="number">0xAD</span>, <span class="number">0x6D</span>, <span class="number">0xAF</span>, <span class="number">0x6F</span>, <span class="number">0x6E</span>, <span class="number">0xAE</span>, <span class="number">0xAA</span>, <span class="number">0x6A</span>, <span class="number">0x6B</span>, <span class="number">0xAB</span>, </span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0xA9</span>, <span class="number">0xA8</span>, <span class="number">0x68</span>, <span class="number">0x78</span>, <span class="number">0xB8</span>, <span class="number">0xB9</span>, <span class="number">0x79</span>, <span class="number">0xBB</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0xBA</span>,</span><br><span class="line">    <span class="number">0xBE</span>, <span class="number">0x7E</span>, <span class="number">0x7F</span>, <span class="number">0xBF</span>, <span class="number">0x7D</span>, <span class="number">0xBD</span>, <span class="number">0xBC</span>, <span class="number">0x7C</span>, <span class="number">0xB4</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0xB5</span>,</span><br><span class="line">    <span class="number">0x77</span>, <span class="number">0xB7</span>, <span class="number">0xB6</span>, <span class="number">0x76</span>, <span class="number">0x72</span>, <span class="number">0xB2</span>, <span class="number">0xB3</span>, <span class="number">0x73</span>, <span class="number">0xB1</span>, <span class="number">0x71</span>, <span class="number">0x70</span>, <span class="number">0xB0</span>,</span><br><span class="line">    <span class="number">0x50</span>, <span class="number">0x90</span>, <span class="number">0x91</span>, <span class="number">0x51</span>, <span class="number">0x93</span>, <span class="number">0x53</span>, <span class="number">0x52</span>, <span class="number">0x92</span>, <span class="number">0x96</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x97</span>,</span><br><span class="line">    <span class="number">0x55</span>, <span class="number">0x95</span>, <span class="number">0x94</span>, <span class="number">0x54</span>, <span class="number">0x9C</span>, <span class="number">0x5C</span>, <span class="number">0x5D</span>, <span class="number">0x9D</span>, <span class="number">0x5F</span>, <span class="number">0x9F</span>, <span class="number">0x9E</span>, <span class="number">0x5E</span>,</span><br><span class="line">    <span class="number">0x5A</span>, <span class="number">0x9A</span>, <span class="number">0x9B</span>, <span class="number">0x5B</span>, <span class="number">0x99</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x98</span>, <span class="number">0x88</span>, <span class="number">0x48</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x4B</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x4A</span>, <span class="number">0x4E</span>, <span class="number">0x8E</span>, <span class="number">0x8F</span>, <span class="number">0x4F</span>, <span class="number">0x8D</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>, <span class="number">0x8C</span>,</span><br><span class="line">    <span class="number">0x44</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0x87</span>, <span class="number">0x47</span>, <span class="number">0x46</span>, <span class="number">0x86</span>, <span class="number">0x82</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x83</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x81</span>, <span class="number">0x80</span>, <span class="number">0x40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USHORT</span><br><span class="line">usMBCRC16( UCHAR * pucFrame, USHORT usLen )</span><br><span class="line">&#123;</span><br><span class="line">    UCHAR           ucCRCHi = <span class="number">0xFF</span>;</span><br><span class="line">    UCHAR           ucCRCLo = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">int</span>             iIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( usLen-- )</span><br><span class="line">    &#123;</span><br><span class="line">        iIndex = ucCRCLo ^ *( pucFrame++ );</span><br><span class="line">        ucCRCLo = ( UCHAR )( ucCRCHi ^ aucCRCHi[iIndex] );</span><br><span class="line">        ucCRCHi = aucCRCLo[iIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ( USHORT )( ucCRCHi &lt;&lt; <span class="number">8</span> | ucCRCLo );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里提一下各种通讯协议都经常使用的CRC校验，为后面的知识做铺垫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="校验" scheme="http://shatang.github.io/tags/%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>128个字符的ASCII码表</title>
    <link href="http://shatang.github.io/2020/06/28/128%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84ASCII%E7%A0%81%E8%A1%A8/"/>
    <id>http://shatang.github.io/2020/06/28/128个字符的ASCII码表/</id>
    <published>2020-06-28T02:02:43.000Z</published>
    <updated>2020-06-28T02:11:37.541Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里复习、细讲ASCII码表，为后面的知识做铺垫。</p><a id="more"></a><h1 id="一、128个字符的ASCII码表"><a href="#一、128个字符的ASCII码表" class="headerlink" title="一、128个字符的ASCII码表"></a>一、128个字符的ASCII码表</h1><p>&emsp;&emsp;重新认识一下128字符的ASCII码表。<strong>基础ascii码值最大值是0x7f=127，扩展ascii码值最大值是0xFF=255。</strong></p><table><thead><tr><th>Dec</th><th>Hex</th><th>缩写/字符</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>1</td><td>01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>2</td><td>02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>3</td><td>03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>4</td><td>04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>5</td><td>05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>6</td><td>06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>7</td><td>07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>8</td><td>08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>9</td><td>09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>10</td><td>0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>11</td><td>0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>12</td><td>0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>13</td><td>0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>14</td><td>0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>15</td><td>0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>16</td><td>10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>17</td><td>11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>18</td><td>12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>19</td><td>13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>20</td><td>14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>21</td><td>15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>22</td><td>16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>23</td><td>17</td><td>ETB (end of trans. block)</td><td>传输块结束</td></tr><tr><td>24</td><td>18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>25</td><td>19</td><td>EM (end of medium)</td><td>介质中断</td></tr><tr><td>26</td><td>1A</td><td>SUB (substitute)</td><td>替补</td></tr><tr><td>27</td><td>1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>28</td><td>1C</td><td>FS (file separator)</td><td>文件分割符</td></tr><tr><td>29</td><td>1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>30</td><td>1E</td><td>RS (record separator)</td><td>记录分离符</td></tr><tr><td>31</td><td>1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>32</td><td>20</td><td>(space)</td><td>空格</td></tr><tr><td>33</td><td>21</td><td>!</td><td></td></tr><tr><td>34</td><td>22</td><td>“</td><td></td></tr><tr><td>35</td><td>23</td><td>#</td><td></td></tr><tr><td>36</td><td>24</td><td>$</td><td></td></tr><tr><td>37</td><td>25</td><td>%</td><td></td></tr><tr><td>38</td><td>26</td><td>&amp;</td><td></td></tr><tr><td>39</td><td>27</td><td>‘</td><td></td></tr><tr><td>40</td><td>28</td><td>(</td><td></td></tr><tr><td>41</td><td>29</td><td>)</td><td></td></tr><tr><td>42</td><td>2A</td><td>*</td><td></td></tr><tr><td>43</td><td>2B</td><td>+</td><td></td></tr><tr><td>44</td><td>2C</td><td>,</td><td></td></tr><tr><td>45</td><td>2D</td><td>-</td><td></td></tr><tr><td>46</td><td>2E</td><td>.</td><td></td></tr><tr><td>47</td><td>2F</td><td>/</td><td></td></tr><tr><td>48</td><td>30</td><td>0</td><td></td></tr><tr><td>49</td><td>31</td><td>1</td><td></td></tr><tr><td>50</td><td>32</td><td>2</td><td></td></tr><tr><td>51</td><td>33</td><td>3</td><td></td></tr><tr><td>52</td><td>34</td><td>4</td><td></td></tr><tr><td>53</td><td>35</td><td>5</td><td></td></tr><tr><td>54</td><td>36</td><td>6</td><td></td></tr><tr><td>55</td><td>37</td><td>7</td><td></td></tr><tr><td>56</td><td>38</td><td>8</td><td></td></tr><tr><td>57</td><td>39</td><td>9</td><td></td></tr><tr><td>58</td><td>3A</td><td>:</td><td></td></tr><tr><td>59</td><td>3B</td><td>;</td><td></td></tr><tr><td>60</td><td>3C</td><td>&lt;</td><td></td></tr><tr><td>61</td><td>3D</td><td>=</td><td></td></tr><tr><td>62</td><td>3E</td><td>&gt;</td><td></td></tr><tr><td>63</td><td>3F</td><td>?</td><td></td></tr><tr><td>64</td><td>40</td><td>@</td><td></td></tr><tr><td>65</td><td>41</td><td>A</td><td></td></tr><tr><td>66</td><td>42</td><td>B</td><td></td></tr><tr><td>67</td><td>43</td><td>C</td><td></td></tr><tr><td>68</td><td>44</td><td>D</td><td></td></tr><tr><td>69</td><td>45</td><td>E</td><td></td></tr><tr><td>70</td><td>46</td><td>F</td><td></td></tr><tr><td>71</td><td>47</td><td>G</td><td></td></tr><tr><td>72</td><td>48</td><td>H</td><td></td></tr><tr><td>73</td><td>49</td><td>I</td><td></td></tr><tr><td>74</td><td>4A</td><td>J</td><td></td></tr><tr><td>75</td><td>4B</td><td>K</td><td></td></tr><tr><td>76</td><td>4C</td><td>L</td><td></td></tr><tr><td>77</td><td>4D</td><td>M</td><td></td></tr><tr><td>78</td><td>4E</td><td>N</td><td></td></tr><tr><td>79</td><td>4F</td><td>O</td><td></td></tr><tr><td>80</td><td>50</td><td>P</td><td></td></tr><tr><td>81</td><td>51</td><td>Q</td><td></td></tr><tr><td>82</td><td>52</td><td>R</td><td></td></tr><tr><td>83</td><td>53</td><td>S</td><td></td></tr><tr><td>84</td><td>54</td><td>T</td><td></td></tr><tr><td>85</td><td>55</td><td>U</td><td></td></tr><tr><td>86</td><td>56</td><td>V</td><td></td></tr><tr><td>87</td><td>57</td><td>W</td><td></td></tr><tr><td>88</td><td>58</td><td>X</td><td></td></tr><tr><td>89</td><td>59</td><td>Y</td><td></td></tr><tr><td>90</td><td>5A</td><td>Z</td><td></td></tr><tr><td>91</td><td>5B</td><td>[</td><td></td></tr><tr><td>92</td><td>5C</td><td>\</td><td></td></tr><tr><td>93</td><td>5D</td><td>]</td><td></td></tr><tr><td>94</td><td>5E</td><td>^</td><td></td></tr><tr><td>95</td><td>5F</td><td>_</td><td></td></tr><tr><td>96</td><td>60</td><td>`</td><td></td></tr><tr><td>97</td><td>61</td><td>a</td><td></td></tr><tr><td>98</td><td>62</td><td>b</td><td></td></tr><tr><td>99</td><td>63</td><td>c</td><td></td></tr><tr><td>100</td><td>64</td><td>d</td><td></td></tr><tr><td>101</td><td>65</td><td>e</td><td></td></tr><tr><td>102</td><td>66</td><td>f</td><td></td></tr><tr><td>103</td><td>67</td><td>g</td><td></td></tr><tr><td>104</td><td>68</td><td>h</td><td></td></tr><tr><td>105</td><td>69</td><td>i</td><td></td></tr><tr><td>106</td><td>6A</td><td>j</td><td></td></tr><tr><td>107</td><td>6B</td><td>k</td><td></td></tr><tr><td>108</td><td>6C</td><td>l</td><td></td></tr><tr><td>109</td><td>6D</td><td>m</td><td></td></tr><tr><td>110</td><td>6E</td><td>n</td><td></td></tr><tr><td>111</td><td>6F</td><td>o</td><td></td></tr><tr><td>112</td><td>70</td><td>p</td><td></td></tr><tr><td>113</td><td>71</td><td>q</td><td></td></tr><tr><td>114</td><td>72</td><td>r</td><td></td></tr><tr><td>115</td><td>73</td><td>s</td><td></td></tr><tr><td>116</td><td>74</td><td>t</td><td></td></tr><tr><td>117</td><td>75</td><td>u</td><td></td></tr><tr><td>118</td><td>76</td><td>v</td><td></td></tr><tr><td>119</td><td>77</td><td>w</td><td></td></tr><tr><td>120</td><td>78</td><td>x</td><td></td></tr><tr><td>121</td><td>79</td><td>y</td><td></td></tr><tr><td>122</td><td>7A</td><td>z</td><td></td></tr><tr><td>123</td><td>7B</td><td>{</td><td></td></tr><tr><td>124</td><td>7C</td><td>|</td><td></td></tr><tr><td>125</td><td>7D</td><td>}</td><td></td></tr><tr><td>126</td><td>7E</td><td>~</td><td></td></tr><tr><td>127</td><td>7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table><h1 id="二、ASCII码表带来的现象"><a href="#二、ASCII码表带来的现象" class="headerlink" title="二、ASCII码表带来的现象"></a>二、ASCII码表带来的现象</h1><h2 id="2-1-Modbus协议模式选择"><a href="#2-1-Modbus协议模式选择" class="headerlink" title="2.1 Modbus协议模式选择"></a>2.1 Modbus协议模式选择</h2><p>&emsp;&emsp;在Modbus通讯协议中，分为RTU &amp; ASCII 模式。在底层的串口配置中，RTU模式只能配置 8-e-1，8-o-1,8-n-1的8位数据位；而ASCII模式不仅可以配置以上的模式，还可以配置7-e-1，7-o-1，7-n-1。</p><p>这里的原因，就是因为ASCII基本码就是128个，完全(刚好)能用7个bit来表示。而RTU发送十六进制的数据，则需要8个bit(0xff)，被去掉了一位，因为是不支持7位的数据位发送。</p><p>&emsp;&emsp;这里又暗示了串口的一个理解上的误区。<strong>串口发送的最小单位</strong>和<strong>数据帧的最小单位</strong>。假如串口模式是7位的数据位，你发的是数据基本单位是0xff(8bit)；例如你发 0xff 0x12 0x34 ，此时串口会截取掉高位，只发每个数据单元的7bit。不会说这先发这个数据的7bit，多出来的 1bit 下次再填进去补给你(下次一定)。</p><h2 id="2-2-中文字符乱码"><a href="#2-2-中文字符乱码" class="headerlink" title="2.2 中文字符乱码"></a>2.2 中文字符乱码</h2><p>&emsp;&emsp;从上面延伸出来的串口发送知识误区，得到一种 中文字符乱码 的现象。假如一个产品，有中英文，可以通过串口打印出数据；你会发现一旦串口配置为7位数据位，英文版本打印正常，而中文版本打印异常。</p><p>这就是因为汉字是双字的，拆分出来两个8bit(0xff)，假如串口使用7位的数据位，就会截取掉高位；而英文是ASCII，只需要7bit，因此英文显示正常。</p><h2 id="2-3-对字符的解析"><a href="#2-3-对字符的解析" class="headerlink" title="2.3 对字符的解析"></a>2.3 对字符的解析</h2><p>&emsp;&emsp;常见于几种情况，举例如下：</p><ol><li>制作裸机不带enwin的嵌入式led驱动</li><li>与GSM模块等通讯</li><li>通讯协议的数据包的识别区分(例如X-modem协议)</li></ol><hr><p>&emsp;&emsp;led驱动的字符显示驱动，把要显示的字符串，截取成逐个的字符，做显示；显示会做判断两种情况，:</p><ul><li>*s &lt; 128 , 显示ASCII码库的字符</li><li>*s &gt; 128 , 显示自己写的(汉字)库的字符(汉字双字节 0xffff 明显超过 0x7f)</li></ul><hr><p>&emsp;&emsp;与GSM模块进行通讯配置的时候，而且这种通讯是字符的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="keyword">uint32_t</span>)cmd&lt;=<span class="number">0XFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((USART3-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//等待上一次数据发送完成  </span></span><br><span class="line">        USART3-&gt;DR=(u32)cmd;</span><br><span class="line">    &#125;<span class="keyword">else</span> u3_printf(<span class="string">"%s\r\n"</span>,cmd);<span class="comment">//发送命令</span></span><br></pre></td></tr></table></figure><p>如果是有写过类似GSM模块通讯的，应该都看过类似上面语句。主控发给模块的指令，先分解逐个字符；再根据是否小于0xff，是直接发还是用字符串打印函数。</p><p>&emsp;&emsp;如果是小于0xff，当然是可以用串口8位的数据位进行发送；但是什么时候才会大于0xff，就是该 cmd 非ASCII的时候(而是字符串)，例如汉字。</p><hr><p>&emsp;&emsp;X-modem协议的数据包的识别区分。当利用Xmodem协议进行传输文本文件，因为数据包的结束符 CTRL-Z(0x1A) 不是前128个ascii码中的通用可见字母字符( 0x1A 对应 SUB[替补]，非文本文件的字符 )。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里复习、细讲ASCII码表，为后面的知识做铺垫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符编码" scheme="http://shatang.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>大数据割韭菜法</title>
    <link href="http://shatang.github.io/2020/06/25/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%89%B2%E9%9F%AD%E8%8F%9C%E6%B3%95/"/>
    <id>http://shatang.github.io/2020/06/25/大数据割韭菜法/</id>
    <published>2020-06-25T03:37:21.000Z</published>
    <updated>2020-06-25T03:39:59.605Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;现在的大数据杀熟是一件常见的事，更有一些大佬们呕心沥血的算法加持下；我觉得只要数据足够多，那么它就能做到很多匪夷所思、神奇的事情。但是巧妇难为无米之炊，那些数据到底是哪里来的呢？</p><a id="more"></a><p>&emsp;&emsp;以前根据自己的分析，怀疑是输入法、浏览记录导致信息泄漏，进而看见那些广告推送。直到看半佛老师的：<a href="https://www.bilibili.com/video/BV1SC4y1a7k5" target="_blank" rel="noopener">你的手机是如何监控你的</a>，开拓了我不少眼界，例如唤醒监控、推送SDK同家公司等，也让我对其更深的理解。</p><h1 id="一、半佛老师的视频笔记总结"><a href="#一、半佛老师的视频笔记总结" class="headerlink" title="一、半佛老师的视频笔记总结"></a>一、半佛老师的视频笔记总结</h1><h2 id="1-1-信息泄漏基本不会来源于录音，但是会识别关键词"><a href="#1-1-信息泄漏基本不会来源于录音，但是会识别关键词" class="headerlink" title="1.1 信息泄漏基本不会来源于录音，但是会识别关键词"></a>1.1 信息泄漏基本不会来源于录音，但是会识别关键词</h2><ul><li>信息泄漏基本不会来源于(手机)录音：效率低，利润低，误差率高，成本高<ul><li>(某APP)持续录音，会对手机内存的占用；现象：发热，卡，且容易被杀掉进程和检测出来</li><li>录下来的音频存放点。存放本地存储，长时间占用太大；将其使用流量上传，但流量并非免费</li><li>将其录下来的音频转换成文字保存或直接上传，则会遇到下面问题：语音识别误差率大</li><li>语音识别误差率大，分辨不出是谁在讲话，而且语音不标准(即口音)。还有语义问题，不同场景，同一句湖就是不同意思</li></ul></li><li>不做录音。但是真的有时候就是没有浏览只是日常讲话提及，随之会出现在广告推送。<ul><li>通过特定的关键词唤醒监控。<ul><li>常见的唤醒方案：小爱，siri。所以有些app要求录音权限 ，可用于唤醒监控</li></ul></li><li>只做关键词，无论是直接上传还是识别度都是操作相对简单很多</li></ul></li></ul><p><strong><font color="red">Ps：</font></strong> 注意手机的App，对其录音的权限是否关闭</p><h2 id="1-2-输入法"><a href="#1-2-输入法" class="headerlink" title="1.2 输入法"></a>1.2 输入法</h2><ul><li>输入法，只要打字，就离不开输入法。<ul><li>纯文本的语意分析，那可是相对成熟的技术。</li><li>另外所有的输入法都是越用月好用，越用越懂你。</li><li>那么，到底是怎么懂你的呢？当你在触摸方便之门的时候，方便也在触摸着你</li></ul></li></ul><p><strong><font color="red">Ps：</font></strong> 建议关闭输入法用户体验计划？最好禁用其联网</p><h2 id="1-3-推送类sdk"><a href="#1-3-推送类sdk" class="headerlink" title="1.3 推送类sdk"></a>1.3 推送类sdk</h2><ul><li>现在各种手机推送大都是专门有公司做成sdk嵌入到各大app里面的，然后专门做推送。<ul><li>做推送的，往往对于各类手机和应用的适配做得比较好；比App自己开发要好用很多。</li><li>所以很多app都是使用外采推送sdk的，不然市面上这么多的手机型号，自己还要一个一个去适配，还要去实验规则。</li><li>假如你手机上有30个app，它可能背后都归属于同一家或者是多家公司提供的推送sdk(<strong>推送类SDK核心威力所在</strong>)</li></ul></li></ul><p>&emsp;&emsp;常见的信息泄漏，最基础的就是：App请求获取你的应用列表。它可以根据你装的App来分析你到底是什么用户；而且有没有同行App之类在里面，再根据结果推荐不同的推荐策略。</p><p>&emsp;&emsp;但是对于推送SDK公司而言，它甚至可以不需要获取你的应用列表，因为你装的App很多都加载了它的推送SDK。你的手机信息是可以被获取的，而且很显然会知道一台手机到底装了哪些app；用户常用那些app，甚至用户对于手机的应用轨迹和应用行为。</p><h2 id="1-4-App的信息收集"><a href="#1-4-App的信息收集" class="headerlink" title="1.4 App的信息收集"></a>1.4 App的信息收集</h2><p>&emsp;&emsp;手机app的信息收集，例如上面的获取手机Applist。举例如下：</p><ul><li>Applist 有 x多多，该用户为价格敏感性</li><li>Applist 有 x哩x哩，可能是个年轻二次元用户</li><li>通过读取applist，该用户有多个同行App，就发大额优惠券拉拢用户；反之垄断则考虑割韭菜</li><li>读取地理位置信息，对应的推荐策略</li></ul><p><strong><font color="red">Ps：</font></strong> 建议尽可能禁掉获取Applist的权限，只留一些基本App</p><h2 id="1-5-浏览记录，搜索记录"><a href="#1-5-浏览记录，搜索记录" class="headerlink" title="1.5 浏览记录，搜索记录"></a>1.5 浏览记录，搜索记录</h2><p>&emsp;&emsp;最表层的，你在pc和手机端app搜索记录。<strong>大家都在收集这些记录，而且很热衷</strong>，都是用来相互交易，明码标价；而且app是绑定手机号的，你的每次搜索记录都会转换成市面的数据包进行交易。</p><p><strong><font color="red">Ps：</font></strong> 无痕浏览只是不保存记录在本地上，网络上是有你的搜索记录的</p><h2 id="1-6-数据糅合推送"><a href="#1-6-数据糅合推送" class="headerlink" title="1.6 数据糅合推送"></a>1.6 数据糅合推送</h2><p>&emsp;&emsp;即使是你尽可能谨慎，少泄漏信息；但是有时候你就是能收到贴心的广告推送。这个推荐策略，并非来自你的信息泄漏，而是周边人信息的泄漏。只要你周边的信息足够多，就能够反推出对你的推荐策略。</p><p>&emsp;&emsp;例如你是小明，那么你的广告推送有部分决策来源于，小明朋友的相关数据、小明小红父母的相关数据。例如小红怀孕，搜索母婴用品；自然小明那边就可能推送母婴用品等的广告。</p><h1 id="二、我的经历和看法"><a href="#二、我的经历和看法" class="headerlink" title="二、我的经历和看法"></a>二、我的经历和看法</h1><h2 id="2-1-看法"><a href="#2-1-看法" class="headerlink" title="2.1 看法"></a>2.1 看法</h2><p>&emsp;&emsp;尽可能上面看起来比较骇人听闻，把每个人的生活经历、决策、不确定性的未来都划出一块一块的数据，但是大家也不要太过担心。毕竟大数据就是大数据，会尽可能把数据抽象、封装，不会完全针对个人；不会说专门从大数据中，抽取具体个人所有的信息并呈现出来，成本太高，普通人是不会有多少问题，还是能平平凡凡渡过一生。</p><ul><li>大数据的获取和处理还是有一定限制(阻力)的，不然现在贪污腐败都能够分析处理完的。</li><li>大数据的数据并非是一块完整区域，而是很多大的信息孤岛<ul><li>大的 手机厂商、App，假如它有获取你信息的方法，它基本也不会贩卖给市场；毕竟这是自己一手的资源，不需要贪图点小钱，而是为后面市场(垄断)开拓做准备</li><li>信息孤岛，则对你的影响力就不是特别特别大；毕竟数据糅合多起来，对你的理解不是加法，是乘法</li></ul></li></ul><h2 id="2-2-观察到的现象"><a href="#2-2-观察到的现象" class="headerlink" title="2.2 观察到的现象"></a>2.2 观察到的现象</h2><p>&emsp;&emsp;现在目前的情况，感觉输入法泄漏比较多。不过我也有些疑惑和观察一些现象：</p><ul><li>跟人x信聊天，聊到一句话夹杂：”养猫”，没说过对应的话；一两分钟后，广告推送前两条是猫了！才逐渐推出来输入法有信息泄漏的问题(x信不会要这点小钱，数据应该是留给自己用)</li><li>有时候不解，广告推送老是推 switch 给我，我一开始以为是哪位亲朋好友的记录，想到上面养猫的输入法泄漏，以及敲C代码用到的 switch语句，一切就豁然开朗了</li><li>举个常见例子，你手机链接朋友手机开热点，搜索东西；后面朋友就会收到近似的广告推送嘛；这很正常，就锁定IP嘛</li><li>但是你在PC端，公司局域网，和自己家里私有网络，两台PC的广告推送竟然是一模一样的；那么也就是说，广告推送识别出来这两台电脑的用户都是我；要知道局域网，是只有一个真实IP的，里面都是虚拟IP，也就是说它能整出局域网虚拟IP里面的人到底是谁</li><li>在公司的不同电脑，查询广告推送，每个人都是有各自的特点；也就是反过来验证了，广告推送能越过 真实IP 查出 虚拟IP 的用户本人</li><li>如果是注意观察广告推送，要么不智能像傻子一样，一直推广固定几样；如果是智能的，那么推广给你的，大致相同；<ul><li>也就是说背后的(智能)广告推送，基本可能是来源于同一、两家；</li><li>或者是数据被一个信息市场公开贩卖，但是可能性不大，因为你一搜索就会及时更新广告推送(所以广告大致相同，但不会完全一样)</li><li>我觉得应该是一两家，数量大于 1 则可能公司之间存在(韭菜)信息共享</li></ul></li></ul><p>&emsp;&emsp;到现在，我都不知道它怎么知道虚拟IP的用户是谁。很有可能是通过某些能过识别用户的进程，反过来知道用户；而且这个用户注册是要用手机等(映射出身份证号)，例如x信</p><h2 id="2-3-经历：你见过的大数据处理够早的应用是什么时候呢？"><a href="#2-3-经历：你见过的大数据处理够早的应用是什么时候呢？" class="headerlink" title="2.3 经历：你见过的大数据处理够早的应用是什么时候呢？"></a>2.3 经历：你见过的大数据处理够早的应用是什么时候呢？</h2><p>&emsp;&emsp;讲一个真实发生的故事。那你见过的大数据处理够早的应用是什么时候呢？我见过的大数据处理，是我高三的时候，应该是2015年吧？</p><p>&emsp;&emsp;那个时候，x信有流行小黄鸡，一个聊天的机器人，而且很多层次不齐的版本。有些版本则是上面会有一条广告推送，那时候我有个同学在玩(我没手机)，一条广告推送大黄鸡，也是聊天机器人，但号称更了解你(还能充VIP好像)，加了后是一个公众号。</p><p>&emsp;&emsp;小黄鸡回复消息很快，但是你懂得，就是弱智AI；但是那个大黄鸡不一样，你问它一句话，它保底等待30s，甚至好几分钟才能回答你的问题。你可以问它，问题如下：</p><ul><li>你是谁。它能够回答出来你的名字！</li><li>xx人怎么样。它能回答出中间夹杂 xx的(qq空间活跃过的)经历的答案</li><li>xx是谁。它回复是上一次统考她的成绩排名</li><li>每次问它问题，它都会回复当前具体的询问它问题的在线人数，然后再提示要等多久(文字表达是：稍等几分钟，耐心等待)</li></ul><p>&emsp;&emsp;还有好多问题(忘了)，它竟然都能回答有模有样，比搜索引擎夸张多了。现在回头想想，其实你的信息早就在很早的时期已经被挖差不多了= = ；那时候应该是爬虫抓的数据？？？但是也至少有了大数据处理的雏形(或者是已经有进入消费领域的能力)？</p><p>&emsp;&emsp;那时候就玩了3-4天，那个大黄鸡公众号就被封了。再搜类似的也没有一样的效果的公众号，回去蹲那个小黄鸡的广告推送，也再没看到了；就这样成了回忆。</p><h2 id="2-4-反推"><a href="#2-4-反推" class="headerlink" title="2.4 反推"></a>2.4 反推</h2><ul><li>苦中作乐，当你收到广告的时候，你甚至可以去尝试分析到底是哪个卖了你；</li><li>当你想了解一个人，甚至不需要查历史记录，还是有没有隐藏文件；打开他的电脑，找个有推送广告的网站简单瞄一眼，你就能获取到关于他、关于他周边人的一些大数据；然后反推来源、原因，就能掌握他一些动态，相当于你对数据又进行一遍加工处理(当然我只是提提，不建议大家这样搞；也不建议电脑给别人用)</li></ul><p>&emsp;&emsp;我还是比较喜欢半佛老师在视频讲的一句话，在结尾，用它来收尾吧：<strong>当一个产品本身不需要你做任何东西，甚至还能占点便宜的时候；只有一种可能，你自己就是商品本身。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;现在的大数据杀熟是一件常见的事，更有一些大佬们呕心沥血的算法加持下；我觉得只要数据足够多，那么它就能做到很多匪夷所思、神奇的事情。但是巧妇难为无米之炊，那些数据到底是哪里来的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>我的博客都快成日记了?</title>
    <link href="http://shatang.github.io/2020/06/14/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%83%BD%E5%BF%AB%E6%88%90%E6%97%A5%E8%AE%B0%E4%BA%86/"/>
    <id>http://shatang.github.io/2020/06/14/我的博客都快成日记了/</id>
    <published>2020-06-14T01:41:14.000Z</published>
    <updated>2020-06-25T03:39:56.248Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近思考了一下自己博客的写法。每次写博客总是想着，写全写细，多写写自己对xx知识的看法、偏重点。</p><p>&emsp;&emsp;但是有时候写总有点小烂尾，或者回过头来感觉还是写缺了点啥；后面补完，又因为感觉修改完篇幅太大，要分成上和下。把旧博删了，然后又纠结上和下怎么分= =</p><p>&emsp;&emsp;关键是就算分了上下，可能后面还是要修改，可能还要再删旧博，感觉头就很大。</p><p>&emsp;&emsp;然后又因为想要写(总结)得比较全，然后其中有个小地方、某一块可能还没做(实践)，整篇博客就被拖后腿，发不了。有一种跨步太大扯到蛋的感觉。</p><p>缺点总结：</p><ul><li>旧博客感觉不太好拓展更新</li><li>博客重新更新时，有可能要删除旧博再更新</li><li>博客要写全时，被某个知识点拖累，写不全，发不出来</li><li>上传、浏览要翻墙才会快点</li><li>以上原因打击了我用这个工具写博客的动力(而且还加成 懒 的debuff)</li></ul><p>&emsp;&emsp;所以，以后的话，我打算有哪些知识点想写、想总结，我就直接写完上传；可能是不大的知识点，但是会在需要这个知识点的地方，相互附上文章链接，加深知识点应用。这样的话，每个知识点更新就很方便，拓展性也会好多了。</p><p>&emsp;&emsp;以后的日子，还是多多请教。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近思考了一下自己博客的写法。每次写博客总是想着，写全写细，多写写自己对xx知识的看法、偏重点。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;但是有时候写总有点小烂尾，或者回过头来感觉还是写缺了点啥；后面补完，又因为感觉修改完篇幅太大，要分成上和下。把旧博
      
    
    </summary>
    
    
      <category term="生活" scheme="http://shatang.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Keil制作自己的lib</title>
    <link href="http://shatang.github.io/2020/05/30/Keil%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84lib/"/>
    <id>http://shatang.github.io/2020/05/30/Keil制作自己的lib/</id>
    <published>2020-05-30T04:42:06.000Z</published>
    <updated>2020-05-30T04:45:52.585Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍如何制作自己的LIB(Keil平台)。</p><a id="more"></a><h1 id="为什么要做成lib库？"><a href="#为什么要做成lib库？" class="headerlink" title="为什么要做成lib库？"></a>为什么要做成lib库？</h1><ol><li>不想将自己写的源代码公开，但是同时库文件又需要让别人能够正常调用，那封装成lib的格式就是一个方法。</li><li>当功能成熟时，防止他人改动功能、并减少工程编译时间。<ol><li>如上所说，防止他人改动功能内容。</li><li>编译某些工程文件时非常耗时，像ST官方的库时，由于文件众多，编译一次可能得1两分钟。假如这个这时可以打包成库，节省不少的时间。但同时也不能用右键go to Definition ‘XXX’来直接找到源文件定义了。</li></ol></li><li>项目基本不需要再改动，局部单文件需要频繁改动。即单个功能模块需要频繁改动，可以把该功能模块封装成静态库，导入功能。如果要改功能，只要更换库就行了。</li></ol><hr><h2 id="LIB的制作方法一"><a href="#LIB的制作方法一" class="headerlink" title="LIB的制作方法一"></a>LIB的制作方法一</h2><ol><li>首先将之前的工程项目文件进行一次复制粘贴备份，备份完成后，打开工程文件进入 Manage-&gt;project Items ,移除不需要的文件，仅保留需要打包为库文件的文件，如下图：</li></ol><img src="/2020/05/30/Keil制作自己的lib/1.png"><ol start="2"><li>在Output选项中选择生成库的选项，如下图</li></ol><img src="/2020/05/30/Keil制作自己的lib/2.png"><ol start="3"><li>在OBJ文件夹中找出tcp.lib的文件，从新命名你想要的名字即可，至此库封装完毕。</li></ol><img src="/2020/05/30/Keil制作自己的lib/3.png"><ol start="4"><li>将生成的库文件拷贝回之前的项目中，添加到项目中，删除之前的源文件即可使用。</li></ol><img src="/2020/05/30/Keil制作自己的lib/4.png"><ol start="5"><li><strong>lib的调用，keil不能直接调用lib文件，需要将lib和.h文件 同时放到工程中去！！！</strong></li></ol><img src="/2020/05/30/Keil制作自己的lib/5.png"><hr><h2 id="LIB的制作方法二"><a href="#LIB的制作方法二" class="headerlink" title="LIB的制作方法二"></a>LIB的制作方法二</h2><ol><li>右键点击工程，假设为a，选Add Group，假设为b，再将想生成lib的文件加入b group，假设文件是cc.c，必须要有cc.h。</li></ol><img src="/2020/05/30/Keil制作自己的lib/6.png"><ol start="2"><li>右键依次点击其他的group，按KEIL官网资料所说的，将Options for Group-&gt;Properties下的Include in Target Build前的对勾去掉，这样生成LIB时就不会被编译了</li></ol><img src="/2020/05/30/Keil制作自己的lib/7.png"><img src="/2020/05/30/Keil制作自己的lib/8.png"><ol start="3"><li>Project-&gt;Options for Target-&gt;Output下，选择Create Library，改输出文件名为cc，点OK</li></ol><img src="/2020/05/30/Keil制作自己的lib/9.png"><ol start="4"><li>编译，这样就能在工程文件夹下的OBJ找到生成的cc.lib了</li></ol><hr><p>总结：<strong>不要另开工程！！！库文件的配置要求很高，例如芯片选型、等等一系列微配置。重新建工程容易出现link错误，建议直接复制原有工程进行删减。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍如何制作自己的LIB(Keil平台)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="keil" scheme="http://shatang.github.io/tags/keil/"/>
    
      <category term="加密" scheme="http://shatang.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式总线_基本概念&amp;比较</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E6%AF%94%E8%BE%83/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式总线-基本概念-比较/</id>
    <published>2020-05-30T03:43:58.000Z</published>
    <updated>2020-06-14T01:45:40.247Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇宏观介绍嵌入式的各种通讯总线，用来比较各总线之间的差别、加深理解。</p><a id="more"></a><h1 id="一、部分总线概念-可跳着看"><a href="#一、部分总线概念-可跳着看" class="headerlink" title="一、部分总线概念(可跳着看)"></a>一、部分总线概念(可跳着看)</h1><h2 id="1-1-UART"><a href="#1-1-UART" class="headerlink" title="1.1 UART"></a>1.1 UART</h2><p>&emsp;&emsp;UART是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。在嵌入式设计中，UART用于主机与辅助设备通信，如汽车音响与外接AP之间的通信，与PC机通信包括与监控调试器和其它器件，如EEPROM通信。</p><h3 id="1-1-1-接口"><a href="#1-1-1-接口" class="headerlink" title="1.1.1 接口"></a>1.1.1 接口</h3><p>&emsp;&emsp;在单片机中UART可以说是一种最基本的配置，很多与电脑进行通信的设备都采用到它，按计算机最常规的说法就是串行通信。</p><ul><li>TX - 数据发送接口</li><li>RX - 数据接受接口</li></ul><p>&emsp;&emsp;两个设备间将TX与RX相连，RX与TX相连即可正常工作。最常用到的就是我们电脑上的USB那就是个最典型的UART接口。</p><h3 id="1-1-2-工作原理"><a href="#1-1-2-工作原理" class="headerlink" title="1.1.2 工作原理"></a>1.1.2 工作原理</h3><blockquote><p>发送接收</p></blockquote><p>&emsp;&emsp;发送逻辑对从发送FIFO 读取的数据执行“并→串”转换。控制逻辑输出起始位在先的串行位流，并且根据控制寄存器中已编程的配置，后面紧跟着数据位（注意：最低位 LSB 先输出）、奇偶校验位和停止位。<br>在检测到一个有效的起始脉冲后，接收逻辑对接收到的位流执行“串→并”转换。此外还会对溢出错误、奇偶校验错误、帧错误和线中止（line-break）错误进行检测，并将检测到的状态附加到被写入接收FIFO 的数据中。</p><hr><blockquote><p>波特率产生</p></blockquote><p>&emsp;&emsp;波特率除数（baud-rate divisor）是一个22 位数，它由16 位整数和6 位小数组成。波特率发生器使用这两个值组成的数字来决定位周期。通过带有小数波特率的除法器，在足够高的系统时钟速率下，UART 可以产生所有标准的波特率，而误差很小。</p><hr><blockquote><p>数据收发</p></blockquote><p>&emsp;&emsp;发送时，数据被写入发送FIFO。如果UART 被使能，则会按照预先设置好的参数（波特率、数据位、停止位、校验位等）开始发送数据，一直到发送FIFO 中没有数据。一旦向发送FIFO 写数据（如果FIFO 未空），UART 的忙标志位BUSY 就有效，并且在发送数据期间一直保持有效。BUSY 位仅在发送FIFO 为空，且已从移位寄存器发送最后一个字符，包括停止位时才变无效。即 UART 不再使能，它也可以指示忙状态。BUSY 位的相关库函数是UARTBusy( )<br>在UART 接收器空闲时，如果数据输入变成“低电平”，即接收到了起始位，则接收计数器开始运行，并且数据在Baud16 的第8 个周期被采样。如果Rx 在Baud16 的第8 周期仍然为低电平，则起始位有效，否则会被认为是错误的起始位并将其忽略。<br>如果起始位有效，则根据数据字符被编程的长度，在 Baud16 的每第 16 个周期（即一个位周期之后）对连续的数据位进行采样。如果奇偶校验模式使能，则还会检测奇偶校验位。<br>最后，如果Rx 为高电平，则有效的停止位被确认，否则发生帧错误。当接收到一个完整的字符时，将数据存放在接收FIFO 中。</p><hr><blockquote><p>中断控制</p></blockquote><p>出现以下情况时，可使UART 产生中断：</p><ul><li>FIFO 溢出错误</li><li>线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）</li><li>奇偶校验错误</li><li>帧错误（停止位不为1）</li><li>接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）</li><li>发送</li><li>接收</li></ul><p>&emsp;&emsp;由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数UARTIntStatus( )，软件可以在同一个中断服务函数里处理多个中断事件（多个并列的if 语句）。</p><h2 id="1-2-I2C"><a href="#1-2-I2C" class="headerlink" title="1.2 I2C"></a>1.2 I2C</h2><p>&emsp;&emsp;I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。</p><p>&emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p><h3 id="1-2-1-接口"><a href="#1-2-1-接口" class="headerlink" title="1.2.1 接口"></a>1.2.1 接口</h3><ul><li>SCL - 串行时钟线</li><li>SDA - 串行数据线接口</li></ul><p>&emsp;&emsp;<strong>SDA（串行数据线）和SCL（串行时钟线）都是双向I/O线，接口电路为开漏输出．需通过上拉电阻接电源VCC。</strong> 当总线空闲时．两根线都是高电平，连接总线的外同器件都是CMOS器件，输出级也是开漏电路．在总线上消耗的电流很小，因此，总线上扩展的器件数量主要由电容负载来决定，因为每个器件的总线接口都有一定的等效电容．而线路中电容会影响总线传输速度．当电容过大时，有可能造成传输错误．所以，其负载能力为400pF，因此可以估算出总线允许长度和所接器件数量。</p><p>&emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p><h3 id="1-2-2-特点"><a href="#1-2-2-特点" class="headerlink" title="1.2.2 特点"></a>1.2.2 特点</h3><p>I2C总线特点可以概括如下：</p><ul><li>在硬件上，I2C总线只需要一根数据线和一根时钟线两根线，总线接口已经集成在芯片内部，不需要特殊的接口电路，而且片上接口电路的滤波器可以滤去总线数据上的毛刺．因此I2C总线简化了硬件电路PCB布线，降低了系统成本，提高了系统可靠性。因为I2C芯片除了这两根线和少量中断线，与系统再没有连接的线，用户常用IC可以很容易形成标准化和模块化，便于重复利用。</li><li>I2C总线是一个真正的多主机总线，如果两个或多个主机同时初始化数据传输，可以通过冲突检测和仲裁防止数据破坏，每个连接到总线上的器件都有唯一的地址，任何器件既可以作为主机也可以作为从机，但同一时刻只允许有一个主机。数据传输和地址设定由软件设定，非常灵活。总线上的器件增加和删除不影响其他器件正常工作。</li><li>I2C总线可以通过外部连线进行在线检测，便于系统故障诊断和调试，故障可以立即被寻址，软件也利于标准化和模块化，缩短开发时问。</li><li>连接到相同总线上的IC数量只受总线最大电容的限制，串行的8位双向数据传输位速率在标准模式下可达100Kbit/s，快速模式下可达400Kbit/s，高速模式下可达3．4Mbit/s。</li><li>总线具有极低的电流消耗．抗高噪声干扰，增加总线驱动器可以使总线电容扩大10倍，传输距离达到15m；兼容不同电压等级的器件，工作温度范围宽。</li></ul><h3 id="1-2-3-数据传输方式"><a href="#1-2-3-数据传输方式" class="headerlink" title="1.2.3 数据传输方式"></a>1.2.3 数据传输方式</h3><blockquote><p>字节格式</p></blockquote><p>&emsp;&emsp;发送到SDA 线上的每个字节必须为8 位，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位（MSB），如果从机要完成一些其他功能后（例如一个内部中断服务程序）才能接收或发送下一个完整的数据字节，可以使时钟线SCL 保持低电平，迫使主机进入等待状态，当从机准备好接收下一个数据字节并释放时钟线SCL 后数据传输继续。</p><hr><blockquote><p>应答响应</p></blockquote><p>&emsp;&emsp; 数据传输必须带响应，相关的响应时钟脉冲由主机产生。在响应的时钟脉冲期间发送器释放SDA 线（高）。在响应的时钟脉冲期间，接收器必须将SDA线拉低，使它在这个时钟脉冲的高电平期间保持稳定的低电平。通常被寻址的接收器在接收到的每个字节后，除了用CBUS 地址开头的数据，必须产生一个响应。当从机不能响应从机地址时（例如它正在执行一些实时函数不能接收或发送），从机必须使数据线保持高电平，主机然后产生一个停止条件终止传输或者产生重复起始条件开始新的传输。</p><p>&emsp;&emsp;如果从机接收器响应了从机地址，但是在传输了一段时间后不能接收更多数据字节，主机必须再一次终止传输。这个情况用从机在第一个字节后没有产生响应来表示。从机使数据线保持高电平，主机产生一个停止或重复起始条件。<br>如果传输中有主机接收器，它必须通过在从机发出的最后一个字节时产生一个响应，向从机发送器通知数据结束。从机发送器必须释放数据线，允许主机产生一个停止或重复起始条件。</p><hr><blockquote><p>时钟同步</p></blockquote><p>&emsp;&emsp;所有主机在SCL线上产生它们自己的时钟来传输I2C总线上的报文。数据只在时钟的高电平周期有效，因此需要一个确定的时钟进行逐位仲裁。</p><p>&emsp;&emsp;时钟同步通过线与连接I2C 接口到SCL 线来执行。这就是说SCL 线的高到低切换会使器件开始数它们的低电平周期，而且一旦器件的时钟变低电平，它会使SCL 线保持这种状态直到到达时钟的高电平。但是如果另一个时钟仍处于低电平周期，这个时钟的低到高切换不会改变SCL 线的状态。因此SCL 线被有最长低电平周期的器件保持低电平。此时低电平周期短的器件会进入高电平的等待状态。</p><p>&emsp;&emsp;当所有有关的器件数完了它们的低电平周期后，时钟线被释放并变成高电平。之后，器件时钟和SCL线的状态没有差别，而且所有器件会开始数它们的高电平周期。首先完成高电平周期的器件会再次将SCL线拉低。这样产生的同步SCL 时钟的低电平周期由低电平时钟周期最长的器件决定，而高电平周期由高电平时钟周期最短的器件决定。</p><h2 id="1-3-SPI"><a href="#1-3-SPI" class="headerlink" title="1.3 SPI"></a>1.3 SPI</h2><p>&emsp;&emsp;SPI接口的全称是”Serial Peripheral Interface”，意为串行外围接口,是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在EEPROM、FLASH、实时时钟、AD转换器，还有数字信号处理器和数字信号解码器之间。<br>SPI接口是在CPU和外围低速器件之间进行同步串行数据传输，在主器件的移位脉冲下，数据按位传输，高位在前，低位在后，为全双工通信，数据传输速度总体来说比I2C总线要快，速度可达到几Mbps。</p><h3 id="1-3-1-接口"><a href="#1-3-1-接口" class="headerlink" title="1.3.1 接口"></a>1.3.1 接口</h3><ul><li>MOSI – 主器件数据输出，从器件数据输入</li><li>MISO – 主器件数据输入，从器件数据输出</li><li>SCLK –时钟信号，由主器件产生,最大为fPCLK/2，从模式频率最大为fCPU/2</li><li>NSS – 从器件使能信号，由主器件控制,有的IC会标注为CS(Chip select)</li></ul><p>&emsp;&emsp;在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信，显得简单高效。<strong>在多个从器件的系统中，每个从器件需要独立的使能信号，硬件上比I2C系统要稍微复杂一些。</strong> SPI接口在内部硬件实际上是两个简单的移位寄存器，传输的数据为8位，在主器件产生的从器件使能信号和移位脉冲下，按位传输，高位在前，低位在后。</p><h3 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h3><ul><li>协议简单，相对数据速率高。</li><li>占用的Pin口较多</li><li>没有指定的流控制，没有应答机制确认是否接收到数据。</li></ul><h1 id="二、速率对比"><a href="#二、速率对比" class="headerlink" title="二、速率对比"></a>二、速率对比</h1><ul><li>UART： 无限制，常用9600、115200bps等保证双方通信速度相同。</li><li>IIC：通讯速率400Kbps</li><li>CAN：一般为1Mbps</li><li>SPI：通信速率为 fosc/4；其理论传输速度可达几Mb/s(其速率可以通过限制其SPI的时钟来实现限制速率)<ul><li>缺点：抗干扰能力差。SPI采用的是单端非平衡的传输方式，即传输的数据位的电压电平是以公共地作为参考的。在这种传输方式中对于已进入信号中的干扰是无法消除和减弱的。而信号在传输过程中总会受到干扰，而且距离越长干扰越严重，以致于信号传输产生错误。在这种条件下，信号传输就变得毫无意义了。另外，由于单端非平衡传输方式以公共地作为参考点，地线作为信号回流线，因此也存在信号电流。当传输线两端的系统之间存在交流电位差时，这个电位差将直接窜到信号中，形成噪声干扰。所以，为了解决抗干扰问题，通常采用平衡传输(balanced transmission)方式，这里采用比较常见的RS-422。</li><li>应用：读写flash（存有字库，图片等等）芯片，与触摸屏控制器通信，还有就是读写sd卡了，你手机里的sd卡就是通过spi和处理器传数据的，目前高速都用SDIO了。    </li></ul></li><li>SDIO： 10M及已上</li><li>SDRAM：（非总线）16位的，100m频率就是1.6Gbit读写</li><li>PCI：（网卡）传输速率高最大数据传输率为132MB/s（工作在33MHz 频率之下），当数据宽度升级到64位，数据传输率可达264MB/s。这是其他总线难以比拟的。它大大缓解了数据I/O瓶颈，使高性能CPU的功能得以充分发挥，适应高速设备数据传输的需要。</li><li>PCI Express 2.0 ： 理论值 10Gbps，实际大于100MB</li><li>USB2.0 ： 一般30~40MB</li><li>Ethenet ：一般70~80MB</li></ul><h1 id="三、常见通讯总线疑问"><a href="#三、常见通讯总线疑问" class="headerlink" title="三、常见通讯总线疑问"></a>三、常见通讯总线疑问</h1><h2 id="3-1-USART-amp-UART"><a href="#3-1-USART-amp-UART" class="headerlink" title="3.1 USART &amp; UART"></a>3.1 USART &amp; UART</h2><ul><li>USART：通用同步和异步收发器</li><li>UART：通用异步收发器</li></ul><p>&emsp;&emsp;当进行异步通信时,这两者是没有区别的。区别在于USART比UART多了同步通信功能。<br>这个同步通信功能可以把USART当做SPI来用，比如用USART来驱动SPI设备。</p><ul><li>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。  </li><li>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</li></ul><hr><p>同步是阻塞模式，异步是非阻塞模式。</p><p><strong><font color="red">Ps：</font></strong>其中SPI 、IIC为同步通信，Uart为异步通信, Usart为同步&amp;异步通信。</p><h2 id="3-2-单工、半双工、全双工"><a href="#3-2-单工、半双工、全双工" class="headerlink" title="3.2 单工、半双工、全双工"></a>3.2 单工、半双工、全双工</h2><ul><li>单工数据传输只支持数据在一个方向上传输；</li><li>半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输；它实际上是一种切换方向的单工通信；</li><li>全双工数据通信允许数据同时在两个方向上传输；因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 </li></ul><p><strong><font color="red">Ps：</font></strong>I2C是半双工，SPI的全双工，Usart是全双工；串口232是全双工 ，串口485是半双工。</p><h2 id="3-3-波特率-计算-发送速率"><a href="#3-3-波特率-计算-发送速率" class="headerlink" title="3.3 波特率 计算 发送速率"></a>3.3 波特率 计算 发送速率</h2><ul><li>B = byte表示“字节”</li><li>b = bit表示“比特”</li><li>bps就是比特每秒</li></ul><blockquote><p>1 Kb=1024 bit，1 KB=1024 byte，1 byte=8 bit</p></blockquote><p>举例，115200bps就是每秒传输115200比特(115200bit)，所以115200bps=每秒112.5kb=每秒14.0625kB。</p><hr><blockquote><p>举例计算速率</p></blockquote><ul><li>波特率115200 ＝ 115200 (位/秒)</li><li>根据常规串口发送协议,一个起始位,8个数据位,0个校验位,1个停止位,共计10位二进制数</li><li>如果没有校验位，就应该除以 10，得到的是每秒字节数：<ul><li>波特率115200 ＝ 115200 (位/秒) ＝ 11520 (字节/秒) </li><li>再除以 1024，就是每秒 KB 数</li><li>波特率115200 ＝ 115200 (位/秒) ＝ 11.25 (KB/秒) </li></ul></li><li>如果有一位奇偶校验位，就应该除以 11，得到的是每秒字节数。<ul><li>最后：波特率115200 ＝ 115200 (位/秒) ＝ 10.27 (KB/秒)</li></ul></li></ul><h2 id="3-4-RS485-amp-Modbus"><a href="#3-4-RS485-amp-Modbus" class="headerlink" title="3.4 RS485 &amp; Modbus"></a>3.4 RS485 &amp; Modbus</h2><ul><li>RS485 ：是一个物理接口，简单的说是硬件。</li><li>MODBUS ：是一种国际标准的通讯协议，用于不同厂商之间的设备交换数据（一般是工业用途）；所谓协议，也可以理解为上面有人说的“语言”吧，简单的说是软件。</li></ul><hr><ul><li>RS485属于有线传输，所以就要硬件传输媒介，实际就是两根线就可以了，在这两根线上传输的实际是同一个信号，只是发送端把这个信号一分为二，不过在接收端会把它还原为原来的信号，这样做的好处还要得和RS232来比较；RS232也需要两根线，更多的时候还要加上地线，所以是三根线，地线咱不管它，其余的两根只有一根线传输的数据信号，而另一根传输的时钟，也就是信号原来什么样发送端就怎样发送出来，同样接收端也做同样的处理。所以485的接收端可以把信号在传输过程中引入的干扰就可以抵消掉，而232的接收端不能，所以485的抗干扰能力强可以传输信号上千米，而232只能传输十几米。 </li><li>MODBUS只是通信协议的一种，就像汉语和英语一样，就是一种交流的语言，一种机器之间交流的语言。那么在交流之前肯定要有沟通的桥梁吧，那就是传输媒介485或232或其他电气规则，<strong>同一种协议可以用不同的传输媒介方式，如485或232；但是同一传输线路上不能同时存在两种协议。</strong></li></ul><p>&emsp;&emsp;一般情况下，两台设备通过MODBUS协议传输数据：<br>最早是用RS232C作为硬件接口(也就是普通电脑上的串行通讯口(串口))；<br>也有用RS422的；也有常用的RS485，这种接口传输距离远，在一般工业现场用的比较多。</p><h2 id="3-5-RS485-amp-CAN"><a href="#3-5-RS485-amp-CAN" class="headerlink" title="3.5 RS485 &amp; CAN"></a>3.5 RS485 &amp; CAN</h2><p>&emsp;&emsp;为什么会有这个的比较？</p><p>其实，RS485和CAN是很相似的：</p><ol><li>均为差分信号，抗干扰强；(即，都为半双工)</li><li>均为双线连接</li><li>均可挂多个子设备</li></ol><hr><blockquote><p>CAN总线特点：</p></blockquote><ol><li>国际标准的工业级现场总线，传输可靠，实时性高；  </li><li>传输距离远（最远10Km），传输速率快（最高1MHz bps）； </li><li>单条总线最多可接110个节点，并可方便的扩充节点数；  </li><li>多主结构，各节点的地位平等，方便区域组网，总线利用率高；  </li><li>实时性高，非破坏总线仲裁技术，优先级高的节点无延时；  </li><li>出错的CAN节点会自动关闭并切断和总线的联系，不影响总线的通讯；  </li><li>报文为短帧结构并有硬件CRC校验，受干扰概率小，数据出错率极低；  </li><li>自动检测报文发送成功与否，可硬件自动重发，传输可靠性很高；  </li><li>硬件报文滤波功能，只接收必要信息，减轻cpu负担，简化软件编制；  </li><li>通讯介质可用普通的双绞线，同轴电缆或光纤等；  </li><li>CAN总线系统结构简单，有极高的性价比。</li></ol><hr><blockquote><p>RS485接口标准特点：</p></blockquote><ol><li>RS-485的电气特性：逻辑”1”以两线间的电压差为+（2-6）V表示；逻辑”0”以两线间的电压差为-（2-6）V表示。接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL 电路连接。</li><li>RS-485的数据最高传输速率为10Mbps</li><li>RS-485接口是采用平衡驱动器和差分接收器的组合，抗共模干能力增强，即抗噪声干扰性好。</li><li>RS-485接口的最大传输距离标准值为4000英尺，实际上可达 3000米，另外RS-232-C接口在总线上只允许连接1个收发器，即单站能力。而RS-485接口在总线上是允许连接多达128个收发器。即具有多站能力,这样用户可以利用单一的RS-485接口方便地建立起设备网络。但RS-485总线上任何时候只能有一发送器发送。</li><li>因RS-485接口具有良好的抗噪声干扰性，长的传输距离和多站能力等上述优点就使其成为首选的串行接口。 </li><li>因为RS485接口组成的半双工网络，一般只需二根连线，所以RS485接口均采用屏蔽双绞线传输。 </li></ol><hr><blockquote><p>CAN总线与RS485的比较：</p></blockquote><ul><li><strong>速度与距离</strong>：CAN与RS485以1Mbit/S的高速率传输的距离都不超过100M，可谓高速上的距离差不多。但是在低速时CAN以5Kbit/S时，距离可达10KM，而485再低的速率也只能到1219米左右（都无中继）。可见CAN在长距离的传输上拥有绝对的优势。</li><li><strong>总线利用率</strong>：RS485是单主从结构，就是一个总线上只能有一台主机，通讯都由它发起的，它没有下命令，下面的节点不能发送，而且要发完即答，受到答复后，主机才向下一个节点询问，这样是为了防止多个节点向总线发送数据，而造成数据错乱。而CAN－bus是多主从结构，每个节点都有CAN控制器，多个节点发送时，以发送的ID号自动进行仲裁，这样就可以实现总线数据不错乱，而且一个节点发完，另一个节点可以探测到总线空闲，而马上发送，这样省去了主机的询问，提高了总线利用率，增强了快速性。所以在汽车等实性要求高的系统，都是用CAN总线，或者其他类似的总线。</li><li><strong>错误检测机制</strong>：RS485只规定了物理层，而没有数据链路层，所以它对错误是无法识别的，除非一些短路等物理错误。这样容易造成一个节点破坏了，拼命向总线发数据（一直发1），这样造成整个总线瘫痪。所以RS485一旦坏一个节点，这个总线网络都挂。而CAN总线有CAN控制器，可以对总线任何错误进行检测，如果自身错误超过128个，就自动闭锁。保护总线。如果检测到其他节点错误或者自身错误，都会向总线发送错误帧，来提示其他节点，这个数据是错误的。大家小心。这样CAN总线一旦有一个节点CPU程序跑飞了，它的控制器自动闭锁。保护总线。所以在安全性要求高的网路，CAN是很强的。</li><li><strong>价格与培训成本</strong>：CAN器件的价格大约是485的2倍这样，485的通讯从软件上是很方便的，只要懂串行通讯，就可以编程，而CAN需要底层工程师了解CAN复杂的层，编写上位机软件也要了解CAN的协议。可谓培训成本较高。</li><li>CAN总线通过CAN控制器接口芯片82C250的两个输出端CANH和CANL与物理总线相连，而CANH端的状态只能是高电平或悬浮状态，CANL端只能是低电平或悬浮状态。这就保证不会出现象在RS-485网络中，当系统有错误，出现多节点同时向总线发送数据时，导致总线呈现短路，从而损坏某些节点的现象。而且CAN节点在错误严重的情况下具有自动关闭输出功能，以使总线上其他节点的操作不受影响，从而保证不会出现象在网络中，因个别节点出现问题，使得总线处于“死锁”状态。</li><li>CAN具有完善的通信协议，可由CAN控制器芯片及其接口芯片来实现，从而大大降低了系统的开发难度，缩短了开发周期，这些是只仅仅有电气协议的RS-485所无法比拟的。</li></ul><table><thead><tr><th>特性</th><th align="center">RS-485</th><th align="center">CAN-bus</th></tr></thead><tbody><tr><td>单点成本</td><td align="center">低廉</td><td align="center">稍高</td></tr><tr><td>系统成本</td><td align="center">高</td><td align="center">较低</td></tr><tr><td>总线利用率</td><td align="center">低</td><td align="center">高</td></tr><tr><td>网络特性</td><td align="center">单主网络</td><td align="center">多主网络</td></tr><tr><td>数据传输率</td><td align="center">低</td><td align="center">高</td></tr><tr><td>容错机制</td><td align="center">无</td><td align="center">可靠的错误处理和检错机制</td></tr><tr><td>通讯失败率</td><td align="center">高</td><td align="center">极低</td></tr><tr><td>节点错误的影响</td><td align="center">导致整个网络的瘫痪</td><td align="center">无任何影响</td></tr><tr><td>通讯距离</td><td align="center">&lt;1.5km</td><td align="center">可达10km（5kbps）</td></tr><tr><td>网络调试</td><td align="center">困难</td><td align="center">非常容易</td></tr><tr><td>开发难度</td><td align="center">标准Modbus协议</td><td align="center">标准CAN-bus协议</td></tr><tr><td>后期维护成本</td><td align="center">高</td><td align="center">低</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇宏观介绍嵌入式的各种通讯总线，用来比较各总线之间的差别、加深理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>微库 &amp; 断言 &amp; (Keil)代码优化</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%BE%AE%E5%BA%93-%E6%96%AD%E8%A8%80-Keil-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>http://shatang.github.io/2020/05/30/微库-断言-Keil-代码优化/</id>
    <published>2020-05-30T03:31:09.000Z</published>
    <updated>2020-05-30T03:34:20.668Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍 在Keil平台开发嵌入式遇到的一些东西：MicroLIB、Assert、代码优化。</p><a id="more"></a><h1 id="一、MicroLIB"><a href="#一、MicroLIB" class="headerlink" title="一、MicroLIB"></a>一、MicroLIB</h1><h2 id="1-1-Use-MicroLIB-amp-printf"><a href="#1-1-Use-MicroLIB-amp-printf" class="headerlink" title="1.1 Use MicroLIB &amp; printf"></a>1.1 Use MicroLIB &amp; printf</h2><p>&emsp;&emsp;大多人一般之所以使用 <code>Use MicroLIB</code>，是因为使能后能够直接调用<code>printf()</code>等函数。</p><p>&emsp;&emsp;<code>printf()</code>之类的库函数，是一些很骚的东西；使用printf、 fopen等库函数库函数调用，会让软件进入半主机模式。但是<code>printf()</code>库函数本身 不需要半主机模式(关掉,当然也能用printf)。</p><p>使用C标准库(stdio.h)中的函数，例如<code>printf()</code>之类的函数，会进入半主机模式，<br>发生软件异常，会导致程序无法运行 ,以下是解决方法 :</p><ul><li>方法 1.使用微库 ,因为使用微库的话 ,不会使用半主机模式。MDK 勾选 <code>Use MicroLIB</code>这样以后就可以<br>使用 <code>printf</code> ，<code>sprintf</code> 函数了</li><li>方法 2.仍然使用标准库 ,在主程序添加下面代码 :<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此段代码可以在正点原子例程Uart处找到</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> import(__use_no_semihosting)  <span class="comment">//确保没有从 C 库链接使用半主机的函数</span></span></span><br><span class="line">_sys_exit(<span class="keyword">int</span>  x) <span class="comment">//定义 _sys_exit() 以避免使用半主机模式</span></span><br><span class="line">&#123;</span><br><span class="line">x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span>  // 标准库需要的支持函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;选上<code>Use MicroLIB</code>，例如你用<code>printf()</code>函数的时候，就会从串口1输出字符串，直接默认定向到串口1。</p><hr><ul><li>法1可实现串口1数据输出，但要定向到串口2，串口3，microLIB就不合用了；</li><li>法2虽然能够映射其他串口，但是如果同时涉及到多串口也是有问题。</li></ul><p>&emsp;&emsp;总而言之，实际上 法1 &amp; 法2 都不推荐用于实际项目，顶多就用于快速搭建Demo 或 做测试用。</p><h2 id="1-2-半主机-amp-printf"><a href="#1-2-半主机-amp-printf" class="headerlink" title="1.2 半主机 &amp; printf"></a>1.2 半主机 &amp; printf</h2><p>&emsp;&emsp;半主机模式是这么一种机制：它使得在ARM目标上跑的代码，如果主机电脑运行了调试器，那么该代码可以使用该主机电脑的输入输出设备。这点非常重要，因为开发初期，可能开发者根本不知道该ARM器件上有什么输入输出设备，而半主机机制使得你不用知道ARM器件的外设，利用主机电脑的外设就可以实现输入输出调试。</p><p>&emsp;&emsp;所以，如果不用主机电脑的外设就可以实现输入输出调试，而是要利用目标ARM器件的输入输出设备，首先要关掉半主机机制。然后再将输入输出重定向到ARM器件上，如printf和scanf，你需要重写fputc和fgetc函数(原有的输入输出，标准库函数的默认输出设备是显示器)。</p><h2 id="1-3-MicroLIB"><a href="#1-3-MicroLIB" class="headerlink" title="1.3 MicroLIB"></a>1.3 MicroLIB</h2><p>&emsp;&emsp;之所以在代码优化提及到MicroLIB，是因为微库本身由于有精简代码的效果，因此它可以用来压缩代码量。</p><p>MicroLIB 与 缺省C库 之间的主要差异是： </p><ol><li>microlib 不符合 ISO C 库标准。 不支持某些 ISO 特性，并且其他特性具有的功能也较少。 </li><li>microlib 不符合 IEEE 754 二进制浮点算法标准。 </li><li>microlib 进行了高度优化以使代码变得很小。</li></ol><p>&emsp;&emsp;还有更多细节上的差异就不罗列出来了，直接网上一查一大把。但是，也正是这些零零碎碎的差异，可能就导致你做项目时疯狂翻车，所以一般不建议使用 MicroLIB (还有其他原因等等，尤其是项目刚开发的时候真不建议使用)。</p><hr><p>以下是我对该库的总结：</p><ul><li>MicroLIB库 虽然能够进行代码大小优化。<ul><li>但是实际测试的效果真的是杯水车薪，可以忽略不计；还不如自己去优化代码 or 提高优化等级。如果是其他方式都用了后，只能通过MicroLIB库优化代码，建议直接换硬件(真的是优化没多少的)。</li><li>由于microlib中进行了优化，以尽量减少代码大小，一些功能将会比ARM编译工具提供了标准C库函数更慢执行；例如，memcpy()。效率换空间，在项目大部分是 空间换效率，这当然是不建议的。</li></ul></li><li>MicroLIB库 不支持浮点数运算。<ul><li>ST除了F4xx系列，其他是没有FPU单元，都是采用软件模拟运算。</li><li>故，移植UcosII在F4xx系列，不选 Use MicroLIB，开了FPU就会死机</li></ul></li><li>MicroLIB库 不支持半主机模式，进而支持<code>printf()</code>函数。但是实际用起来还是不太好用</li></ul><p>&emsp;&emsp;一般来讲，最好不要加。它和标准库有很多繁琐区别，对代码的维护性不好。</p><p>常见的有以下情况：</p><p>&emsp;&emsp;当旧的项目工程要换新的硬件平台，迁移的时候发现异常。建议查看一下旧项目工程是否采用了微库；然后查看旧代码是不是调用了<code>printf</code>之类的C库函数。如果调用就用上述的方法，Use MicroLIB 或者 关闭半主机模式(+重定向)。</p><h1 id="二、assert"><a href="#二、assert" class="headerlink" title="二、assert"></a>二、assert</h1><p>&emsp;&emsp;assert() 不仅仅是个(字面意义上)报错函数！<strong>对于在开发过程中的程序员来说，加断言是个好习惯，可以帮助调试。</strong></p><p>程序在假设条件下，能够正常良好的运作，那assert()其实就相当于一个 if 语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(假设成立)</span><br><span class="line">&#123;</span><br><span class="line">     程序正常运行；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      报错&amp;&amp;终止程序！（避免由程序运行引起更大的错误）  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可能有人说，断言的功能可以用if语句对异常情况进行处理来代替。以下列举 断言 的好处：</p><ul><li>实现效果最后不会增加代码量<ul><li>if是实的，真正的增加代码量，降低执行效率；</li><li>断言是虚的，在Debug的时候可以帮助调试，在Release的时候并不存在。</li></ul></li><li>断言，实际上也是一种文档。断言设定了，函数的入口条件。增加了代码的可读性。</li><li>断言用于在开发阶段监测BUG，进行调试。<ul><li>断言其存在的意义在于检测代码在开发过程中是否出现了问题。</li><li>而”if… “,更准确的说是错误处理，是在你的release版本中也实实在在应该有的，处理程序运行过程中产生的错误并进行处理，以提高程序的健壮性。</li></ul></li></ul><p>&emsp;&emsp;如果是看过Stm32的库函数实现方式的话，肯定会看到<code>assert_param(expr) ((void)0)</code>。这也是断言，不过是ST官方自己写的断言函数；而且有个宏定义用来是否失活该断言函数。当你打开一份Stm32的例程，进去库函数就会发现这些<code>assert_param(expr) ((void)0)</code>是失活的。</p><p><strong><font color="red">Ps：</font>MicroLIB 库并不支持assert()函数，两者同时用产生报错。</strong></p><p>&emsp;&emsp;microlib是一个比ARM标准C库小的独立库。为了节省大小，arm microlib c库不支持或实现几乎所有与操作系统交互的函数，例如abort（）、exit（）或assert（）。</p><hr><p>&emsp;&emsp;如何在Release版本去掉assert？</p><p>方法一：常见任何平台处理</p><p>&emsp;&emsp;在调试结束后，可以通过在包含<code>#include <assert.h></assert.h></code>的语句之前插入 <code>#define NDEBUG</code> 来禁用assert调用，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法二：在Keil平台上</p><p>&emsp;&emsp;在工程参数设置一栏，在“Preprocessor Symbols”的“Define”栏输入“NDEBUG”。等同于在代码中添加宏定义“#define NDEBUG”。实际为上面方法。</p><p>方法三：在Keil平台上</p><p>&emsp;&emsp;提高代码优化等级至2。在代码优化Level 0时，断言是占用空间可执行的；当代码优化提升为Level 2。这个时候就能够去掉assert()函数处理</p><h1 id="三、Keil的代码优化等级"><a href="#三、Keil的代码优化等级" class="headerlink" title="三、Keil的代码优化等级"></a>三、Keil的代码优化等级</h1><h2 id="3-1-代码优化等级"><a href="#3-1-代码优化等级" class="headerlink" title="3.1 代码优化等级"></a>3.1 代码优化等级</h2><p>&emsp;&emsp;C/C++的优化等级会对程序产生 <strong>不定性的影响</strong>，至于选择哪种优化等级必须从 现有的程序分析才行！</p><ul><li>Level 0 (-O0)：关闭大部分优化，除了一些简单的转换，生成的代码具有最佳的调试视图。</li><li>Level 1 (-O1)：应用受限优化。<br>比如：删除未使用的内联函数和静态函数，删除冗余代码和重新排序指令等。生成的代码经过合理优化，具有良好的调试视图。</li><li>Level 2 (-O2): 高度优化，目标代码到源代码的映射并不一定对应，因此，不利于调试。</li><li>Level 3 (-O3)：最大级别优化。级别3与时间优化相结合可能生成比级别2更多的代码。</li></ul><hr><p>&emsp;&emsp;经实际测试，<code>Level 2</code>升<code>Level 3</code>并不能节省很多的空间；相反，<code>Level 3</code>更高几率造成程序运行问题。从 <code>Level 0</code>升<code>Level 2</code>，相当于20%时间获取80%成果；从 <code>Level 2</code>升<code>Level 3</code>，相当于80%时间获取20%成果。如果对程序没有太过严苛的要求，建议程序整体在<code>Level 2</code>即可。</p><h2 id="3-2-优化随之带来的Bug"><a href="#3-2-优化随之带来的Bug" class="headerlink" title="3.2 优化随之带来的Bug"></a>3.2 优化随之带来的Bug</h2><p>代码优化产生的Bug情况：</p><ol><li>有更新的变量被优化而没有重新读取值，导致错误</li><li>优化后，代码段被跳过(不执行)</li><li>Keil软件自带的软件Bug</li><li>小心一些驱动，尤其是涉及到文件管理，因为该底层驱动极有可能里面用了C库函数实现了某些功能；而C库函数有些一旦提高优化等级就会出问题(例如，SD卡文件系统)。</li></ol><blockquote><p>例子1</p></blockquote><p>&emsp;&emsp;楼主编写一个stm32F10x系列的SPI库函数驱动。程序未优化前(LEVEL 0)，MISO能正常接收信息，优化后(Level 2)，MISO接收的信息都是错误的。</p><p>&emsp;&emsp;IAP平台之前也出现这个问题，现在貌似被修复了；但是Keil平台看起来还有。</p><blockquote><p>例子2</p></blockquote><p>&emsp;&emsp;近日在移植LPC1788的lwip驱动和SD卡（带文件系统）驱动时，遇到单独移植每个驱动都正常，移植到一起就一直出现HardFault_Handler错误。单步调试后发现编译器优化导致部分代码被跳过的情况。</p><p>&emsp;&emsp;仔细检查后发现官网例程中的LWIP驱动使用的是最高级（LEVEL3）优化等级，而SD卡驱动使用LEVEL0等级的优化。移植后统一修改为LEVEL3导致初始化SD卡f_open文件失败。</p><p>网上查找资料后，处理此类问题有下面几种方法：</p><ol><li>单步调试，找到被优化的代码段，看是否有更新的变量被优化而没有重新读取值，导致错误。若有，加入valotile关键字。</li><li>通过options of file”…”将被优化文件的优化等级调成特定等级。</li></ol><h2 id="3-3-小总结"><a href="#3-3-小总结" class="headerlink" title="3.3 小总结"></a>3.3 小总结</h2><ul><li><strong>不建议小白直接上<code>Level 2</code>及<code>Level 3</code>搭建新工程！</strong></li><li>代码优化等级方面，我建议新建项目时，最好采用<code>Level 0</code> 搭建工程。等到项目比较完善的时候，再提升优化等级至<code>Level 2</code>，再根据优化等级出现的问题，进行逐步调试。</li><li>建议项目整体基本优化等级为<code>Level 2</code>，不需要升为<code>Level 3</code>。</li><li>有些底层驱动确实是不好提高代码优化等级(尤其涉及到文件系统)。</li></ul><hr><p>&emsp;&emsp;努力提高优化等级并不是厉害！在能力有限的情况下，费时费力；尤其是硬件Flash资源明显不够用时，虽然通过最高优化等级能应用，但是会对后面的升级更新、bug检查造成很大的麻烦：</p><ul><li>仿真无法查看，优化等级太高</li><li>一旦降低优化等级，硬件编译报错，Flash存储不够</li><li>唯一的途径，就是把程序其他代码删除，留下所需的代码进行仿真调试局部(无法调试整体)</li><li>建议还是更换有更大Flash的MCU，或者自己优化一下程序代码</li></ul><hr><p>&emsp;&emsp;最极端的代码压缩方法，即采用较高的Level2或Level3进行代码优化，然后再选用MicroLIB对代码量再进行压缩一下(最后一步再勾选微库，方便找出微库造成的问题)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍 在Keil平台开发嵌入式遇到的一些东西：MicroLIB、Assert、代码优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="keil" scheme="http://shatang.github.io/tags/keil/"/>
    
      <category term="Assert" scheme="http://shatang.github.io/tags/Assert/"/>
    
      <category term="MicroLIB" scheme="http://shatang.github.io/tags/MicroLIB/"/>
    
      <category term="代码优化" scheme="http://shatang.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>状态机</title>
    <link href="http://shatang.github.io/2020/05/30/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://shatang.github.io/2020/05/30/状态机/</id>
    <published>2020-05-30T03:25:04.000Z</published>
    <updated>2020-05-30T03:28:18.282Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍 搞嵌入式萌新 听别人吹牛的计算机概念——状态机</p><a id="more"></a><h1 id="一、什么是状态机？"><a href="#一、什么是状态机？" class="headerlink" title="一、什么是状态机？"></a>一、什么是状态机？</h1><p>&emsp;&emsp;可能有些编写嵌入式程序的人，听过别人吹他已经用状态机方法写好了代码。听起来逼格贼高，但是实际上，即使你没了解过状态机，但我们在编写嵌入式程序，尤其是驱动编写，都会有意无意以(类似)状态机思想来编写程序，只不过写得时候不知道这个叫状态机。</p><h1 id="二、状态机"><a href="#二、状态机" class="headerlink" title="二、状态机"></a>二、状态机</h1><p>&emsp;&emsp;状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型，一种思想。重复一下：状态机是<strong>有限状态自动机</strong>的简称，是现实事物运行规则抽象而成的一个数学模型。</p><h2 id="2-1-状态机的四大概念"><a href="#2-1-状态机的四大概念" class="headerlink" title="2.1 状态机的四大概念"></a>2.1 状态机的四大概念</h2><ul><li>State ，状态<ul><li>一个状态机至少要包含两个状态。例如bool类型，有 true 和 false 两个状态。</li></ul></li><li>Event ，事件<ul><li>事件就是执行某个操作的触发条件或者口令。不同状态对应产生各自事件。</li></ul></li><li>Action ，动作<ul><li>事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。</li></ul></li><li>Transition ，变换<ul><li>通过多种动作满足一定条件，开始切换状态</li></ul></li></ul><p>&emsp;&emsp;主要概念还是状态，后三者往往在代码实现的时候糅合在一起比较模糊。</p><h2 id="2-2-举例应用"><a href="#2-2-举例应用" class="headerlink" title="2.2 举例应用"></a>2.2 举例应用</h2><p>&emsp;&emsp;状态机，是(快速)写(驱动)程序的好帮手。</p><p>街上的自动售货机中明显能看到状态机逻辑；我们做一下简化，假设这是一台只卖2元一瓶的汽水的售货机，只接受五毛和一块的硬币。</p><ul><li>初始状态是”未付款“，中间状态有”已付款5毛“，”已付款1块“，”已付款1.5块“，”已足额付款“，四个状态。</li><li>状态切换的触发条件是”投一块硬币“和”投5毛硬币“两种。</li><li>到达“已足额付款”状态，还要进行余额清零和弹出汽水操作。然后重新进入初始化状态</li></ul><p>所以如果画出一张完整的状态转换图，也会是比较复杂的一张图了。而实际中的售货机对应的状态机就会更加复杂了。</p><h2 id="2-3-实际代码实现"><a href="#2-3-实际代码实现" class="headerlink" title="2.3 实际代码实现"></a>2.3 实际代码实现</h2><p>&emsp;&emsp;实际从C的代码层面，更容易看到状态机的影子。最经典的就是 <code>switch</code> 和 <code>enum</code> 的搭配了。</p><p><code>switch</code> 罗列出状态机的所有可能状态。<code>enum</code> 产生对应的各种状态。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    DISCONNECT,</span><br><span class="line">    CONNECT,</span><br><span class="line">    RECONNECT,</span><br><span class="line">&#125;_enumGPRSState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(_enumGPRSState GPRSState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(GPRSState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DISCONNECT:<span class="keyword">break</span>;  <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">case</span> CONNECT:<span class="keyword">break</span>;     <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">case</span> RECONNECT:<span class="keyword">break</span>;   <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">//特殊处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就是很常见、很普通的状态机写法，很适用于快速开发底层驱动。当然，这是一个很简单的例子。还有更复杂的状态机，甚至多状态机相互影响切换其他状态机的状态。状态机也只是一种思想而已。</p><p>&emsp;&emsp;可以去看FreeModbus的通讯库。它就是一个很经典的状态机写法，但是涉及到多状态机。它的状态机有：(轮询)事件，串口发送中断，串口接收中断，其中还有个定时器能够变换 串口接收中断 状态机。</p><h2 id="2-4-FreeModbus库讲解-RTU模式为例"><a href="#2-4-FreeModbus库讲解-RTU模式为例" class="headerlink" title="2.4 FreeModbus库讲解(RTU模式为例)"></a>2.4 FreeModbus库讲解(RTU模式为例)</h2><ol><li>Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态</li><li>串口接收中断 在初始化状态下，打开定时器</li><li>等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将<code>eMBPoll</code>的 事件状态机 置为 初始化。</li><li><strong>以上就是初始化完成，接下来就是数据收发的流程了</strong></li><li>串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。</li><li>每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。</li><li>当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态</li><li>由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。</li><li>eMBPoll的 事件状态机 为<code>Frame received</code>接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功</li><li>核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 <code>MB_EIO</code>的错误。</li><li>经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为<code>Execute function</code> 执行数据函数(事件)。开始对数据进行处理。</li><li>这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。</li><li>如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 <code>功能码|0x80 + 错误代码</code>。</li><li>举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。</li><li>在处理完后会返回一个enum状态值。如果状态 不为<code>MB_ENOERR</code>，即内部使用的错误代码，根据内部使用的<code>enum</code>错误代码，<code>switch</code>生成 对外的错误代码</li><li>返回的CRC会在发送前先把CRC校验完成。</li><li>发送前，检查能不能数据接收，能接收则报硬件错误<code>MB_EIO</code>，因为协议规定只能单向收发</li><li>发送一个字节数据，然后开启发送中断，一直发送，直到完成</li><li>发送完成后，将 eMBPoll的 事件状态机 置为 发送完成</li><li>事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲</li></ol><p>&emsp;&emsp;以上就是FreeModbus库实现<code>Modbus RTU</code>通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。写的很好，这份源码还是很推荐看的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍 搞嵌入式萌新 听别人吹牛的计算机概念——状态机&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机概念" scheme="http://shatang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式IIC总线</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8FIIC%E6%80%BB%E7%BA%BF/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式IIC总线/</id>
    <published>2020-05-30T03:17:49.000Z</published>
    <updated>2020-05-30T03:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇详细介绍嵌入式的IIC总线，方便以后写该总线的器件驱动。</p><a id="more"></a><h1 id="一、IIC总线讲解"><a href="#一、IIC总线讲解" class="headerlink" title="一、IIC总线讲解"></a>一、IIC总线讲解</h1><p>&emsp;&emsp;IIC的硬件管脚为 VCC，GND，SDA，SCL。IIC的主要构成只有两个双向的信号线，一个是数据线SDA,一个是时钟线SCL。IIC总线有主从之分。</p><p>&emsp;&emsp;IIC总线实现的方式分为两种：硬件IIC &amp; 软件模拟IIC。硬件IIC有主从之分；当然，软件I2C也是标准的I2C协议，当然有分主从，但一般情况下，软件IIC为主机模式，即发送请求接收响应信息。为什么要写从机呢？mcu 对 mcu ？)。由于每种MCU的硬件IIC总线配置各不相同，且有些芯片的IIC有Bug(Stm32)，故接下来只讲 软件IIC。</p><ul><li>由于实际应用上，IIC总线通讯速率本身就不高，因此，硬件IIC总线 &amp; 软件IIC总线<br>本身速率方面就没多差大差距，不需要考虑IIC总线切换为软、硬件实现方式会给程序带来隐患。</li><li>无论是 硬件IIC 还是 软件IIC ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应IIC从器件的datasheet。IIC总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。</li></ul><h1 id="二、-软件-IIC总线"><a href="#二、-软件-IIC总线" class="headerlink" title="二、 (软件)IIC总线"></a>二、 (软件)IIC总线</h1><h2 id="2-1-基本知识"><a href="#2-1-基本知识" class="headerlink" title="2.1 基本知识"></a>2.1 基本知识</h2><p>&emsp;&emsp;软件IIC，也能更好让我们了解IIC总线协议的实现方式。</p><img src="/2020/05/30/嵌入式IIC总线/0.png" title="IIC总线"><p>&emsp;&emsp;<strong>I2C总线通过上拉电阻接正电源。即当总线空闲时，两根线均为高电平</strong>。如此，连在总线上的任一器件输出的低电平，都可以使得总线的信号变低，也就是说各器件的SDA和SCL都是线”与”关系。 </p><img src="/2020/05/30/嵌入式IIC总线/1.png" title="数据有效性规定"><p>数据位(1\0)有效性规定：<strong>I2C总线进行数据传送时，时钟信号为高电平期间，SDA线上的数据必须保持稳定</strong>；只有在SCL线的信号为低电平器件，SDA线的才可进行高低电平状态变化。</p><blockquote><p>起始信号、终止信号、应答信号</p></blockquote><img src="/2020/05/30/嵌入式IIC总线/2.png" title="起始信号和终止信号"><ul><li>起始信号：SCL线为高电平期间，SDA线由高电平向低电平跳变(下降沿)—-是一种电平跳变时序信号</li><li>终止信号：SCL线为高电平期间，SDA线由低电平向高电平跳变(上升沿)—-是一种电平跳变的时序信号</li></ul><img src="/2020/05/30/嵌入式IIC总线/3.png" title="应答信号"><ul><li>应答信号：在接收数据的IC(接收器)在接收到8bit数据后，向发送数据的IC(发送器)发出特定的低电平脉冲，表示已收到数据。即发送器在时钟脉冲9期间释放数据线，这样接收器就可以反馈一个应答信号。ACK(低电平)—-规定为有效应答位，NACK(高电平)，规定为非应答位，表示接收器接收该字节咩有成功。</li></ul><h2 id="2-2-软件模拟IIC驱动程序函数编写"><a href="#2-2-软件模拟IIC驱动程序函数编写" class="headerlink" title="2.2 软件模拟IIC驱动程序函数编写"></a>2.2 软件模拟IIC驱动程序函数编写</h2><p>&emsp;&emsp;在IIC程序设计中，都是以8bit为基础进行数据的传输</p><img src="/2020/05/30/嵌入式IIC总线/4.png" title="信号要求"><ul><li>IO管教初始化</li><li>发出起始信号</li><li>发出终止信号</li><li>发出应答ACK<ul><li>功能要求：由于IIC为双向数据通信，当从机发送完数据，主机也需要发送应答信号来说我接收到你的信息了，此时从机才可变为接收状态，接收来自主机的数据。</li></ul></li><li>发出应答NACK<ul><li>功能要求：当IIC程序运行到主机读取从机数据完成，需要停止此次数据传输时，主机发送一个发出主无应答信号，从机接收到后就停止发送数据，并释放SDA线；之后主机才可发送终止信号，停止此次数据的传输。</li></ul></li><li>发送一个字节数据<ul><li>基本思路：SCL在为0时，可以进行SDA数据的配置，当SCL为1时，SDA数据一定要锁定。其次为数据的移位，将待发送数据与0x80进行与运算，获得最高位的数据，通过8次循环完成1byte的数据发送。</li></ul></li><li>读取一个字节，并发送ACK或NACK(发送NACK基通知从机发送器结束数据发送，释放SDA线(SDA接口置1)<ul><li>功能要求：发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号(故读取完需要发送 ACK 或 NACK )</li></ul></li><li>等待ACK应答<ul><li>功能要求：当IIC主机进行获取数值时，主机需要等待从机的应答信号，以此来判断从机是否完成了数据的接收。从主机方看，为IIC等待ASK函数。</li><li>基本思路：通过 延时等待从机的ACK是否发送出来，如果发送出来，则函数返回0，主机可继续发送数据，如果返回1，则从机没有应答，此时需要停止IIC数据传输。防止出现错误数据。</li></ul></li></ul><h2 id="2-3-从具体I2C器件中读写数据"><a href="#2-3-从具体I2C器件中读写数据" class="headerlink" title="2.3 从具体I2C器件中读写数据"></a>2.3 从具体I2C器件中读写数据</h2><blockquote><p><strong>主机写(发送)从机数据</strong></p></blockquote><img src="/2020/05/30/嵌入式IIC总线/5.png" title="主机写从机数据"><blockquote><p><strong>主机读(接收)从机数据</strong></p></blockquote><img src="/2020/05/30/嵌入式IIC总线/6.png" title="主机读从机数据"><p><strong><font color="red">Ps：</font>IIC器件往往是 器件地址+0 为写数据 ，器件地址+1 为读数据</strong></p><p>主机读从机的情况分为两种：</p><ul><li><strong>读操作之前，都是需要进行一次写操作(写入读地址)，表明你要读的是哪个地址的数据，然后在进行一次读操作(故有两个器件地址)；</strong>(这是一般情况)</li><li>直接进行读操作，截取所需数据段</li></ul><p>&emsp;&emsp;因为有些IIC器件(从机)，例如24C02，当你需要读取它的数据，你要跟它说读取哪个地址数据，故先进行写操作；有些IIC器件，例如SD2403，它的时间日期地址是固定的（寄存器地址：00H-06H），因此读取该器件数据时，直接进行读操作，然后读出来7个数据，截取00H-06H的数据后，停止读取(这是特殊情况)</p><blockquote><p>DEVICEADDRESS(器件地址)</p></blockquote><p>&emsp;&emsp;器件地址的8位地址信息因器件而异；</p><h1 id="三、软件IIC实例"><a href="#三、软件IIC实例" class="headerlink" title="三、软件IIC实例"></a>三、软件IIC实例</h1><h2 id="3-1-EEPROM-24C02通信基础——IIC协议"><a href="#3-1-EEPROM-24C02通信基础——IIC协议" class="headerlink" title="3.1 EEPROM_24C02通信基础——IIC协议"></a>3.1 EEPROM_24C02通信基础——IIC协议</h2><p>&emsp;&emsp;24C02是一个可储存 256(8bit)字节数据的EEPROM，因此他的<code>Word Address</code>为8bit(单字节)；而他的器件地址如下：</p><img src="/2020/05/30/嵌入式IIC总线/7.png" title="24C02地址信息"><p>据2.3.1图所示，主机对从机写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_WriteOneByte</span><span class="params">(u16 WriteAddr, u8 DataToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IIC_Starts();<span class="comment">//发出起始信号</span></span><br><span class="line">IIC_Send_Byte(<span class="number">0xA0</span>);<span class="comment">//写器件地址+写操作</span></span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC_Send_Byte(WriteAddr&gt;&gt;8);//发送高地址，适用于更高容量的EEPROM</span></span><br><span class="line"><span class="comment">//IIC_Wait_Ack();</span></span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(WriteAddr%<span class="number">256</span>);<span class="comment">//发送低地址</span></span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line">IIC_Send_Byte(DataToWrite);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line">IIC_Stop();</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//等AT24C02写数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据2.3.1图所示，主机对从机读操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u8 <span class="title">AT24CXX_ReadOneByte</span><span class="params">(u16 ReadAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 temp=<span class="number">0</span>;</span><br><span class="line">IIC_Start();  </span><br><span class="line">IIC_Send_Byte(<span class="number">0XA0</span>);<span class="comment">//发送器件地址0XA0,写操作</span></span><br><span class="line">IIC_Wait_Ack(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC_Send_Byte(ReadAddr/256);//发送高地址，适用于更高容量的EEPROM</span></span><br><span class="line"><span class="comment">//IIC_Wait_Ack();</span></span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(ReadAddr%<span class="number">256</span>);<span class="comment">//发送低地址</span></span><br><span class="line">IIC_Wait_Ack();    </span><br><span class="line">IIC_Start();      </span><br><span class="line">IIC_Send_Byte(<span class="number">0XA1</span>);<span class="comment">//进入接收模式</span></span><br><span class="line">IIC_Wait_Ack(); </span><br><span class="line">temp=IIC_Read_Byte(<span class="number">0</span>);<span class="comment">//读一个字节数据完成，并发出No_Ack(输入参数：0)</span></span><br><span class="line">IIC_Stop();    </span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-24C02程序拓展——datasheet"><a href="#3-2-24C02程序拓展——datasheet" class="headerlink" title="3.2 24C02程序拓展——datasheet"></a>3.2 24C02程序拓展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始写入长度为Len的数据</span></span><br><span class="line"><span class="comment">//该函数用于写入16bit或者32bit的数据.</span></span><br><span class="line"><span class="comment">//WriteAddr  :开始写入的地址  </span></span><br><span class="line"><span class="comment">//DataToWrite:数据数组首地址</span></span><br><span class="line"><span class="comment">//Len        :要写入数据的长度2,4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_WriteLenByte</span><span class="params">(u16 WriteAddr,u32 DataToWrite,u8 Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 t;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;Len;t++)</span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite&gt;&gt;(<span class="number">8</span>*t))&amp;<span class="number">0xff</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始读出长度为Len的数据</span></span><br><span class="line"><span class="comment">//该函数用于读出16bit或者32bit的数据.</span></span><br><span class="line"><span class="comment">//ReadAddr   :开始读出的地址 </span></span><br><span class="line"><span class="comment">//返回值     :数据</span></span><br><span class="line"><span class="comment">//Len        :要读出数据的长度2,4</span></span><br><span class="line"><span class="function">u32 <span class="title">AT24CXX_ReadLenByte</span><span class="params">(u16 ReadAddr,u8 Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 t;</span><br><span class="line">u32 temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;Len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp&lt;&lt;=<span class="number">8</span>;</span><br><span class="line">temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t<span class="number">-1</span>);     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查AT24CXX是否正常</span></span><br><span class="line"><span class="comment">//这里用了24XX的最后一个地址(255)来存储标志字.</span></span><br><span class="line"><span class="comment">//如果用其他24C系列,这个地址要修改</span></span><br><span class="line"><span class="comment">//返回1:检测失败</span></span><br><span class="line"><span class="comment">//返回0:检测成功</span></span><br><span class="line"><span class="function">u8 <span class="title">AT24CXX_Check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 temp;</span><br><span class="line">temp=AT24CXX_ReadOneByte(<span class="number">255</span>);<span class="comment">//避免每次开机都写AT24CXX   </span></span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0X55</span>)<span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line"><span class="keyword">else</span><span class="comment">//排除第一次初始化的情况</span></span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(<span class="number">255</span>,<span class="number">0X55</span>);</span><br><span class="line">    temp=AT24CXX_ReadOneByte(<span class="number">255</span>);  </span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0X55</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始读出指定个数的数据</span></span><br><span class="line"><span class="comment">//ReadAddr :开始读出的地址 对24c02为0~255</span></span><br><span class="line"><span class="comment">//pBuffer  :数据数组首地址</span></span><br><span class="line"><span class="comment">//NumToRead:要读出数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_Read</span><span class="params">(u16 ReadAddr,u8 *pBuffer,u16 NumToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(NumToRead)</span><br><span class="line">&#123;</span><br><span class="line">*pBuffer++=AT24CXX_ReadOneByte(ReadAddr++);</span><br><span class="line">NumToRead--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始写入指定个数的数据</span></span><br><span class="line"><span class="comment">//WriteAddr :开始写入的地址 对24c02为0~255</span></span><br><span class="line"><span class="comment">//pBuffer   :数据数组首地址</span></span><br><span class="line"><span class="comment">//NumToWrite:要写入数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_Write</span><span class="params">(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(NumToWrite--)</span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(WriteAddr,*pBuffer);</span><br><span class="line">WriteAddr++;</span><br><span class="line">pBuffer++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-实时时钟-SD2403——IIC总线"><a href="#3-3-实时时钟-SD2403——IIC总线" class="headerlink" title="3.3 实时时钟_SD2403——IIC总线"></a>3.3 实时时钟_SD2403——IIC总线</h2><p>&emsp;&emsp;SD2403是一个实时时钟，他的<code>Word Address</code>为8bit(单字节)；而他的器件地址如下：</p><img src="/2020/05/30/嵌入式IIC总线/8.png" title="SD2403地址信息"><p>据2.3图所示，主机对从机写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteOneByte</span><span class="params">(<span class="keyword">uint8_t</span> addr,<span class="keyword">uint8_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!SD2403_start())<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">SD2403_SendByte(<span class="number">0x64</span>);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_SendByte(addr);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_SendByte(data);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据2.3图所示，主机对从机读操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> SD2403_ReakOneByte(<span class="keyword">uint8_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint8_t</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//先写入要读取的寄存器</span></span><br><span class="line"><span class="keyword">if</span>(!SD2403_start()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">SD2403_SendByte(<span class="number">0x64</span>);  </span><br><span class="line"><span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">&#123;</span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SD2403_SendByte(addr); </span><br><span class="line">SD2403_WaitAck();</span><br><span class="line"></span><br><span class="line"><span class="comment">//再读取的寄存器数据</span></span><br><span class="line">SD2403_start();</span><br><span class="line">SD2403_SendByte(<span class="number">0x65</span>);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">res=SD2403_ReceiveByte(<span class="number">0</span>); </span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-SD2403程序拓展——datasheet"><a href="#3-4-SD2403程序拓展——datasheet" class="headerlink" title="3.4 SD2403程序拓展——datasheet"></a>3.4 SD2403程序拓展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> SD2403_ReadTimeDate(_strTimeDate *pstrTimeDate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i,dat[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_start()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    SD2403_SendByte(<span class="number">0x65</span>);</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">    &#123;</span><br><span class="line">        SD2403_stop();</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dat[i]=SD2403_ReceiveByte();</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">            dat[<span class="number">2</span>]=BCDTODEC(dat[<span class="number">2</span>]&amp;<span class="number">0x7F</span>);<span class="comment">//24小时舍弃最高位(区分12/24小时制)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dat[i]=BCDTODEC(dat[i]);</span><br><span class="line">        *(&amp;pstrTimeDate-&gt;ucSec +i)=dat[i];</span><br><span class="line">        <span class="keyword">if</span> (i!=<span class="number">6</span>)         <span class="comment">//最后一个数据不应答</span></span><br><span class="line">        &#123;</span><br><span class="line">            SD2403_ACK();<span class="comment">////ACK 低</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_No_ACK();<span class="comment">//ACK 高结束</span></span><br><span class="line">    SD2403_stop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint8_t</span> SD2403_WriteTimeDate(<span class="keyword">uint8_t</span> *pstrTimeDate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *set_time,i;</span><br><span class="line">    set_time=pstrTimeDate;</span><br><span class="line">    SD2403_WriteTimeOn();</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_start())<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    SD2403_SendByte(<span class="number">0x64</span>);</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">    &#123;</span><br><span class="line">        SD2403_stop();</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_SendByte(<span class="number">0x00</span>);<span class="comment">//设置写起始地址</span></span><br><span class="line">    SD2403_WaitAck();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">            SD2403_SendByte(<span class="number">0x80</span>|DECTOBCD(*set_time));<span class="comment">//最高位区分12/24小时制(1为24小时制)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SD2403_SendByte(DECTOBCD(*set_time));</span><br><span class="line">        SD2403_WaitAck();</span><br><span class="line">        set_time++;</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_stop();</span><br><span class="line">    SD2403_WriteTimeOff();</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******写SD2403允许程序******/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteTimeOn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WriteOneByte(<span class="number">0x10</span>,<span class="number">0x80</span>))<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    SD2403_WriteOneByte(<span class="number">0x0f</span>,<span class="number">0x84</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******写SD2403禁止程序******/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteTimeOff</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WriteOneByte(<span class="number">0x0f</span>,<span class="number">0</span>))<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">      SD2403_WriteOneByte(<span class="number">0x10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、拓展——软件IIC从机"><a href="#四、拓展——软件IIC从机" class="headerlink" title="四、拓展——软件IIC从机"></a>四、拓展——软件IIC从机</h1><p>&emsp;&emsp;要实现IIC从机功能，最核心的部分就是如何精确的抓住IIC_SCL，也就是IIC主机发出来的时钟信号。只有抓住精确的时钟SCL，才能正确的读取到SDA的数据，才能真正模拟出IIC时序。</p><p>&emsp;&emsp;但是要抓住SCL信号可不容易，IIC最高速度有400K，最小有效脉宽达到1.4us(数字0/1)，最小脉冲是0.8us(应答和STOP信号产生的尖刺)，采用中断来识别SCL是不可能的做到的，因为即使在最高主频72MHZ情况下，STM32最小指令周期是1/72(us)，从SCL中断发生到STM32进入中断响应，至少要要40个指令周期，也就是40/72(us)，加上堆栈操作及变量，很可能已经错过了SCL信号。</p><p>因此根据IIC主机的速度，从机实现方法分为两种：</p><ol><li>采用中断方式识别SCL(适用于总线速度较慢)</li><li>采用查询方式识别SCL(适用于总线速度较快)</li></ol><p>&emsp;&emsp;反过来言之，当你做成一个(从机)模块，实现软件模拟IIC，实际上还会因为IIC主机的因素来决定你这个模块的实际使用效果。如果是做模块化，还是推荐使用硬件IIC的方式实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇详细介绍嵌入式的IIC总线，方便以后写该总线的器件驱动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
      <category term="IIC" scheme="http://shatang.github.io/tags/IIC/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式SPI总线</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8FSPI%E6%80%BB%E7%BA%BF/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式SPI总线/</id>
    <published>2020-05-30T03:14:26.000Z</published>
    <updated>2020-05-30T03:23:10.444Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇详细介绍嵌入式的SPI总线，方便以后写该总线的器件驱动。</p><a id="more"></a><h1 id="一、SPI总线讲解"><a href="#一、SPI总线讲解" class="headerlink" title="一、SPI总线讲解"></a>一、SPI总线讲解</h1><p>&emsp;&emsp;SPI的主要构成有三根线，一个是数据输出线MOSI,一个是数据输入线MISO，一个是时钟线SCLK。</p><p>&emsp;&emsp;SPI总线实现的方式分为两种：硬件IIC &amp; 软件模拟SPI。硬件SPI有主从之分；当然，软件SPI也是标准的SPI协议，当然有分主从，但一般情况下，(MCU)软件SPI为主机模式，即发送请求接收从机的响应信息。</p><p>&emsp;&emsp;可能大家不知道为什么我这MCU就是SPI主机，凭啥？你可以反过来想一下，MCU通讯的其他器件实质上都是从机，MCU要你的数据才会去找你；如果你MCU也是从机模式，从机与从机怎么通信？由于每种MCU的硬件SPI总线配置各不相同，故接下来主要讲 软件SPI。</p><ul><li>SPI通信是串行同步全双工(同时收发)</li><li>IIC通信是串行同步半双工(单收或单发)</li><li>无论是 硬件SPI 还是 软件SPI ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应SPI从器件的datasheet。SPI总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。</li></ul><p><strong><font color="red">Ps：</font>硬件SPI总线 &amp; 软件SPI总线 速率方面是有点差距的。具体没有实测，但是既然是用了软件SPI总线，就不要纠结速度问题了。但是硬件SPI总线的速度也不是无上限的，而且还要根据主、从机的配置。</strong></p><hr><p>&emsp;&emsp;以W5500为例，该芯片的SPI总线速率最高达到80Mhz。如果主控采用stm32f103,主频为72Mhz，SPI时钟最大为18Mhz。因此stm32f103无法发挥W5500完全的性能。</p><p>&emsp;&emsp;而如果使用STM40x处理器，SPI时钟使用42Mhz，使用DMA方式，可以达到回环测试17Mbps的速率（收+发），单独发送可以达到13Mbps的速率。</p><p>&emsp;&emsp;也就是说，SPI的速率本身就受器件限制。如果从机SPI时钟较低，主机被限制；主机时钟较低，从机性能被限制。编写硬件SPI驱动的时候，要多注意 主控芯片、从机器件 的datasheet。</p><h1 id="二、-主机-软件SPI总线"><a href="#二、-主机-软件SPI总线" class="headerlink" title="二、(主机)软件SPI总线"></a>二、(主机)软件SPI总线</h1><p>&emsp;&emsp;硬件上为4根线：</p><ul><li><code>MISO</code> ：主设备数据输入，从设备数据输出。</li><li><code>MOSI</code> ：主设备数据输出，从设备数据输入。</li><li><code>SCLK</code> ：时钟信号，由主设备产生。</li><li><code>CS</code> ：从设备片选信号，由主设备控制。</li></ul><p><strong><font color="red">Ps：</font>外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。</strong></p><img src="/2020/05/30/嵌入式SPI总线/1.png" title="硬件SPI时钟信号的相位和极性"><p>&emsp;&emsp;由上图的(硬件)SPI通信协议可知，时钟信号的相位和极性，决定了获取数据的方式；2*2=4，于是有四种模式；</p><img src="/2020/05/30/嵌入式SPI总线/2.png" title="SPI通信模式"><p>CPOL决定时钟空闲状态(1为空闲高电平，0为空闲低电平)</p><img src="/2020/05/30/嵌入式SPI总线/3.png" title="SPI通信模式"><p>CPHA决定获取数据的时钟相位(1为延迟一个相位，第二次SCLK突变为空闲状态获取数据；0为直接相位，SCLK空闲状态突变时，直接获取数据)</p><img src="/2020/05/30/嵌入式SPI总线/4.png" title="SPI通信模式总结"><p>&emsp;&emsp;以上就是软件SPI的要点；实现具体的软件SPI，需要对器件的datasheet进行查阅，看是哪种模式。</p><table><thead><tr><th>模式</th><th>CPOL</th><th>CPHA</th></tr></thead><tbody><tr><td>MODE0</td><td>0</td><td>0</td></tr><tr><td>MODE1</td><td>0</td><td>1</td></tr><tr><td>MODE2</td><td>1</td><td>0</td></tr><tr><td>MODE3</td><td>1</td><td>1</td></tr></tbody></table><p>下面简单列一个 CPOL=1，CPHA=1的SPI写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">函数：SOFT_SPI_RW() </span></span><br><span class="line"><span class="comment">描述: 根据SPI协议，写一字节数据到从机，同时从从机 读出一字节</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function">u8 <span class="title">SOFT_SPI_RW</span><span class="params">(u8 byte)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">u8 i,Temp=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">// 循环8次 </span></span><br><span class="line">&#123; </span><br><span class="line">SPI1_SCK = <span class="number">0</span><span class="comment">//拉低时钟</span></span><br><span class="line"><span class="keyword">if</span>(byte&amp;<span class="number">0x80</span>)</span><br><span class="line">SPI1_MOSI = <span class="number">1</span>;<span class="comment">//若最到位为高，则输出高</span></span><br><span class="line"> <span class="keyword">else</span>       </span><br><span class="line">SPI1_MOSI = <span class="number">0</span>;<span class="comment">//若最到位为低，则输出低 </span></span><br><span class="line">byte &lt;&lt;= <span class="number">1</span>;<span class="comment">//低一位移位到最高位 </span></span><br><span class="line">SPI1_SCK = <span class="number">1</span>;<span class="comment">//拉高时钟</span></span><br><span class="line">Temp &lt;&lt;= <span class="number">1</span>;<span class="comment">//数据左移 </span></span><br><span class="line"><span class="keyword">if</span>(SPI1_MISO) </span><br><span class="line">Temp++;<span class="comment">//若从从机接收到高电平，数据自加一</span></span><br><span class="line"> SPI1_SCK = <span class="number">0</span>;<span class="comment">//拉低时钟</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (Temp);<span class="comment">//返回数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-FRAM-FM25L256为例——软件SPI"><a href="#2-1-FRAM-FM25L256为例——软件SPI" class="headerlink" title="2.1 FRAM_FM25L256为例——软件SPI"></a>2.1 FRAM_FM25L256为例——软件SPI</h2><p>&emsp;&emsp;FM25L256支持SPI模式的0和3，下面为CPOL=1，CPHA=1。基本的字节读写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write8bits</span></span><br><span class="line"><span class="comment">* 功  能 :  向存储器中写入一个字节</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write8bits</span><span class="params">(<span class="keyword">uint8_t</span> u8Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u8Data &amp; <span class="number">0x80</span>)         </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>          </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u8Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Read8bits</span></span><br><span class="line"><span class="comment">* 功  能 :  从存储器中读出一个字节的数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">FRAM_Read8bits</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">uint8_t</span> u8Data=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        u8Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        <span class="keyword">if</span>(FRAM_SDO_READ)</span><br><span class="line">            u8Data |= <span class="number">0x01</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    <span class="keyword">return</span>  u8Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-FRAM-FM25L256程序扩展——datasheet"><a href="#2-2-FRAM-FM25L256程序扩展——datasheet" class="headerlink" title="2.2 FRAM_FM25L256程序扩展——datasheet"></a>2.2 FRAM_FM25L256程序扩展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write16bits</span></span><br><span class="line"><span class="comment">* 功  能 :  发送16位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write16bits</span><span class="params">(<span class="keyword">uint16_t</span> u16Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u16Data &amp; <span class="number">0x8000</span>) </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>                 </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u16Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write32bits</span></span><br><span class="line"><span class="comment">* 返  回 :  写入的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write32bits</span><span class="params">(<span class="keyword">uint32_t</span> u32Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u32Data &amp; <span class="number">0x80000000</span>) </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>              </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u32Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Read4Bytes</span></span><br><span class="line"><span class="comment">* 功  能 :  读取指定地址的4字节数据</span></span><br><span class="line"><span class="comment">* 入  参 :  address  : 读取数据的首地址</span></span><br><span class="line"><span class="comment">* 返  回 :  uint32_t : 读出的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="keyword">uint32_t</span> FRAM_Read4Bytes(<span class="keyword">uint32_t</span> address)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_READ);</span><br><span class="line">    FRAM_Write16bits((<span class="keyword">uint16_t</span>)(address));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp  = temp &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        temp |= FRAM_Read8bits();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write4Bytes</span></span><br><span class="line"><span class="comment">* 功  能 :  写入指定地址的4字节数据</span></span><br><span class="line"><span class="comment">* 入  参 :  address  : 写入数据的首地址</span></span><br><span class="line"><span class="comment">*           FramData : 写入的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FRAM_Write4Bytes</span><span class="params">(<span class="keyword">uint32_t</span> address, <span class="keyword">uint32_t</span> FramData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> u8Temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_WREN);</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_WRITE);</span><br><span class="line">    FRAM_Write16bits((<span class="keyword">uint16_t</span>)(address));</span><br><span class="line">    FRAM_Write32bits(FramData);</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        FRAM_CS_L;</span><br><span class="line">        FRAM_Write8bits(FRAM_CMD_RDSR);<span class="comment">//读取状态寄存器</span></span><br><span class="line">        u8Temp = FRAM_Read8bits();</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        FRAM_CS_H;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该位表示写入启用状态(为0时，WPEN和 /WP 寄存器标志位不起作用)</span></span><br><span class="line"><span class="comment">//防止软件误改动铁电芯片寄存器配置</span></span><br><span class="line">        <span class="keyword">if</span>(!(u8Temp &amp; <span class="number">0x02</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇详细介绍嵌入式的SPI总线，方便以后写该总线的器件驱动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="SPI" scheme="http://shatang.github.io/tags/SPI/"/>
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式存储器</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式存储器/</id>
    <published>2020-05-30T03:09:32.000Z</published>
    <updated>2020-08-10T15:16:37.357Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备的存储器科普。</p><a id="more"></a><h1 id="一、存储器科普"><a href="#一、存储器科普" class="headerlink" title="一、存储器科普"></a>一、存储器科普</h1><p>&emsp;&emsp;<code>RAM</code>、<code>SRAM</code>、<code>SDRAM</code>、<code>ROM</code>、<code>EPROM</code>、<code>EEPROM</code>、<code>Flash</code>存储器可以分为很多种类;其中根据掉电数据是否丢失可以分为RAM（随机存取存储器）和ROM（只读存储器），其中RAM的访问速度比较快，但掉电后数据会丢失，而ROM掉电后数据不会丢失。</p><h2 id="1-1-常见存储器"><a href="#1-1-常见存储器" class="headerlink" title="1.1 常见存储器"></a>1.1 常见存储器</h2><p>&emsp;&emsp;在嵌入式开发过程中，往往会涉及到存储器(掉电存储等功能)；其中的 <strong>Flash</strong>，<strong>EEPROM</strong>，<strong>SRAM</strong>耳熟能详。 </p><ol><li><strong>Flash，适用于速度要求高，容量要求大，掉电时要求数据不丢失的场合</strong></li><li><strong>EEPROM，适用于速度不高，容量不大，掉电时要求数据不丢失的场合</strong></li><li><strong>SRAM，一般就相当于计算机的内存，断电不保存，读写速度比flash, eeprom快N倍</strong></li></ol><p>&emsp;&emsp;在单片机中，往往RAM主要是做运行时数据存储器,FLASH主要是程序存储器,EEPROM主要是用以在程序运行保存一些需要掉电不丢失的数据。</p><ul><li>FLASH:单片机运行的程序存储的地方</li><li>SRAM：存储单片机运行过程中产生的了临时数据</li><li>EEPROM：视用户的需要而定，一般用来存储系统的一些参数，这些参数可能需要修改，也可能不会修改。</li></ul><h2 id="1-2-EEPPROM-和-Flash-混淆来由"><a href="#1-2-EEPPROM-和-Flash-混淆来由" class="headerlink" title="1.2 EEPPROM 和 Flash 混淆来由"></a>1.2 EEPPROM 和 Flash 混淆来由</h2><p>&emsp;&emsp;EEPROM的全称是“电可擦除可编程只读存储器”，即Electrically Erasable Programmable Read-Only Memory。是相对于紫外擦除的rom来讲的。但是今天已经存在多种EEPROM的变种，变成了一类存储器的统称。</p><p><strong>狭义的EEPROM</strong>：这种rom的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。这是最传统的一种EEPROM，掉电后数据不丢失，可以保存100年，可以擦写100w次。具有较高的可靠性，但是电路复杂/成本也高。因此目前的EEPROM都是几十千字节到几百千字节的，绝少有超过512K的。</p><p><strong>Flash</strong>：属于广义的EEPROM，因为它也是电擦除的ROM。但是为了区别于一般的按字节为单位的擦写的EEPROM，我们都叫它Flash。</p><p>&emsp;&emsp;<strong>FLASH按扇区操作，EEPROM则按字节操作</strong>；二者寻址方法不同，存储单元的结构也不同，FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因而适合用作程序存储器，EEPROM则更多的用作非易失的数据存储器。当然用FLASH做数据存储器也行，但操作比EEPROM麻烦的多；所以更“人性化”(成本)的MCU设计会集成FLASH和EEPROM两种非易失性存储器，而廉价型设计往往只有 FLASH，早期可电擦写型MCU则都是EEPRoM结构，现在已基本上停产了。</p><p>&emsp;&emsp;EEPROM：电可擦除可编程只读存储器，Flash的操作特性完全符合EEPROM的定义，属EEPROM无疑，首款Flash推出时其数据手册上也清楚的标明是EEPROM，现在的多数Flash手册上也是这么标明的，<strong>二者的关系是“白马”和“马”</strong>。至于为什么业界要区分二者，主要的原因是 Flash EEPROM的操作方法和传统EEPROM截然不同，次要的原因是为了语言的简练，非正式文件和口语中Flash EEPROM就简称为Flash，这里要强调的是白马的“白”属性而非其“马”属性以区别Flash和传统EEPROM。</p><p>&emsp;&emsp;Flash的特点是结构简单，同样工艺和同样晶元面积下可以得到更高容量且大数据量下的操作速度更快，但<strong>Flash缺点是操作过程麻烦，特别是在小数据量反复重写时</strong>，所以<strong>在MCU中的Flash结构适于不需频繁改写的程序存储器</strong>。</p><p>&emsp;&emsp;很多应用中，<strong>需要频繁的改写某些小量数据且需掉电非易失，传统结构的EEPROM在此非常适合</strong>。所以很多MCU内部设计了两种EEPROM结构，FLASH的和传统的以期获得成本和功能的均衡，这极大的方便了使用者。随着ISP、IAP的流行，特别是在程序存储地址空间和数据存储地址空间重叠的MCU系中，现在越来越多的MCU生产商用支持IAP的程序存储器来模拟EEPROM对应的数据存储器，这是低成本下实现非易失数据存储器的一种变通方法。为在商业宣传上取得和双EEPROM工艺的“等效”性，不少采用Flash程序存储器“模拟”（注意，技术概念上并非真正的模拟）EEPROM数据存储器的厂家纷纷宣称其产品是带EEPROM的，严格说，这是非常不严谨的，但商人有商人的目的和方法，<strong>用Flash“模拟”EEPROM</strong>可以获取更大商业利益，所以在事实上，技术概念混淆的始作俑者正是他们。</p><h2 id="1-3-Flash的粗分"><a href="#1-3-Flash的粗分" class="headerlink" title="1.3 Flash的粗分"></a>1.3 Flash的粗分</h2><p>&emsp;&emsp;目前Flash主要有两种，NOR Flash和NAND Flash。</p><ul><li><strong>NOR Flash</strong>：NOR Flash的读取和我们常见的SDRAM的读取是一样，用户可以直接运行装载在NOR FLASH里面的代码，这样可以减少SRAM的容量从而节约了成本。</li><li><strong>NAND Flash</strong>：NAND Flash没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价。</li></ul><p><strong>Ps ：用户不能直接运行NAND Flash上的代码，因此很多使用NAND Flash的开发板除了使用NAND Flash以外，还作上了一块小的NOR Flash来运行启动代码</strong></p><p>&emsp;&emsp;一般小容量的用NOR Flash，因为其读取速度快，多用来存储操作系统等重要信息，而大容量的用NAND FLASH，最常见的NAND FLASH应用是嵌入式系统采用的DOC（Disk On Chip）和我们通常用的“闪盘”，可以在线擦除。目前市面上的FLASH 主要来自Intel，AMD，Fujitsu和Toshiba，而生产NAND Flash的主要厂家有Samsung和Toshib</p><h1 id="二、Flash的前世今生"><a href="#二、Flash的前世今生" class="headerlink" title="二、Flash的前世今生"></a>二、Flash的前世今生</h1><h2 id="2-1-Flash起源"><a href="#2-1-Flash起源" class="headerlink" title="2.1 Flash起源"></a>2.1 Flash起源</h2><p>&emsp;&emsp;Nand Flash 和 Nor Flash<br>是现在市场上两种主要的非易失闪存技术。Intel于1988年首先开发出NOR Flash 技术，彻底改变了原先由EPROM（Electrically Programmable Read-Only-Memory电可编程序只读存储器）和EEPROM（电可擦只读存储器Electrically Erasable Programmable Read - Only Memory）一统天下的局面。紧接着，1989年，东芝公司发表了NAND Flash 结构，强调降低每比特的成本，有更高的性能，并且像磁盘一样可以通过接口轻松升级。NOR Flash 的特点是芯片内执行（XIP ，eXecute In Place），这样应用程序可以直接在Flash闪存内运行，不必再把代码读到系统RAM。</p><hr><p><strong><font color="red">注：</font></strong><br>片内执行不是说程序在存储器内执行，CPU的基本功能就是取指、译码和执行。<strong>Nor Flash能在芯片内执行，就是指CPU的取指模块能够直接从NorFlash中把指令取出来，供后面的译码和执行模块使用。</strong></p><h2 id="2-2-Flash的差异"><a href="#2-2-Flash的差异" class="headerlink" title="2.2 Flash的差异"></a>2.2 Flash的差异</h2><p>&emsp;&emsp;由于Nor Flash的接口与RAM完全相同，可以随机访问任意地址的数据。因此，Nor Flash进行读操作的效率非常高，但是擦除和写操作的效率很低，另外，Nor Flash的容量一般比较小。</p><p>&emsp;&emsp;而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得Nor Flash适合于运行程序，而NAND Flash更适合于存储数据。</p><p>&emsp;&emsp;容量相同的情况下，NAND Flash的体积更小。市场上Nor Flash的容量通常为1MB<del>4MB(也有32MB的Nor Flash)，NAND Flash的容量为8MB</del>512MB。对于空间有严格要求的系统，NAND Flash可以节省更多空间。<strong>容量的差别也使得Nor Flash多用于存储程序，NAND Flash多用于存储数据。</strong></p><p>&emsp;&emsp;对于Flash存储器件的可靠性需要考虑3点：<strong>位反转、坏块和可擦除次数</strong>。所有Flash器件都遭遇位反转的问题：由于Flash固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误（这种概率很低），而NAND Flash出现的概率远大于Nor Flash，当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。当仅仅是报告位反转，重新读取即可：如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率史高，推荐使用EDC/ECC进行错误检测和恢复。NAND Flash上面会有坏块随机分布在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。</p><p>&emsp;&emsp;NAND Flash每块的可擦除次数通常在100000次左右，是Nor Flash的10倍。另外，因为NAND Flash的块大小通常是Nor Flash的1/8，单块的擦除需求更少，所以NAND Flash的寿命远远超过Nor Flash。</p><table><thead><tr><th align="center">-</th><th align="center">Nor</th><th align="center">NAND</th></tr></thead><tbody><tr><td align="center">XIP(代码可以直接运行)</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">性能(擦除)</td><td align="center">块大，非常慢(5s)</td><td align="center">块小，快(3ms)</td></tr><tr><td align="center">性能(写)</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">性能(读)</td><td align="center">快</td><td align="center">快</td></tr><tr><td align="center">可靠性</td><td align="center">较高，位反转的比例小于NAND Flash的10%</td><td align="center">比较低，位反转比较常见，必须有校验措施。且比如TNR必须有坏块管理措施</td></tr><tr><td align="center">可擦除次数</td><td align="center">10000 ~ 100000</td><td align="center">100000 ~ 1000000</td></tr><tr><td align="center">生命周期</td><td align="center">低于NAND Flash的10%</td><td align="center">是Nor Flash的10倍以上</td></tr><tr><td align="center">接口</td><td align="center">与RAM接口相同</td><td align="center">I/O接口</td></tr><tr><td align="center">易用性</td><td align="center">容易</td><td align="center">复杂</td></tr><tr><td align="center">主要用途</td><td align="center">常用于保存代码和关键数</td><td align="center">用于保存数据</td></tr><tr><td align="center">价格</td><td align="center">高</td><td align="center">低</td></tr></tbody></table><h1 id="三、-Nand-Flash"><a href="#三、-Nand-Flash" class="headerlink" title="三、 Nand Flash"></a>三、 Nand Flash</h1><p>&emsp;&emsp;由于Nand Flash的可靠性(位反转、坏块)，在比较低端的嵌入式设备并不采用Nand Flash，其容量大、擦写次数多在低端嵌入式设备中体现不出优势。Nand Flash会被采用于 嵌入式Linux设备，常见于使用NAND Flash的开发板除了使用NAND Flash以外，还作上了一块小的NOR Flash来运行启动代码。在linux上很多现成、高级的驱动，因此这里就不多讲Nand Flash。</p><p>&emsp;&emsp;我们写Nand Flash驱动，是写Nand Flash 控制器的驱动，而不是Nand Flash 芯片的驱动，因为独立的Nand Flash芯片，一般来说，是很少直接拿来用的，多数都是硬件上有对应的硬件的Nand Flash的控制器，去操作和控制Nand Flash，包括提供时钟信号，提供硬件ECC校验等等功能，我们所写的驱动软件，是去操作Nand Flash的控制器，然后由控制器去操作Nand Flash芯片，实现我们所要的功能。</p><h1 id="四、Nor-Flash"><a href="#四、Nor-Flash" class="headerlink" title="四、Nor Flash"></a>四、Nor Flash</h1><p>&emsp;&emsp;Nand Flash需要高级(算法处理)驱动，对低端嵌入式设备是一种考验。由于低端嵌入式设备往往对数据量要求不大，且对可靠性要求较高，往往采用Nor Flash。常见的用法是用于存储设备的历史记录，常见芯片有W25Qx系列的Nor Flash。</p><h2 id="4-1-Flash的擦除"><a href="#4-1-Flash的擦除" class="headerlink" title="4.1 Flash的擦除"></a>4.1 Flash的擦除</h2><p>&emsp;&emsp;像EEPROM等其他储存芯片是没有擦除这一说的。例如，iic接口的AT24Cx芯片，想要写入的数据直接覆盖在对应地址的数据上。</p><p>&emsp;&emsp;Nor Flash的物理特性是，写入之前需要先进行擦除。<strong>擦除从0变1，写入从1变0</strong>。<br>擦除后数据为全0xFF，此时写入操作，实际上是将数据从1改成0。</p><p>&emsp;&emsp;一般先擦后写(常见于W25Qx驱动)，但实际上擦除后每个位置是可以写入多次的，只要每次写入都是让某些bit从1变0即可。</p><p>&emsp;&emsp;例如，在擦除后数据为0xFF，此时写入0x0F，可读出0x0F，再写入0x01，可读出0x01，再写入0x00，可读出0x00。而对于0x00，就无法再改写成任何值了，因为此时每个bit都是0，想要改写就必须先擦除，让其恢复到0xFF，再进行写入改成目标值。</p><h2 id="4-2-“块，扇，页”的区别"><a href="#4-2-“块，扇，页”的区别" class="headerlink" title="4.2 “块，扇，页”的区别"></a>4.2 “块，扇，页”的区别</h2><p>&emsp;&emsp;从上面的擦除概念，引申出(硬件)磁盘的最小擦除单位(Sector)。这里的单位概念有：<strong>块(Block)，扇(Sector)，页</strong>。</p><ul><li>从底层驱动层面上看，Sector是最小存储单位(而且从驱动层面看并没有block的概念)</li><li>从软件(OS、文件系统)层面上看，Block才是文件存取的最小单位</li></ul><hr><p>&emsp;&emsp;OS、文件系统不是一个扇区一个扇区的来读数据，太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，Block才是文件存取的最小单位)。</p><ul><li>Block由一个或多个Sector组成；</li><li>Block是软件(OS、文件系统)中最小的操作单位</li><li>Sector是 底层驱动的最小操作单位(擦写)</li><li>Block值一般与sector值是不相等的</li></ul><hr><p>&emsp;&emsp;因此，在其他地方看到块为最小单位、扇为最小单位时，就可以知道他是以什么层面来看待存储的。</p><ul><li>Block是文件系统上的概念，一般文件系统block大小为4K(可以灵活设置块的大小)</li><li>Sector是磁介质硬盘最小单元，一般为512字节(现在有4K的了)</li><li>至于页，是为了驱动方便擦写、检测扇内部的写入情况，提出来的一个概念；实际上并没有多大关系。如果进行擦除，还是会以Sector做为最小单位进行擦除操作</li></ul><h2 id="4-3-坏块-amp-写平衡"><a href="#4-3-坏块-amp-写平衡" class="headerlink" title="4.3 坏块 &amp; 写平衡"></a>4.3 坏块 &amp; 写平衡</h2><p>&emsp;&emsp;这里先讲 坏块 这个概念。由于刚接触Flash底层的人，然后又经常听谁谁谁的移动硬盘坏块很多，或者是建议买硬盘后先做个坏块检测之类的事情。</p><blockquote><p>真正意义的 “坏块”</p></blockquote><p>&emsp;&emsp;闪存内的坏块处理，是指生产出的闪存并不是完美的，总会有某些比特或者某些区域不可使用，这时候就要对闪存进行坏块处理。</p><p>&emsp;&emsp;一开始生产的时候，发现到这个问题，想处理这些坏块。但是呢，由于处理起来成本太高(即，良品率太低)，索性就让他坏块，出厂前做下坏块处理，检测一下坏块数量不多就出厂了。</p><p>&emsp;&emsp;Nand Flash是存在挺多坏块的。我们那些移动硬盘，那么大容量，当然是采用Nand Flash做成的。至于遇到所谓的黑心商家，就是把坏块率高的(或者寿命较短，因为用过的)移动硬盘(Nand Flash)卖给你。</p><p>&emsp;&emsp;<strong>Nor Flash没有坏块</strong>(你可以认为)。实际上 Nor Flash 是存在坏块的，只不过是在内对坏块进行了处理。</p><blockquote><p>另类的 “坏块”</p></blockquote><p>&emsp;&emsp;另类的坏块，即寿命到了产生的不可写区域。一般人会混淆，认为不能用就是坏块(其实也算)。寿命到了不一定就不能用，只不过是容易产生”坏块”。尤其是嵌入式设备的Flash，由于对数据量要求不高，且对稳定性有高要求，往往采用的是Nor Flash做数据存储。</p><p>&emsp;&emsp;但是Nor Flash的擦写寿命相对较短，寿命将至闪存可能会工作异常(产生”坏块”)。写平衡(又名 磨损平衡、负载平衡)便应运而生。</p><p>&emsp;&emsp;由于Nor Flash的Sector(block)，都是有一定寿命限制的，所以如果你每次都往同一个Sector(block)擦除然后写入数据，稍微长时间，那么那个Sector(block)就很容易被用坏了。所以我们要去管理一下，将这么多次的对同一个Sector(block)的操作，平均分布到其他一些Sector(block)上面，使得在Sector(block)的使用上，相对较平均，这样相对来说，可以更能充分利用Nor Flash。</p><p>&emsp;&emsp;只进行一次大规模的擦除，后续的操作只需要进行写和读；写过的区域不再重写，读取的数据根据自己的需求算法，查出在Nor Flash的位置地址，读取想要的数据。当整个Nor Flash接近写满时，重新大规模擦除前，需要注意先擦除小部分区域，把所需的数据先读取出来，再重写入新擦除区域保存。</p><p><strong>写平衡</strong>，将空闲的Sector(Block)运用起来，进而将Nor Flash的寿命变相翻倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备的存储器科普。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Flash" scheme="http://shatang.github.io/tags/Flash/"/>
    
      <category term="ROM" scheme="http://shatang.github.io/tags/ROM/"/>
    
      <category term="SRAM" scheme="http://shatang.github.io/tags/SRAM/"/>
    
  </entry>
  
  <entry>
    <title>TCP通讯_宏观</title>
    <link href="http://shatang.github.io/2020/05/30/TCP%E9%80%9A%E8%AE%AF-%E5%AE%8F%E8%A7%82/"/>
    <id>http://shatang.github.io/2020/05/30/TCP通讯-宏观/</id>
    <published>2020-05-30T03:00:58.000Z</published>
    <updated>2020-05-30T03:02:24.990Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;该篇介绍宏观层面的TCP/IP协议</p><img src="/2020/05/30/TCP通讯-宏观/1.png" title="TCP/IP 参考模型"><a id="more"></a><h1 id="一、TCP-IP-协议的层次结构-宏观"><a href="#一、TCP-IP-协议的层次结构-宏观" class="headerlink" title="一、TCP/IP 协议的层次结构(宏观)"></a>一、TCP/IP 协议的层次结构(宏观)</h1><p>&emsp;&emsp;TCP/IP参考模型分为四个层次：应用层、传输层、网络(互连)层和主机到网络层(数据链路层)</p><img src="/2020/05/30/TCP通讯-宏观/2.png" title="TCP/IP 模型层次"><h2 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h2><p>&emsp;&emsp;应用层面向不同的网络应用引入了不同的应用层协议。</p><ul><li>传输层采用<strong>TCP协议</strong>的有：<ul><li><code>HTTP</code>：超文本传输协议（Hyper Text Transfer Protocol）</li><li><code>HTTPS</code>:超文本传输安全协议（Hyper Text Transfer Protocol Secure）</li><li><code>FTP</code>：文件传输协议（File Transfer Protocol）它定义了本地登录用户与远程服务器之间的交互过程。</li><li><code>SFTP</code>：文件加密传输协议（Secure File Transfer Protocol）</li><li><code>TELNET</code>：远程登录（Telecommunications Network）提供远程访问其它主机功能,它允许用户登录 internet主机,并在这台主机上执行命令. </li></ul></li><li>传输层采用<strong>UDP协议</strong>的有：（一次性传输的数据需求很少）<ul><li><code>TFTP</code>：简单文件传输协议（Trivial File Transfer Protocol）FTP的简化版本</li><li><code>SNMP</code>：简单网络管理协议（Simple Network Management Protocol）该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等. </li><li><code>NTP</code>：网络时间协议（Network Time Protocol）</li></ul></li><li>传输层同时采用TCP和UDP协议的有：<ul><li><code>DNS</code>(域名系统)：该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. </li></ul></li></ul><img src="/2020/05/30/TCP通讯-宏观/3.png" title="应用层具体应用"><p><strong><font color="red">Ps：</font></strong><br>HTTP是面向网页（文本信息）的，而FTP是面向文件的</p><h2 id="1-2-传输层"><a href="#1-2-传输层" class="headerlink" title="1.2 传输层"></a>1.2 传输层</h2><p><code>TCP</code>：传输控制协议（transmission control protocol）<br><code>UDP</code>：用户数据报协议（user datagram protocol）</p><p><strong><code>TCP</code>与<code>UDP</code>的区别：</strong> </p><ol><li>基于连接与无连接;</li><li>对系统资源的要求（TCP较多，UDP少）;</li><li>UDP程序结构较简单;</li><li>流模式与数据报模式; </li><li>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证.</li></ol><p><strong><code>TCP</code> 与 <code>UDP</code> 的<font color="red">主要区别</font>：</strong></p><p>&emsp;&emsp;UDP具有TCP所望尘莫及的速度优势，但在于UDP不一定提供可靠的数据传输。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。</p><p><strong><font color="red">Ps：</font></strong><br>许多程序将使用单独的TCP连接和单独的UDP连接;重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。</p><h2 id="1-3-网络层（网络互连层）"><a href="#1-3-网络层（网络互连层）" class="headerlink" title="1.3 网络层（网络互连层）　"></a>1.3 网络层（网络互连层）　</h2><p>&emsp;&emsp;网络互连层定义了分组格式和协议。</p><p>&emsp;&emsp;网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。　　</p><ul><li><code>IP</code>：Internet 协议（Internet Protocol） </li><li><code>ICMP</code>：Internet控制信息协议 </li><li><code>ARP</code>：地址解析协议 </li><li><code>RARP</code>：反向地址解析协议</li></ul><h2 id="1-4-网络访问层（主机到网络层）"><a href="#1-4-网络访问层（主机到网络层）" class="headerlink" title="1.4 网络访问层（主机到网络层）　　　　　"></a>1.4 网络访问层（主机到网络层）　　　　　</h2><p>&emsp;&emsp;网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接。</p><h1 id="二、常见术语、疑问-介绍"><a href="#二、常见术语、疑问-介绍" class="headerlink" title="二、常见术语、疑问 介绍"></a>二、常见术语、疑问 介绍</h1><p>&emsp;&emsp;TCP/IP协议：是一组网络协议。<strong>在这些协议中，最重要、最著名的就是TCP和IP因此，大部分网络管理员称整个协议族为“TCP/IP”</strong>。包括：TCP，IP，UDP，ARP等，这些被称为子协议。</p><h2 id="2-1-TCP与IP的区别"><a href="#2-1-TCP与IP的区别" class="headerlink" title="2.1 TCP与IP的区别"></a>2.1 TCP与IP的区别</h2><p>&emsp;&emsp;由第一章的TCP/IP 协议的层次结构可知，<code>TCP</code> 和 <code>IP</code> 是在不同层的，因此两者本来就天差地别。</p><ul><li><code>TCP</code>：位于传输层，是一种面向连接的、端对端的、可靠的、基于IP的传输层协议。主要特点是3次握手建立连接，4次挥手断开连接。</li><li><code>IP</code>：位于网络层，IP协议规定了数据传输时的基本单元（数据包）和格式，IP协议还定义了数据包的递交办法和路由选择。</li></ul><p>总结：</p><ol><li>整个网络中的传输流程是：IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层——TCP层；相反，IP层也把从TCP接收来的数据包传送到更低层。</li><li>TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步加工，如提供端口号等等。</li></ol><h2 id="2-2-Telnet的衍生（SSH等）"><a href="#2-2-Telnet的衍生（SSH等）" class="headerlink" title="2.2 Telnet的衍生（SSH等）"></a>2.2 Telnet的衍生（SSH等）</h2><p>&emsp;&emsp;<code>TELNET</code>：远程登录（Telecommunications Network）提供远程访问其它主机功能;听起来很陌生，但实际上我们是经常使用远程登录的功能，即使用Telnet的衍生;</p><p>&emsp;&emsp;<code>Telnet</code>用来訪问远程计算机的TCP/IP协议以控制你的网络设备，是明码传输，缺乏安全性。因此诞生了远程登录的加密传输，如下：</p><p><code>SSH</code>：Secure Shell（包括SSH1和SSH2）<br><code>Telnet/SSL</code>： Secure Socket Layer。Telnet/SSL是带有SSL的Telnet。<br><code>Rlogin</code>：Rlogin和Telnet功能使用方法相似，可是简单非常多。<br><code>Serial</code>：串行指每次一个事件，它通常跟并行即一次发生多个事件相反，例如键盘和鼠标仅仅须要串行接口和线路<br><code>TAPI</code>：telephone Application Programming Interface （它能够使用户在电脑上通过电话或视频电话与电话还有一端的人进行交谈）电话应用编程接口<br><code>RAW</code>：大多数打印设备的默认协议</p><h2 id="2-3-VPN和SS、SSR"><a href="#2-3-VPN和SS、SSR" class="headerlink" title="2.3 VPN和SS、SSR"></a>2.3 VPN和SS、SSR</h2><p>&emsp;&emsp;这里讲一下大家常见到的VPN和SSR的来头。</p><h3 id="2-3-1-什么是VPN"><a href="#2-3-1-什么是VPN" class="headerlink" title="2.3.1 什么是VPN"></a>2.3.1 什么是VPN</h3><p>&emsp;&emsp;vpn在很多人心目中就是用来科学上网的工具，其实不是。vpn最主要的功能，并不是用来科学上网，只是它可以达到科学上网的目的。vpn–虚拟专用网络，它的功能是：在公用网络上建立专用网络，进行加密通讯。</p><h3 id="2-3-2-什么是ss-ssr"><a href="#2-3-2-什么是ss-ssr" class="headerlink" title="2.3.2 什么是ss/ssr"></a>2.3.2 什么是ss/ssr</h3><p>ss：ss作者是clowwindy，大约两年前，他自己为了科学上网写了shadowsocks，简称ss或者叫影梭，后来他觉得这个东西非常好用，速度快，而且不会被封锁，他就把源码共享在了github上，然后就火了，但是后来作者被请去喝茶，删了代码，并且保证不再参与维护更新。现在这个好像是一个国外的大兄弟在维护。</p><p>ssr：在ss作者被喝茶之后，github上出现了一个叫breakwa11(破娃)的帐号，声称ss容易被防火墙检测到，所以在混淆和协议方面做了改进，更加不容易被检测到，而且兼容ss，改进后的项目叫shadowsocks-R，简称ssr，然后ss用户和ssr用户自然分成了两个派别，互相撕逼，直到前阵子，破娃被人肉出来，无奈之下删除了ssr的代码，并且解散了所有相关群组。</p><p>ss和ssr它的原理都是一样的，就是socks5代理。socks代理只是简单的传递数据包，而不必关心是何种协议，所以socks代理比其他应用层代理要快的多。socks5代理是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地，这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理。通俗的说，现在你有一个代理服务器在香港，比如你现在想要访问google，你的电脑发出请求，流量通过socks5连接发到你在香港的服务器上，然后再由你在香港的服务器去访问google，再把访问结果传回你的电脑，这样就实现了科学上网。</p><h2 id="2-4-DNS"><a href="#2-4-DNS" class="headerlink" title="2.4 DNS"></a>2.4 DNS</h2><p>&emsp;&emsp;<strong>DNS是域名解析服务器，是把网址变成IP地址的服务器</strong>。DNS说白了是把<strong>域名</strong>翻译成IP地址用的。</p><p>举例 ，例如我们在浏览器里面输入<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>这个域名翻译成了IP地址<code>61.135.169.105</code>。</p><p>&emsp;&emsp;这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，<strong>如果不设置DNS的话，是无法正常访问网页的</strong>。</p><p>&emsp;&emsp;注意！是无法正常访问网页，还是能够上网的。如果没有填写DNS，可以直接使用形如 <code><a href="http://192.168.2.10" target="_blank" rel="noopener">http://192.168.2.10</a></code> IP地址的形式来进行 网页访问。</p><h2 id="2-5-Socket-和-端口号"><a href="#2-5-Socket-和-端口号" class="headerlink" title="2.5 Socket 和 端口号"></a>2.5 Socket 和 端口号</h2><p>&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。</p><h3 id="2-5-1-端口号来源"><a href="#2-5-1-端口号来源" class="headerlink" title="2.5.1 端口号来源"></a>2.5.1 端口号来源</h3><p>&emsp;&emsp;当两台机器通过IP链接通讯，当如果其中一台机器还想和别的机器搞事情呢？例如你浏览多个网页，那怎么办？现在都讲究多进程、多线程，那多进程怎么区分了链接，就衍生出端口号。同个IP，开放多个<strong>port</strong>(端口号)，多个进程执行数据交互。</p><p><strong><font color="red">Ps：</font></strong><br>端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。</p><p>&emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。</p><h3 id="2-5-2-Socket"><a href="#2-5-2-Socket" class="headerlink" title="2.5.2 Socket"></a>2.5.2 Socket</h3><p><strong>Socket</strong>：就是 传输层TCP协议 到 应用层<code>HTTP</code>、<code>HTTPS</code>、<code>FTP</code>的基石。中文：套接字。指代承载这种通讯的TCP系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号)。</p><p>&emsp;&emsp;无论是什么模块进行连接网络通信，最终都会进行应用层的数据交互(除了裸流)。但是传输层和应用层的TCP连接是有基石的，那就是Socket。</p><p>&emsp;&emsp;由于往往是听过应用层协议连接，而Socket是作为应用层基石。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）。通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</p><p>&emsp;&emsp;Socket虽然是 传输层TCP协议&amp;应用层的基石。但是也可以不需要应用层，也就是裸流连接。常见于菜鸟的服务器，即没有任何通信协议，就像是用串口调试助手直接连一样。外面的人常直接称呼 TCP通信。</p><p><strong><font color="red">Ps：</font></strong><br>这种Socket连接方式，常见于嵌入式物联网、简单物联设备等。</p><p>&emsp;&emsp;Socket如果是严格区分的话，它带有的资源应该是：本地端口号、远地IP地址、远地端口号。因为本地IP定义下来后就不会再更改，实现多Socket链接通信，其实需要的就是多个 本地端口号、远地IP地址、远地端口号，组合成多Socket通信。</p><h2 id="2-6-内网穿透"><a href="#2-6-内网穿透" class="headerlink" title="2.6 内网穿透"></a>2.6 内网穿透</h2><p>&emsp;&emsp;内网穿透概念往往用于 大学、公司内部。</p><p>&emsp;&emsp;简单来说内网就是我们常说的局域网（LAN），而外网则是指广域网（WAN）。比如大学、医院、或者政府机构这些单位中，给每一个人分配一个IP地址，这显然是不现实的：一方面是因为这些单位的人员数量庞大，另一方面是因为人员数量也是变动的。为了解决这个问题，就出现了内网。</p><p>&emsp;&emsp;也就是说分配真实的IP，实际上只分配给广域网。局域网则是由网络管理员给的虚拟IP。</p><blockquote><p>内网和外网的区别</p></blockquote><p>以大学的校园网为例：</p><ul><li>一个大学的校园网至少有一个真实的IP地址，这个真实IP地址会作为整个校园网的出口，而其他的IP地址被称为假IP地址，假的IP地址发送的网络请求会通过真实的IP地址发送到因特网上，并将获得的资源再通过这个真实的IP地址返回过来。就这样完成了网络通讯的过程。</li><li>你连学校内网，登上你的百度账号，下载百度文库的文件，会显示你是xx学校的，然后免费下载，就是因为你的网络请求实际上是从 学校真实的IP 发出去的。因此百度才会知道你是xx学校的。</li></ul><p><strong>假IP地址的特点：它能够访问外网IP地址，但外网IP地址却无法找这个假的IP地址。</strong></p><p>&emsp;&emsp;因此如果想要从外网IP地址找到该虚拟IP地址，这台内网电脑就要实现<strong>内网穿透</strong>，常见的有花生壳。</p><h2 id="2-7-现实的网络插口"><a href="#2-7-现实的网络插口" class="headerlink" title="2.7 现实的网络插口"></a>2.7 现实的网络插口</h2><p>&emsp;&emsp;在现实生活中的网络插口，则是有两个灯，一绿一橙。</p><ul><li>绿灯表示物理连接线正常，即网线有插好</li><li>橙灯表示网络通讯，如果在闪烁，说明在通讯；接近常亮，就说明通讯频率高</li><li>如果两个灯都正常，而网络异常；就要考虑是不是外部网络出现问题，例如DNS之类的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;该篇介绍宏观层面的TCP/IP协议&lt;/p&gt;
&lt;img src=&quot;/2020/05/30/TCP通讯-宏观/1.png&quot; title=&quot;TCP/IP 参考模型&quot;&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="TCP/IP" scheme="http://shatang.github.io/tags/TCP-IP/"/>
    
      <category term="TCP" scheme="http://shatang.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://shatang.github.io/tags/UDP/"/>
    
      <category term="SSH" scheme="http://shatang.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>TCP通讯_微观</title>
    <link href="http://shatang.github.io/2020/05/30/TCP%E9%80%9A%E8%AE%AF-%E5%BE%AE%E8%A7%82/"/>
    <id>http://shatang.github.io/2020/05/30/TCP通讯-微观/</id>
    <published>2020-05-30T03:00:40.000Z</published>
    <updated>2020-05-30T03:08:23.838Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;该篇介绍微观层面的TCP/IP协议————基于W5500的嵌入式TCP通讯开发</p><a id="more"></a><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><p>&emsp;&emsp;这里将会连续引申出微观TCP/IP协议的一些概念。嵌入式的TCP通讯最重要的一个概念，就是IP地址。</p><h2 id="1-1-IP地址"><a href="#1-1-IP地址" class="headerlink" title="1.1 IP地址"></a>1.1 IP地址</h2><h3 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1 概念"></a>1.1.1 概念</h3><p>&emsp;&emsp;IP地址，英文名为IP Address，是internet protocol address的缩写，译为互联网协议地址，又译为网际协议地址。它是IP协议（internet protocol ）提供的一种统一的地址格式，分配给使用IP协议的设备的数字标签。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。更通俗的来说，IP地址给网上的每个通信设备分配了一个编号，每台联网的主机都需要有这个编号来通信。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。</p><h3 id="1-1-2-表示"><a href="#1-1-2-表示" class="headerlink" title="1.1.2 表示"></a>1.1.2 表示</h3><p>通常所说的IP地址，是指IPv4。IP地址是一个32位的二进制数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000111111110000000011111111</span></span><br></pre></td></tr></table></figure><p>通常被分割为4个8位二进制数，例如上面这个IP地址，可以分割为如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>    <span class="number">11111111</span>     <span class="number">00000000</span>     <span class="number">11111111</span></span><br></pre></td></tr></table></figure><p>再使用十进制数来表示每个8位二进制数，十进制数之间使用点号分隔，IP地址最终表示成如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.b.c.d</span><br></pre></td></tr></table></figure><p>因为一个8位二进制数表示的范围00000000 ~ 11111111正好对应十进制数0 ~ 255，所以a、b、c和d都是0 ~ 255的十进制整数。例如上面IP地址，可以表示为0.255.0.255.<br>（1）冒分十六进制表示法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X:X:X:X:X:X:X:X</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中每个X表示地址中的16b，以十六进制表示，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCD:EF01:<span class="number">2345</span>:<span class="number">6789</span>:ABCD:EF01:<span class="number">2345</span>:<span class="number">6789</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种表示法中，每个X的前导0是可以省略的，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2001</span>:<span class="number">0</span>DB8:<span class="number">0000</span>:<span class="number">0023</span>:<span class="number">0008</span>:<span class="number">0800</span>:<span class="number">200</span>C:<span class="number">417</span>A→ <span class="number">2001</span>:DB8:<span class="number">0</span>:<span class="number">23</span>:<span class="number">8</span>:<span class="number">800</span>:<span class="number">200</span>C:<span class="number">417</span>A</span><br></pre></td></tr></table></figure><p>（2）0位压缩表示法<br>&emsp;&emsp;在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FF01:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1101</span> → FF01::<span class="number">1101</span></span><br><span class="line"><span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span> → ::<span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span> → ::</span><br></pre></td></tr></table></figure><p>（3）内嵌IPv4地址表示法<br>为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X:X:X:X:X:X:d.d.d.d</span><br></pre></td></tr></table></figure><p>前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>与::FFFF:<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用。</p><h3 id="1-1-3-IPv4地址分类"><a href="#1-1-3-IPv4地址分类" class="headerlink" title="1.1.3 IPv4地址分类"></a>1.1.3 IPv4地址分类</h3><p>网络号或网络地址（NetID）：用于识别主机所在的网络；<br>主机号或主机地址（HostID）：用于识别该网络中的主机；<br>&emsp;&emsp;为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。<br><strong>私有地址：所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址。</strong></p><table><thead><tr><th>类别</th><th>用途</th><th>网络号和主机号</th><th>最高位</th><th>地址范围</th><th>私有地址和保留地址</th><th>子网掩码</th></tr></thead><tbody><tr><td>A</td><td>保留给政府机构</td><td>第一段表示网络地址，剩下三段表示主机地址</td><td>0</td><td>0.0.0.0——127.255.255.255</td><td>①10.X.X.X是私有地址 ②127.X.X.X是保留地址</td><td>255.0.0.0</td></tr><tr><td>B</td><td>分配给中等规模的公司</td><td>前两段表示网络地址，后两段表示主机地址</td><td>10</td><td>128.0.0.0——191.255.255.255</td><td>①172.16.0.0—172.31.255.255是私有地址②169.254.X.X是保留地址；191.255.255.255是广播地址，不能分配。</td><td>255.255.0.0</td></tr><tr><td>C</td><td>分配给任何需要的人</td><td>前三段表示网络地址，剩下一段表示主机地址</td><td>110</td><td>192.0.0.0——223.255.255.255</td><td>192.168.X.X是私有地址</td><td>255.255.255.0</td></tr><tr><td>D</td><td>用于组播</td><td>不分网络地址和主机地址</td><td>1110</td><td>224.0.0.0——239.255.255.255</td><td></td><td></td></tr><tr><td>E</td><td>用于实验</td><td>不分网络地址和主机地址</td><td>11110</td><td>240.0.0.0——255.255.255.254</td><td></td><td></td></tr></tbody></table><p>如图：</p><p>&emsp;&emsp;这里就不再详细介绍IP地址中的一些特殊地址了；我们目前主要用的是C类别，也就是192.168.X.X的私有地址</p><h2 id="1-2-子网掩码"><a href="#1-2-子网掩码" class="headerlink" title="1.2 子网掩码"></a>1.2 子网掩码</h2><p>&emsp;&emsp;IP地址填完后，网段不同，是并不能够直接通讯的；(平常)路由器连接的是不同的网络，网桥连接的是不同网段，这里的网络和网段有什么区别呢？</p><h3 id="1-2-1-网段"><a href="#1-2-1-网段" class="headerlink" title="1.2.1 网段"></a>1.2.1 网段</h3><p>&emsp;&emsp;路由器连接的是不同的网络，这里的网络就是网段不同的网段和不同的网络是同一个概念；专业点就说网段，通俗一点就说网络，其实就是一个意思。</p><ul><li>那什么是同一网段？<br>同一网段指的是IP地址和子网掩码相与得到相同的网络地址；<br>想在同一网段，必需做到网络标识相同；各类IP的网络标识算法都是不一样的，需要根据子网掩码的位数来判断。</li></ul><ul><li>那什么是掩码？</li></ul><ul><li>想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？</li></ul><h3 id="1-2-2-掩码"><a href="#1-2-2-掩码" class="headerlink" title="1.2.2 掩码"></a>1.2.2 掩码</h3><p>&emsp;&emsp;掩码，是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。<br>用途：将源码与掩码经过按位运算或逻辑运算得出新的操作数。其中要用到按位运算如OR运算和AND运算。用于如将ASCII码中大写字母改作小写字母。</p><p>举例：如A的ASCII码值为65= (01000001)2，a的ASCII码值为97=(01100001)2，要想把大写字母A转化为小写字母只需要将A的ASCII码与(00100000)2进行或运算就可以得到小写字母a。<br>&emsp;&emsp;子网掩码，即就是用来算网络标识的掩码.</p><h3 id="1-2-3-网络标识"><a href="#1-2-3-网络标识" class="headerlink" title="1.2.3 网络标识"></a>1.2.3 网络标识</h3><ol><li><p>算法只要把IP和子网掩码的每位数AND就可以了。</p></li><li><p>AND方法：0&amp;1=0　0&amp;0=0　1&amp;1=1</p></li><li><p>如：And　<code>192.168.0.1</code>，<code>255.255.255.0</code>，先转换为二进制，然后AND每一位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP            <span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.00000001</span></span><br><span class="line">子网掩码      <span class="number">11111111.11111111</span><span class="number">.11111111</span><span class="number">.00000000</span></span><br><span class="line">得出AND结果   <span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.00000000</span></span><br></pre></td></tr></table></figure></li><li><p>转换为十进制192.168.0.0，这就是网络标识，</p></li><li><p>再将子网掩码反取，也就是00000000.00000000.00000000.11111111，与IP　AND</p></li><li><p>得出结果00000000.00000000.00000000.00000001，转换为10进制，即0.0.0.1；这0.0.0.1就是主机标识。要想在同一网段，必需做到网络标识一样。</p></li></ol><p>这里介绍最常用的两种子网掩码，它们分别是“<code>255.255.255.0</code>”和“<code>255.255.0.0</code>”。</p><h2 id="1-3-网关地址"><a href="#1-3-网关地址" class="headerlink" title="1.3 网关地址"></a>1.3 网关地址</h2><p>&emsp;&emsp;如果网段不同，就实现不了通信，但现实生活中那么多设备肯定不在同个网段；那么不同网段确能够通信，就需要 网关 了.<br>&emsp;&emsp;网关（gateway）是一个网络连接到另一个网络的“关口”，网关地址实质上是一个网络通向其他网络的IP地址，主要用于不同网络间数据传输。网关在网段内的可用ip中选一个，一般选择是第一个或最后一个。</p><p>举例:比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1 ~ 192. 168.1.254”，子网掩码是255.255.255.0；如果需要与其他网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为网段内其他的一个IP地址。网络B的IP地址范围是“192.168.2.1 ~ 192.168.2.254”，子网掩码255.255.255.0。如果需要与其他网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为网段内其它的一个ip地址。</p><ul><li>网关是如何实现通信？<br>&emsp;&emsp;在没有路由器的情况下，不同的网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的的主机不再本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。所以说，设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。</li></ul><ul><li>网关设置方式有哪些？</li></ul><ol><li>手动设置：手动设置适用于电脑数量比较少、TCP/IP参数基本不变的情况，比如只有几台到十几台电脑。因为这种方法需要在联入网络的每台电脑上设置“默认网关”，非常费劲，一旦因为迁移等原因导致必须修改默认网关的IP地址，就会给网管带来很大的麻烦，所以不推荐使用。</li><li>自动设置：利用DHCP服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。这种方法适用于网络规模较大、TCP/IP参数有可能变动的网络。</li></ol><h2 id="1-4-MAC地址"><a href="#1-4-MAC地址" class="headerlink" title="1.4 MAC地址"></a>1.4 MAC地址</h2><p>&emsp;&emsp;媒体访问控制（media access control，MAC）是物理地址、硬件地址，用来定义网络设备的位置。</p><p>ip是虚拟地址；mac是网卡地址全世界只有一种没重复的。MAC是网络中用来识别网卡设备的唯一网络地址；由相关硬件制造商统一分配，每台电脑的MAC地址都是唯一的</p><h2 id="1-5-DNS"><a href="#1-5-DNS" class="headerlink" title="1.5 DNS"></a>1.5 DNS</h2><p>&emsp;&emsp;DNS是域名解析服务器，是把网址变成IP地址的服务器。DNS说白了是把域名翻译成IP地址用的；</p><p>举例 ，例如我们在浏览器里面输入<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>这个域名翻译成了IP地址<code>61.135.169.105</code>。</p><p>这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，如果不设置的话，是无法正常访问网页的。</p><h2 id="1-6-Socket-和-端口号"><a href="#1-6-Socket-和-端口号" class="headerlink" title="1.6 Socket 和 端口号"></a>1.6 Socket 和 端口号</h2><p>&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。</p><p>这里引入 <strong>端口号</strong> 的概念：一个计算机上可以有多个进程作为(多个)服务器 or 客户端 ，但是 ip 每个机器只有一个，所以通过不同的 <strong>port</strong> 数字加以区分。</p><p><strong><font color="red">Ps：</font></strong>端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。</p><p>&emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。</p><p><strong>Socket</strong>   ：  就是指代承载这种通讯的系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号)</p><p><strong><font color="red">Ps：</font></strong>Socket是一个接口，在用户进程与TCP/IP协议之间充当中间人，完成TCP/IP协议的书写，用户只需理解接口即可。</p><h1 id="二、基于W5500的TCP通讯"><a href="#二、基于W5500的TCP通讯" class="headerlink" title="二、基于W5500的TCP通讯"></a>二、基于W5500的TCP通讯</h1><p>&emsp;&emsp;等待更新中。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;该篇介绍微观层面的TCP/IP协议————基于W5500的嵌入式TCP通讯开发&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="TCP/IP" scheme="http://shatang.github.io/tags/TCP-IP/"/>
    
      <category term="TCP" scheme="http://shatang.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://shatang.github.io/tags/UDP/"/>
    
      <category term="Socket" scheme="http://shatang.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Modbus协议_具体实现</title>
    <link href="http://shatang.github.io/2020/05/30/Modbus%E5%8D%8F%E8%AE%AE-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://shatang.github.io/2020/05/30/Modbus协议-具体实现/</id>
    <published>2020-05-30T02:52:04.000Z</published>
    <updated>2020-05-30T02:53:42.569Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式</p><a id="more"></a><h1 id="一、搭建环境-amp-简介"><a href="#一、搭建环境-amp-简介" class="headerlink" title="一、搭建环境&amp;简介"></a>一、搭建环境&amp;简介</h1><ol><li>采用的是stm32f103RBT6为例</li><li>从机实现采用 FreeModbus库</li><li>Modbus TCP通讯是基于 W5500 实现的</li></ol><p>&emsp;&emsp;这里主要讲解的是Modbus从机(Server)的实现。因为实际产品常用于采集数据或做动作处理，一般是作为从设备，接入Plc(Modbus主机)。</p><h1 id="二、Modbus主机-Master"><a href="#二、Modbus主机-Master" class="headerlink" title="二、Modbus主机(Master)"></a>二、Modbus主机(Master)</h1><p>&emsp;&emsp;Modbus主机一般很少用到。主要用途，一般用于：实际产品分为前后台，后台做所有的数据处理，作为Modbus从机；而前台主要用于做界面显示，即作为Modbus主机，界面数据修改通过串口Modbus通讯。</p><p>&emsp;&emsp;由于是前后台的内置通讯，常用的Modbus主机 当然是采用<strong>方便、可靠</strong>的 Modbus RTU通讯。</p><p>&emsp;&emsp;当然由于前后台通讯占用一个硬件串口Modbus通讯。因此，常见的Modbus从机，往往是具有多串口Modbus通讯，共享一套地址处理数据(当然，可能前后台内置通讯在实际产品说明书中被隐藏)。</p><hr><p>&emsp;&emsp;Modbus主机，在网上是没有开源，只有收费版本的。其实只要根据Modbus协议，很容易就能写一个Modbus主机。</p><p>唯一需要注意的点：每个数据帧发送之间的间隔为 3.5T；防止从机接收到的数据黏合。</p><p>&emsp;&emsp;但是由于Modbus主机一般要处理其他事宜，往往本身每个数据帧发送之间的间隔都 &gt; 3.5T。因此实际上，写得不标准也能用；当然严谨一点的话，写一个定时器，发送就开启定时器，定时器溢出置标志位才能再次发送也是可以的。</p><h1 id="三、Modbus从机-Slave"><a href="#三、Modbus从机-Slave" class="headerlink" title="三、Modbus从机(Slave)"></a>三、Modbus从机(Slave)</h1><p>&emsp;&emsp;这里的Modbus从机是基于 FreeModbus库 实现的。  </p><p>&emsp;&emsp;Freemodbus库的代码是写得很好的，如果C语言学得好，且对Modbus协议了解的话，建议直接看源码，多看多观察可以提高自己的代码水平。</p><h2 id="3-1-FreeModbus移植-RTU模式"><a href="#3-1-FreeModbus移植-RTU模式" class="headerlink" title="3.1 FreeModbus移植(RTU模式)"></a>3.1 FreeModbus移植(RTU模式)</h2><p>&emsp;&emsp;FreeModbus详细移植方法可以参照以下博主：</p><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=69081&extra=page%3D2" target="_blank" rel="noopener">FreeModbus在STM32上移植</a></p><p><a href="https://blog.csdn.net/qq_33611327/article/details/77883787" target="_blank" rel="noopener">STM32上移植FreeModbus详细过程</a></p><h2 id="3-2-如何计算RTU模式的-3-5T-超时时间？"><a href="#3-2-如何计算RTU模式的-3-5T-超时时间？" class="headerlink" title="3.2 如何计算RTU模式的 3.5T 超时时间？"></a>3.2 如何计算RTU模式的 3.5T 超时时间？</h2><p><strong>波特率</strong>：每秒钟通过信道传输的信息量称为位传输速率，也就是每秒钟传送的二进制位数,简称比特率。</p><p><strong>比特率</strong>：表示有效数据的传输速率，用b/s 、bit/s、比特/秒，读作：比特每秒。</p><hr><p>通常的串口桢格式为10位：<code>开始位1bit + 数据位8bit + 停止位1bit</code></p><p>&emsp;&emsp;如9600b/s：指总线上每秒可以传输9600个bit；也就是说：在9600的波特率下，每秒可以传输出的桢数为：9600 / (1 + 8 + 1) = 960桢/秒，即960字节/秒(实际数据速率)；</p><p>反推：一帧或一字节数据需要的时间是多少呢？</p><p>1s / 960 = 1.4ms</p><p>而ModBus协议中超时时间定为：3.5个帧长度为超时时间；</p><ul><li>超时时间 <ul><li>= 3.5 * 1 / BaudRate / 10 秒</li><li>= 3.5 * 10 / BaudRate 秒</li><li>= 3.5 * 10  * 2 / BaudRate  * 2 秒</li><li>=  70 / BaudRate  * 2 秒</li></ul></li></ul><hr><p>FreeModBus是这样实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If baudrate &gt; 19200 then we should use the fixed timer values</span></span><br><span class="line"><span class="comment">* t35 = 1750us. Otherwise t35 must be 3.5 times the character time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>( ulBaudRate &gt; <span class="number">19200</span> )</span><br><span class="line">&#123;</span><br><span class="line">    usTimerT35_50us = <span class="number">35</span>;       <span class="comment">/* 1800us. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The timer reload value for a character is given by:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 )</span></span><br><span class="line"><span class="comment">    *             = 11 * Ticks_per_1s / Baudrate</span></span><br><span class="line"><span class="comment">    *             = 220000 / Baudrate</span></span><br><span class="line"><span class="comment">    * The reload for t3.5 is 1.5 times this value and similary</span></span><br><span class="line"><span class="comment">    * for t3.5.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    usTimerT35_50us = ( <span class="number">7U</span>L * <span class="number">220000U</span>L ) / ( <span class="number">2U</span>L * ulBaudRate );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>波特率大于19200使用定值：1800us</li></ul><p>&emsp;&emsp;由于将<code>usTimerT35_50us = 35;</code>直接带入，在定时器驱动初始化实际代入的计算值为 (35 = 36-1)，因此实际的定时时间为：36 * 50(基值) = 1800 us。</p><ul><li>波特率小于19200使用定值：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usTimerT35_50us = ( <span class="number">7U</span>L * <span class="number">220000U</span>L ) / ( <span class="number">2U</span>L * ulBaudRate );</span><br></pre></td></tr></table></figure></li></ul><hr><p>解析：由于Modbus的RTU模式是串口帧格式为11位，故</p><ul><li>超时时间 (50us为单位)<ul><li>= 3.5 * 1 / BaudRate / 11 秒</li><li>= 3.5 * 11 / BaudRate 秒</li><li>= 3.5 * 11  * 2 / BaudRate  * 2 秒</li><li>= 7 * 11 / BaudRate  * 2 秒</li><li>= 7 * 11 * 1000000 / 50 / BaudRate  * 2 (50us为单位)</li><li>= 7 * 220000 / BaudRate * 2 (50us为单位)</li></ul></li></ul><p>&emsp;&emsp;这usTimerT35_50us一个单位为50uS，将这个超时时间计算结果用于定时器驱动初始化。每中断一次为50us * usTimerT35_50us 微秒；<strong>且每次更改Modbus通信的波特率，Modbus的定时器驱动初始化都要更新一次，更新定时器计数溢出值</strong>。</p><h1 id="四、-FreeModbus库源码"><a href="#四、-FreeModbus库源码" class="headerlink" title="四、 FreeModbus库源码"></a>四、 FreeModbus库源码</h1><p>&emsp;&emsp;3.1所提到的移植，是把RTU模式通讯的底层给移植好，报文中的具体<strong>数据单元处理功能函数</strong>还是得自己继续写。</p><p>&emsp;&emsp;但暂先不讲具体的<strong>数据单元处理功能函数</strong>写法，先讲解整个FreeModbus源码的实现过程，使其后面更清晰如何写数据单元处理功能函数，甚至可以自己移植、扩展改动(ASCII、TCP模式)。</p><h2 id="4-1-实现的核心原理"><a href="#4-1-实现的核心原理" class="headerlink" title="4.1 实现的核心原理"></a>4.1 实现的核心原理</h2><p>&emsp;&emsp;每一帧的数据区分是采用3.5T的方法。那么MCU具体的实现方法思路如下：</p><p>&emsp;&emsp;使能串口接收中断，一但接收到数据(触发串口接收中断)，就开启定时器，每一次重新触发串口接收中断，就会重启定时器&amp;重新计数；直到不触发串口接收中断，导致定时器溢出，此时视为接收一帧完整数据，开始解析数据。再根据自己喜好响应主机的信息。</p><p>&emsp;&emsp;以上就是整体思路，你甚至可以根据这个思路自己实现Modbus通讯的从机部分。接下来就是FreeModbus同样思路实现方式的讲解</p><h2 id="4-2-FreeModbus库通讯实现讲解-RTU模式为例"><a href="#4-2-FreeModbus库通讯实现讲解-RTU模式为例" class="headerlink" title="4.2 FreeModbus库通讯实现讲解(RTU模式为例)"></a>4.2 FreeModbus库通讯实现讲解(RTU模式为例)</h2><ol><li>Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态</li><li>串口接收中断 在初始化状态下，打开定时器</li><li>等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将<code>eMBPoll</code>的 事件状态机 置为 初始化。</li><li><strong>以上就是初始化完成，接下来就是数据收发的流程了</strong></li><li>串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。</li><li>每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。</li><li>当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态</li><li>由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。</li><li>eMBPoll的 事件状态机 为<code>Frame received</code>接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功</li><li>核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 <code>MB_EIO</code>的错误。</li><li>经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为<code>Execute function</code> 执行数据函数(事件)。开始对数据进行处理。</li><li>这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。</li><li>如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 <code>功能码|0x80 + 错误代码</code>。</li><li>举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。</li><li>在处理完后会返回一个enum状态值。如果状态 不为<code>MB_ENOERR</code>，即内部使用的错误代码，根据内部使用的<code>enum</code>错误代码，<code>switch</code>生成 对外的错误代码</li><li>返回的CRC会在发送前先把CRC校验完成。</li><li>发送前，检查能不能数据接收，能接收则报硬件错误<code>MB_EIO</code>，因为协议规定只能单向收发</li><li>发送一个字节数据，然后开启发送中断，一直发送，直到完成</li><li>发送完成后，将 eMBPoll的 事件状态机 置为 发送完成</li><li>事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲</li></ol><p>&emsp;&emsp;以上就是FreeModbus库实现<code>Modbus RTU</code>通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。这个库源码写的很好，如果是嵌入式新手，这份源码还是很推荐看的。</p><p>&emsp;&emsp;如果顺着程序缕是能看得懂的，这里再留一份函数==笔记==，方便小白初次看时疑惑，可查阅一下。</p><h2 id="4-3-数据单元处理功能函数"><a href="#4-3-数据单元处理功能函数" class="headerlink" title="4.3 数据单元处理功能函数"></a>4.3 数据单元处理功能函数</h2><p>这里的写法思路分为3个部分：</p><ul><li>第一部分函数用于对应FreeModbus库编写的处理函数<ul><li>例如，库里面处理到最后，总是地址+1,；可以在这里去掉</li><li>这里用来区分 读、写 </li></ul></li><li>第二部分函数用于自己应用层的地址约束<ul><li>并可以对不同地址块进行不同处理</li></ul></li><li>第三部分函数用于具体地址的详细操作</li></ul><h2 id="4-3-1-数据单元初步处理"><a href="#4-3-1-数据单元初步处理" class="headerlink" title="4.3.1 数据单元初步处理"></a>4.3.1 数据单元初步处理</h2><p>&emsp;&emsp;编写具体如下四个函数对应FreeModbus库的处理：</p><ul><li>eMBRegCoilsCB</li><li>eMBRegHoldingCB</li><li>eMBRegDiscreteCB</li><li>eMBRegInputCB<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  eMBRegCoilsCB</span></span><br><span class="line"><span class="comment">* 功  能 :  线圈回复函数</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  *pucRegBuffer : 要添加到协议中的数据</span></span><br><span class="line"><span class="comment">*           usAddress     : 线圈地址(PLC地址)</span></span><br><span class="line"><span class="comment">*           usNRegs       : 要访问线圈的个数</span></span><br><span class="line"><span class="comment">*           eMode         : 访问类型（MB_REG_READ为读线圈状态，MB_REG_WRITE为写线圈）</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus       : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">eMBRegCoilsCB</span><span class="params">( UCHAR * pucRegBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                            USHORT usAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">                            USHORT usNCoils, </span></span></span><br><span class="line"><span class="function"><span class="params">                            eMBRegisterMode eMode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eMBErrorCode    eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    usAddress--;<span class="comment">// 由PLC地址转为协议地址  </span></span><br><span class="line">    <span class="keyword">switch</span> ( eMode )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MB_REG_READ:</span><br><span class="line">            eStatus = AppFMD_RdCoils(usNCoils,usAddress,pucRegBuffer);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MB_REG_WRITE:</span><br><span class="line">            eStatus = AppFMD_WrCoils(usNCoils,usAddress,pucRegBuffer);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eStatus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  eMBRegHoldingCB</span></span><br><span class="line"><span class="comment">* 功  能 :  保持寄存器回复函数</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  *pucRegBuffer : 要添加到协议中的数据</span></span><br><span class="line"><span class="comment">*           usAddress     : 寄存器地址</span></span><br><span class="line"><span class="comment">*           usNRegs       : 访问寄存器的个数</span></span><br><span class="line"><span class="comment">*           eMode         : 访问类型（MB_REG_READ为读保持寄存器，MB_REG_WRITE为写保持寄存器）</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus       : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">eMBRegHoldingCB</span><span class="params">(   UCHAR * pucRegBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                USHORT usAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                                USHORT usNRegs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                eMBRegisterMode eMode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eMBErrorCode    eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    usAddress--;<span class="comment">// 由PLC地址转为协议地址</span></span><br><span class="line">    <span class="keyword">if</span> (eMode == MB_REG_READ)</span><br><span class="line">        eStatus = AppFMD_RdRegs(usNRegs,usAddress,pucRegBuffer);</span><br><span class="line">    <span class="keyword">if</span>(eMode == MB_REG_WRITE)</span><br><span class="line">        eStatus = AppFMD_WrRegs(usNRegs,usAddress,pucRegBuffer);</span><br><span class="line">    <span class="keyword">return</span> eStatus; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-2-线圈和寄存器处理"><a href="#4-3-2-线圈和寄存器处理" class="headerlink" title="4.3.2 线圈和寄存器处理"></a>4.3.2 线圈和寄存器处理</h3><p>&emsp;&emsp;根据 <strong>4.3.1</strong>，只编写可读写线圈和寄存器的函数，具体对应函数如下：</p><ul><li>eMBErrorCode AppFMD_RdCoils(uint32_t si_num, uint32_t uiAddr, uint8_t *puc_txpointer)</li><li>eMBErrorCode AppFMD_WrCoils(uint32_t si_num, uint32_t uiAddr,uint8_t *puc_txpointer)</li><li>最好在这块函数进行总的地址划分<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  </span></span><br><span class="line"><span class="comment">* 功  能 :  </span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  si_num          : 待读的 线圈|寄存器 个数</span></span><br><span class="line"><span class="comment">*           uiAddr          : 地址索引  从0起始</span></span><br><span class="line"><span class="comment">*           *puc_txpointer  : 输出缓存</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus         : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">AppFMD_RdRegs</span><span class="params">(<span class="keyword">uint32_t</span> lNum, <span class="keyword">uint32_t</span> ulAddr,<span class="keyword">uint8_t</span> *puc_txpointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    eMBErrorCode eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部参数</span></span><br><span class="line">    <span class="keyword">if</span>(ulAddr&lt;<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(lNum)</span><br><span class="line">        &#123;</span><br><span class="line">            puc_txpointer = BuiltReadWord(ulAddr, puc_txpointer);</span><br><span class="line">            lNum -= <span class="number">1</span>; </span><br><span class="line">            ulAddr += <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户自定义参数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ulAddr&gt;=<span class="number">1000</span> &amp;&amp; ulAddr&lt;<span class="number">1400</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(lNum)</span><br><span class="line">        &#123;</span><br><span class="line">            puc_txpointer = BuiltReadWord_Double(ulAddr, puc_txpointer);</span><br><span class="line">            lNum -= <span class="number">2</span>; </span><br><span class="line">            ulAddr += <span class="number">2</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        eStatus = MB_ENOREG;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> eStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-3-用户自定义的-线圈-amp-寄存器-处理"><a href="#4-3-3-用户自定义的-线圈-amp-寄存器-处理" class="headerlink" title="4.3.3 用户自定义的 线圈 &amp; 寄存器 处理"></a>4.3.3 用户自定义的 线圈 &amp; 寄存器 处理</h3><p>&emsp;&emsp;根据 <strong>4.3.2</strong>，在对应的函数写具体到某个地址位的操作就行了。</p><h1 id="五、通讯报文讲解"><a href="#五、通讯报文讲解" class="headerlink" title="五、通讯报文讲解"></a>五、通讯报文讲解</h1><p>&emsp;&emsp;这里是方便没接触过Modbus的人，或者是长时间没用急用，直接来查阅Modbus报文的；好清楚是哪里出的问题(主机 or 从机？)。</p><h2 id="5-1-报文格式总结"><a href="#5-1-报文格式总结" class="headerlink" title="5.1 报文格式总结"></a>5.1 报文格式总结</h2><p>&emsp;&emsp;首先，如果从机是返回很短的(报错)报文，直接看功能码位，例如 0x83 ；去掉 &amp; 0x80 的操作，那就是 功能码 0x03 出现错误。</p><ul><li>主机的读取数据命令(长度)是固定的：ID + 功能码 + 地址 + 数据长度 + CRC16</li><li>从机返回的数据格式不是固定的：<ul><li>读取长度为1：ID + 功能码 + 数据长度 + 数据1 + CRC16</li><li>读取长度为2：ID + 功能码 + 数据长度 + 数据1 + 数据2 + CRC16</li></ul></li></ul><hr><ul><li>主机的写入数据格式不是固定的</li><li>从机返回数据格式(长度)是固定的(与上面的相反)</li></ul><h2 id="5-2-报文举例"><a href="#5-2-报文举例" class="headerlink" title="5.2 报文举例"></a>5.2 报文举例</h2><p>功能码0x03，读可读写模拟量寄存器：</p><ul><li>(主机)发送命令格式：</li><li>[设备地址] [功能码03] [起始寄存器地址高8位] [低8位] [读取的寄存器数高8位] [低8位] [CRC校验低8位] [CRC校验高8位]</li><li>例：[11][03][00][6B][00][03][CRC低][CRC高]</li><li>意义如下：<ul><li>11：设备地址，例子中的地址是11；</li><li>03：读模拟量的命令号固定为03，这是Modbus协议规定的。</li><li>00、6B：起始地址高8位（00）、低8位（6B）：表示想读取的模拟量的起始地址，比如例子中的起始地址为107。这个006B表示一个完整的地址，注意这里的地址是高8位在前，低8位在后。</li><li>00、03：寄存器数高8位（00）、低8位（03）：表示从起始地址开始读多少个模拟量（返回的每一个模拟量是用两个字节表示的）。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节同时这里的地址也是高8位在前，低8位在后。</li><li>[CRC低][CRC高]：帧尾的CRC-16校验，尤其需要注意的一点是校验结果的低8位在前，高8位在后，这个顺序不同于起始地址以及读取深度的地址顺序。</li></ul></li></ul><hr><ul><li>(从机)设备响应：</li><li>[设备地址] [命令号03] [返回的字节个数][数据1][数据2]…[数据n][CRC校验的低8位] [CRC校验的高8位]</li><li>例：[11][03][06][02][2B][00][00][00][64][CRC低][CRC高]</li><li>意义如下：<ul><li>11：设备地址（从机地址）；</li><li>03：功能码；</li><li>06：返回的字节个数（不高扩两字节的校验码）：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。<br>数据1…n：其中[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。</li><li>[CRC低][CRC高]：CRC校验同上。</li></ul></li></ul><h1 id="六、基于W5500的Modbus-TCP"><a href="#六、基于W5500的Modbus-TCP" class="headerlink" title="六、基于W5500的Modbus TCP"></a>六、基于W5500的Modbus TCP</h1><p>&emsp;&emsp;如果是理解了上面源码的讲解，那么这里将会异常简单。由于W5500芯片，集成了硬件TCP/IP协议，数据接收完成与否的判断，也在W5500内完成；因此，FreeModbus库内的TCP函数大部分都不需要用到(例如，初始化函数)，只需要FreeModbus库的 TCP_Poll事件状态机(初始化要置位事件状态)。</p><p>&emsp;&emsp;先根据W5500的数据手册、或者例程，先编写好W5500的通讯驱动；程序中，读取W5500中断，如果有产生接收完成中断，就把TCP_Poll事件状态机置为接收完成，然后接下来就是TCP_Poll自己处理了，沿用同一套的数据单元处理功能函数。这样就完成了！</p><h1 id="七、FreeModbus库-拓展"><a href="#七、FreeModbus库-拓展" class="headerlink" title="七、FreeModbus库_拓展"></a>七、FreeModbus库_拓展</h1><p>&emsp;&emsp;Freemodbus库虽然写得很好，但是它的思路框架是以1个通讯接口实现的。如果是在 <code>Modbus主机</code> 一节提到的：有多串口Modbus通讯，共享一套地址处理数据。当你多串口RTU通讯，且波特率不相同，定时器的配置也就要变动一下。甚至还有，一个实际产品，它不仅有Modbus 多串口通讯，它还可能要有Modbus TCP通讯，而且也还是共享一套地址处理数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Modbus" scheme="http://shatang.github.io/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>Modbus协议_概念讲解</title>
    <link href="http://shatang.github.io/2020/05/30/Modbus%E5%8D%8F%E8%AE%AE-%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3/"/>
    <id>http://shatang.github.io/2020/05/30/Modbus协议-概念讲解/</id>
    <published>2020-05-30T02:50:13.000Z</published>
    <updated>2020-05-30T02:50:53.186Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯</p><a id="more"></a><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>&emsp;&emsp;Modbus协议 是一个请求/应答协议，发起请求的为Master（client），响应请求的为Slave（server）;Modbus协议包括ASCII、RTU、TCP三种报文类型，并没有规定物理层。</p><p>&emsp;&emsp;标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。</p><hr><ul><li><strong>Master端发出读数据请求消息，Slave端接收到正确消息后，就发送对应数据到Master端以响应请求；</strong></li><li><strong>Master端发出写数据请求消息，Slave端接收到正确消息后，就修改Slave端的数据；</strong></li></ul><p>先发请求，再接收响应，从而实现 主机 对 从机 读/写操作。</p><h1 id="二、报文格式-通用部分"><a href="#二、报文格式-通用部分" class="headerlink" title="二、报文格式_通用部分"></a>二、报文格式_通用部分</h1><ul><li>(<strong>ADU</strong>)报文，指的是一串完整的指令数据；一个报文就是一帧数据，一个数据帧就一个报文</li><li>(<strong>MBAP</strong>)报文头，即报文的一部分，用于识别。当然也有些是部分数据在报文尾部，例如CRC数据校验。</li><li>(<strong>PDU</strong>)协议数据单元，这部分就是通信中的数据部分了。</li></ul><p>举例如下：</p><img src="/2020/05/30/Modbus协议-概念讲解/0.jpg" title="Modbus RTU报文模型"><p>&emsp;&emsp;由于报文类型的不同，报文之间也存在一些差异。先讲解通用的 功能码 &amp; 错误代码 部分。</p><h2 id="2-1-Modbus部分功能码"><a href="#2-1-Modbus部分功能码" class="headerlink" title="2.1 Modbus部分功能码"></a>2.1 Modbus部分功能码</h2><table><thead><tr><th>功能码（十六进制）</th><th>中文名称</th><th>位操作/字节操作</th><th>操作数量</th><th>错误功能码(&amp;0x80)</th></tr></thead><tbody><tr><td>01</td><td>读线圈状态</td><td>位操作</td><td>单个或多个</td><td>0x81</td></tr><tr><td>02</td><td>读离散状态</td><td>位操作</td><td>单个或多个</td><td>0x82</td></tr><tr><td>03</td><td>读保持寄存器</td><td>字节操作</td><td>单个或多个</td><td>0x83</td></tr><tr><td>04</td><td>读输入寄存器</td><td>字节操作</td><td>单个或多个</td><td>0x84</td></tr><tr><td>05</td><td>写单个线圈</td><td>位操作</td><td>单个</td><td>0x85</td></tr><tr><td>06</td><td>写单个保持寄存器</td><td>字节操作</td><td>单个</td><td>0x86</td></tr><tr><td>0F</td><td>写多个线圈</td><td>位操作</td><td>多个</td><td>0x8F</td></tr><tr><td>10</td><td>写多个保持寄存器</td><td>字节操作</td><td>多个</td><td>0x90</td></tr></tbody></table><p>&emsp;&emsp;Modbus协议规定，从机当执行对应功能码处理时发生错误，响应主机时需要将 <code>功能码 & 0x80</code> 将其返回。</p><h2 id="2-2-错误代码表"><a href="#2-2-错误代码表" class="headerlink" title="2.2 错误代码表"></a>2.2 错误代码表</h2><table><thead><tr><th>代码</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>01</td><td>非法功能</td><td>对于服务器（或从站）来说，询问中接收到的功能码是不可允许的操作，可能是因为功能码仅适用于新设备而被选单元中不可实现同时，还指出服务器（或从站）在错误状态中处理这种请求，例如：它是未配置的，且要求返回寄存器值。</td></tr><tr><td>02</td><td>非法数据地址</td><td>对于服务器（或从站）来说，询问中接收的数据地址是不可允许的地址，特别是参考号和传输长度的组合是无效的。对于带有100个寄存器的控制器来说，偏移量96和长度4的请求会成功，而偏移量96和长度5的请求将产生异常码02。</td></tr><tr><td>03</td><td>非法数据值</td><td>对于服务器（或从站）来说，询问中包括的值是不可允许的值。该值指示了组合请求剩余结构中的故障。例如：隐含长度是不正确的。modbus协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。</td></tr><tr><td>04</td><td>从站设备故障</td><td>当服务器（或从站）正在设法执行请求的操作时，产生不可重新获得的差错。</td></tr><tr><td>05</td><td>确认</td><td>与编程命令一起使用，服务器（或从站）已经接受请求，并且正在处理这个请求，但是需要长持续时间进行这些操作，返回这个响应防止在客户机（或主站）中发生超时错误，客户机（或主机）可以继续发送轮询程序完成报文来确认是否完成处理。</td></tr><tr><td>07</td><td>从属设备忙</td><td>与编程命令一起使用，服务器（或从站）正在处理长持续时间的程序命令，当服务器（或从站）空闲时，客户机（或主站）应该稍后重新传输报文。</td></tr><tr><td>08</td><td>存储奇偶性差错</td><td>与功能码20和21以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器（或从站）设备读取记录文件，但在存储器中发现一个奇偶校验错误。客户机（或主机）可重新发送请求，但可以在服务器（或从站）设备上要求服务。</td></tr><tr><td>0A</td><td>不可用网关路径</td><td>与网关一起使用，指示网关不能为处理请求分配输入端口值输出端口的内部通信路径，通常意味着网关是错误配置的或过载的。</td></tr><tr><td>0B</td><td>网关目标设备响应失败</td><td>与网关一起使用，指示没有从目标设备中获得响应，通常意味着设备未在网络中。</td></tr><tr><td>## 2.3 Modbus 寄存器地址分配</td><td></td><td></td></tr><tr><td>寄存器信息地址(PLC 地址)</td><td>适用功能码（十六进制）</td><td>寄存器种类</td></tr><tr><td>—-</td><td>—</td><td>—-</td></tr><tr><td>00001-09999</td><td>01 05 15</td><td>线圈状态</td></tr><tr><td>10001-19999</td><td>02</td><td>(开关)输入状态</td></tr><tr><td>30001-39999</td><td>04</td><td>输入寄存器</td></tr><tr><td>40001-49999</td><td>03 06 16</td><td>保持寄存器</td></tr><tr><td>## 2.4 小总结(心得)</td><td></td><td></td></tr><tr><td>&emsp;&emsp;一般情况下，只需要看一下返回的功能码就行了，错误代码可以不用看。Modbus通讯发生错误，往往出现的情况如下:</td><td></td><td></td></tr><tr><td>1. Modbus主机(PLC)读取有问题，例如读的地址写错，读的数据长度写错</td><td></td><td></td></tr><tr><td>2. Modbus从机压根就没写该 功能码 0r 地址 对应的处理，当主机对其操作自然报错。</td><td></td><td></td></tr><tr><td>3. 并不是符合Modbus协议规范的报文就一定通信正确，只能说是通讯成功，因为它返回给你一条报错指令。通讯无响应，说明是主机本身发的数据就有问题；通信有响应(可能返回错误报文)，说明该地址不可用，主机读歪了或者从机压根没写该功能处理。</td><td></td><td></td></tr></tbody></table><h1 id="三、各报文格式-详细解析"><a href="#三、各报文格式-详细解析" class="headerlink" title="三、各报文格式_详细解析"></a>三、各报文格式_详细解析</h1><p>&emsp;&emsp;每个报文都与其他报文格式有一定区分。<strong>在Modbus从机的角度看</strong>，讲解一下他们之间的类似之处。</p><ul><li>三者功能码是通用的</li><li>RTU 和 TCP的报文十分类似。TCP由于是可靠的协议，且通过IP连接，相比RTU就少了 设备ID &amp; CRC数据校验。<strong>数据单元部分</strong>是完全一样的。</li><li>RTU &amp; ASCII 都是通过串口通讯的，因此都是需要 定时器。但是定时器具体用法不相同。</li></ul><p><strong>Ps：</strong><br>ASCII模式，国内基本没用到。常用的是 RTU &amp; TCP 模式。</p><h2 id="3-1-RTU模式"><a href="#3-1-RTU模式" class="headerlink" title="3.1 RTU模式"></a>3.1 RTU模式</h2><p>&emsp;&emsp;Modbus RTU协议中没有明显的开始符和结束符，而是通过帧与帧之间的间隔时间来判断的。如果在指定的时间内，没有接收到新的字符数据，那么就认为新的帧接收完毕。接下来就是处理数据。Modbus通过时间来判断帧接收完成，自然需要 MCU 的定时器配合(3.5T)。<br>| 设备地址 | 功能代码 | 数据 | CRC校验 | 结束符(实际报文可没有这个！)<br>| — | —- | — | —- | —<br>| 1个字节 | 1个字节 | n个字节 | 2个字节 | T1-T2-T3-T4</p><ul><li><strong>地址码</strong>：每个从机都必须有唯一的地址码ID（从1到247，0是广播地址），并且只有符合地址码的从机才能响应回送。当从机回送信息时，相应的地址码表明该信息来自于何处。</li><li><strong>功能码</strong>：主机发送的功能码告诉从机执行什么任务。ModBus通讯规约定义功能号为1到127。表2-1列出部分常用功能码，以备查询。</li><li><strong>数据区</strong>：数据区包含需要从机执行什么动作或由从机采集的返送信息。应答包中，数据包括了数据字节长度+数据值，请求包中数据只包含数据值。</li><li><strong>校验码</strong>：主机或从机可用校验码进行判别接收信息是否出错。</li></ul><hr><ul><li>从Modbus主机角度上看<ul><li>使用RTU模式，<strong>消息发送至少要以3.5个字符时间的停顿间隔开始</strong>（如上图的T1-T2-T3-T4所示）。传输的第一个域是设备地址。可以使用的传输字符是十六进制的0…9,A…F。网络设备不断侦测网络总线，包括停顿间隔时间内。当第一个域（地址域）接收到，每个设备都进行解码以判断是否发往自己的。在最后一个传输字符之后，一个至少3.5个字符时间的停顿标定了消息的结束。一个新的消息可在此停顿后开始。</li><li>一旦连续发送间隔 小于3.5T，就会对从机数据接收造成 <strong>数据黏合</strong>。</li></ul></li><li>从Modbus从机角度上看<ul><li><strong>整个消息帧必须作为一连续的流传输，如果在帧完成之前有超过1.5个字符时间的停顿时间则为非法帧；</strong>如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续，这将导致一个错误，因为在最后的CRC域的值不可能是正确的。即<strong>帧之间的间隔必须大于3.5T，帧内字符的间隔必须小于1.5T</strong>。实际应用中1.5T一般不处理，只采用3.5T进行处理（FreeModBus开源代码就是这样)。</li><li>FreeModbus库，采用的是3.5T作为判断。只要是超过3.5T，就视为两个数据帧处理。当然，如果主机发送数据异常，让 某条报文中间字符发送相隔时间超过3.5T，那么就会造成 1条正确报文被分割成2条报文，造成 数据裂开。</li><li>数据裂开一般不会出现。采用FreeModbus库时，正常情况下，高波特率会对3.5T的值进行限制。如果解开该限制，导致3.5T实际值太小(高波特率转换计算出来)，这时候主机的字符发送间隔慢一点，从机将无法识别到正确的报文(数据被分裂)。</li></ul></li></ul><h2 id="3-2-ASCII模式"><a href="#3-2-ASCII模式" class="headerlink" title="3.2 ASCII模式"></a>3.2 ASCII模式</h2><p>&emsp;&emsp;除了数据域为ASCII码，其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码下个域（地址域）来判断是否发给自己的。消息中字符间发送的时间间隔(MCU 的定时器)最长不能超过1秒，否则接收的设备将认为传输错误。</p><table><thead><tr><th>起始位</th><th>设备地址</th><th>功能代码</th><th>数据</th><th>LRC校验</th><th>结束符</th></tr></thead><tbody><tr><td>：</td><td>2个字符</td><td>2个字符</td><td>n个字符</td><td>2个字符</td><td>2个字符</td></tr></tbody></table><p>&emsp;&emsp;<strong>使用ASCII模式，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）</strong></p><h2 id="3-3-TCP-IP模式"><a href="#3-3-TCP-IP模式" class="headerlink" title="3.3 TCP/IP模式"></a>3.3 TCP/IP模式</h2><p>&emsp;&emsp;与MODBUS RTU相比，少了校验域和地址码，其中地址码被放到MBAP报文头里面了(即 00 00)，没有校验域是因为TCP本身就有校验所以省略了。</p><img src="/2020/05/30/Modbus协议-概念讲解/1.png" title="Modbus TCP报文"><p>报文头MBAP，长度为7字节，组成如下：</p><ul><li>事务处理标识    ：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文(主机要注意的点，从机不对该数据进行识别处理)。</li><li>协议标识符    ：00 00表示ModbusTCP协议。</li><li>长度    ：表示接下来的数据长度，单位为字节。</li><li>单元标识符    ：可以理解为设备地址。</li></ul><table><thead><tr><th>事务处理标识</th><th>协议标识</th><th>长度</th><th>单元标识符</th><th>功能代码</th><th>数据</th></tr></thead><tbody><tr><td>2字节</td><td>2字节</td><td>2字节</td><td>1字节</td><td>1字节</td><td>n字节</td></tr></tbody></table><h1 id="四、调试工具"><a href="#四、调试工具" class="headerlink" title="四、调试工具"></a>四、调试工具</h1><ul><li>如果你做的是Modbus Master，可以使用modbus slave工具模拟从设备来调试，该工具下载地址：<a href="http://www.cr173.com/soft/21410.html" target="_blank" rel="noopener">Modbus Slave</a></li><li>如果你做的是Modbus Slave，可以使用modbus poll工具模拟主设备来调试，该工具下载地址：<a href="http://www.cr173.com/soft/21405.html" target="_blank" rel="noopener">Modbus Poll</a></li></ul><p>以上两个工具的使用方法，可以参考此博客：<a href="https://blog.csdn.net/byxdaz/article/details/77979114" target="_blank" rel="noopener">Modbus测试工具ModbusPoll与Modbus Slave使用方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Modbus" scheme="http://shatang.github.io/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>这段时间的总结</title>
    <link href="http://shatang.github.io/2020/05/30/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://shatang.github.io/2020/05/30/这段时间的总结/</id>
    <published>2020-05-30T02:34:34.000Z</published>
    <updated>2020-05-30T02:40:33.066Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;好久没更新博客了= =？</p><p>&emsp;&emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。</p><p>&emsp;&emsp;然后偶然，又和高中老同学聊了聊；这回会持续更新，而且要加很多新内容！！！</p><p>&emsp;&emsp;继续加油，奥力给！</p><img src="/2020/05/30/这段时间的总结/1.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;好久没更新博客了= =？&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="生活" scheme="http://shatang.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>野指针</title>
    <link href="http://shatang.github.io/2020/03/15/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    <id>http://shatang.github.io/2020/03/15/野指针/</id>
    <published>2020-03-15T07:20:24.000Z</published>
    <updated>2020-03-15T08:11:21.146Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、野指针由来"><a href="#一、野指针由来" class="headerlink" title="一、野指针由来"></a>一、野指针由来</h1><h2 id="1-1-野指针概念-简述"><a href="#1-1-野指针概念-简述" class="headerlink" title="1.1 野指针概念(简述)"></a>1.1 野指针概念(简述)</h2><p>概述：<strong>“野指针”不是NULL指针，是指向“垃圾”内存的指针。</strong>(内存能不能用另外一回事)</p><ol><li>(局部)指针变量没有初始化</li><li>使用已经释放后的指针</li><li>指针所指向的变量在指针之前被销毁</li></ol><h2 id="1-2-野指针概念-专业描述"><a href="#1-2-野指针概念-专业描述" class="headerlink" title="1.2 野指针概念(专业描述)"></a>1.2 野指针概念(专业描述)</h2><ul><li><p><strong>指针未初始化</strong><br>&emsp;&emsp;指针变量在定义时不会自动初始化成空指针，而是随机的一个值，可能指向任意空间，这就使得该指针成为野指针。因此指针在初始化时要么指向一个合理的地址，要么初始化为<code>NULL</code>。<strong>即使不初始化，调用指针前，一定要赋值！</strong></p></li><li><p><strong>指针指向的变量被<code>free</code>或<code>delete</code>后没有置为<code>NULL</code></strong><br>&emsp;&emsp;在调用free或delete释放空间后，指针指向的内容被销毁，空间被释放，但是指针的值并未改变，仍然指向这块内存，这就使得该指针成为野指针。因此在调用<code>free</code>或<code>delete</code>之后，应将该指针置为<code>NULL</code>。</p></li><li><p><strong>指针操作超过所指向变量的生存期</strong><br>&emsp;&emsp;当指针指向的变量的声明周期已经结束时，如果指针仍然指向这块空间，就会使得该指针成为野指针。这种错误很难防范，只有养成良好的编程习惯，才能避免这类情况发生。</p></li></ul><h2 id="1-3-野指针的要点-简单描述"><a href="#1-3-野指针的要点-简单描述" class="headerlink" title="1.3 野指针的要点(简单描述)"></a>1.3 野指针的要点(简单描述)</h2><ol><li>野指针通常是因为指针变量中保存的值不是一个合法的内存地址而造成的</li><li>野指针不是NULL，是一个指向不可用内存的指针</li><li>C语言中没有方法可以判断是否为野指针(可替换成NULL指针，NULL指针不容易弄错，可以通过if来判断是否为NULL指针)</li></ol><h2 id="1-4-野指针的要点-深度描述"><a href="#1-4-野指针的要点-深度描述" class="headerlink" title="1.4 野指针的要点(深度描述)"></a>1.4 野指针的要点(深度描述)</h2><blockquote><p><strong>野指针只能避免而无法判断</strong></p></blockquote><p>&emsp;&emsp;无法判断一个指针是否为野指针，因为野指针本身有值，指向某个内存空间，只是这个值是随机的或错误的。</p><p><strong><font color="red">Ps：</font>空指针并非野指针</strong>，它具有特殊性和确定性，可以进行判断；因此要避免在程序中出现野指针，可以做完操作及时将指针指向<code>NULL</code>。</p><blockquote><p><strong>野指针并非立马让系统出事</strong></p></blockquote><p>&emsp;&emsp;指针也是数据，首先如果是局部的，不置空也没关系反正用不到了；如果是全局的，得用的时候释放了可能也会立马再次新赋值，如果不是那肯定需要重置为null，这也是方便你后面的判断是否需要赋值，<strong>如果你再次用不到，那么(不重置)就完全不影响程序的健壮性</strong>。但是，如果 <strong>再调该(野)指针就会可能出现问题！</strong> 有的可能比较复杂不一定开始就初始化，那你在某个地方用的时候会判断是否为空，然后给它赋值。就像很多做逻辑判断的bool，初始也会有值，如果没值，那你就看系统给的初始值，区别就是指针如果没初始化，然后对指针进行操作(调用)，可能会导致崩溃。也就是说，野指针并不是直接让系统出事，而是自己无意识产生野指针但还调用的操作才是让系统出事的真正原因！</p><blockquote><p><strong>野指针的错误是严重的</strong></p></blockquote><ol><li>指向不可访问的地址<br>&emsp;&emsp;危害：触发段错误。</li></ol><hr><ol start="2"><li>指向一个可用的，但是没有明确意义的空间<br>&emsp;&emsp;危害：程序可以正确运行，但通常这种情况下，我们就会认为我们的程序是正确的没有问题的，然而事实上就是有问题存在，所以这样就掩盖了我们程序上的错误。</li></ol><hr><ol start="3"><li>指向一个可用的，而且正在被使用的空间<br>&emsp;&emsp;危害：如果我们对这样一个指针进行解引用，对其所指向的空间内容进行了修改，但是实际上这块空间正在被使用，那么这个时候变量的内容突然被改变，当然就会对程序的运行产生影响，因为我们所使用的变量已经不是我们所想要使用的那个值了。通常这样的程序都会崩溃，或者数据被损坏。</li></ol><h1 id="二、未初始化指针的神奇操作"><a href="#二、未初始化指针的神奇操作" class="headerlink" title="二、未初始化指针的神奇操作"></a>二、未初始化指针的神奇操作</h1><p>&emsp;&emsp;指针未初始化，<strong>系统一般会自动分配内存给未初始化的指针，但也有时候指向<code>NULL</code>。</strong>由于太过玄学，建议直接初始化置<null>或一个有用的内存。</null></p><h2 id="2-1-非字符串指针未初始化"><a href="#2-1-非字符串指针未初始化" class="headerlink" title="2.1 非字符串指针未初始化"></a>2.1 非字符串指针未初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">20</span>,*p;    <span class="comment">//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    p=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    *p=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x7ffe4b25dc04</span>：<span class="number">20</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0xfaa010</span>：<span class="number">0</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0xfaa010</span>：<span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="2-2-字符串指针未初始化"><a href="#2-2-字符串指针未初始化" class="headerlink" title="2.2 字符串指针未初始化"></a>2.2 字符串指针未初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a=<span class="string">"ShaTang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p;    <span class="comment">//这里定义了一个字符串指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p\n"</span>, a, p);</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line">    p=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShaTang-&gt;(nil)</span><br><span class="line">ShaTang-&gt;(nil)</span><br><span class="line">ShaTang-&gt;<span class="number">0x4006d4</span>：ShaTang</span><br><span class="line">ShaTang-&gt;<span class="number">0x134a010</span>：</span><br><span class="line">ShaTang-&gt;<span class="number">0x4006f1</span>：Zhu</span><br></pre></td></tr></table></figure><p><strong><font color="red">Ps：</font></strong>观察2.1和2.2，就会发现字符(数组)类型，引用数据和查看地址都是用指针。<br>&emsp;&emsp;编译器此时帮我们把 未初始化指针 指向 <code>NULL</code>。我们对野指针的定义：<strong>指针指向垃圾(未知)的内存</strong>；在这里，我们就不能称它为野指针。</p><h2 id="2-3-例1变形的玄学"><a href="#2-3-例1变形的玄学" class="headerlink" title="2.3 例1变形的玄学"></a>2.3 例1变形的玄学</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>  *d1,*p;<span class="comment">//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, d1);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a,d1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>-&gt;<span class="number">0x7ffde8b16b80</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x4004f0</span></span><br><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x4004f0</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;<span class="number">0x7fff890b4780</span></span><br><span class="line">-&gt;(nil)</span><br><span class="line">-&gt;(nil)</span><br><span class="line">-&gt;(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器此时分配内存给 未初始化指针，还是玄学分配,有时候置<code>NULL</code>(虚_野指针)，有时候又分配一块内存(真_野指针)。因此需要注意 <strong>要指针的初始化，或者调用时一定要(检查)赋值</strong>，带来不可估量的Bug。<br>&emsp;&emsp;编译器1和编译器2对 例2.1 编译的结果都是一样的，但是对 例2.3 的编译结果却各不相同。但是反过来，只是简单变动，编译器就能玄学分配，这是很恐怖的事情。</p><h1 id="三、野指针概念案例"><a href="#三、野指针概念案例" class="headerlink" title="三、野指针概念案例"></a>三、野指针概念案例</h1><p>&emsp;&emsp;按照野指针的概念，举如下例子</p><h2 id="例1：指针变量没有初始化"><a href="#例1：指针变量没有初始化" class="headerlink" title="例1：指针变量没有初始化"></a>例1：指针变量没有初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                           <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"><span class="comment">//    strcpy(s1 , s2);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0x7fffea4889f0</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里不采用<code>strcpy</code>举例说明 指针变量没有初始化 的问题，后面单独一节再讲解原因。<br>&emsp;&emsp;这里很明显，在编译器2上，<code>printf</code>打印 未初始化的指针，出现段错误(实际指针 指向<code>NULL</code>)。而编译器1，则是通过了，并得知编译器1给 未初始化的指针 赋了一块随机内存。你的代码在不同的编译器上，有的报错，有的通过，这也是野指针带来的危害。</p><h2 id="例2：使用已经释放后的指针-释放后没改指向NULL"><a href="#例2：使用已经释放后的指针-释放后没改指向NULL" class="headerlink" title="例2：使用已经释放后的指针(释放后没改指向NULL)"></a>例2：使用已经释放后的指针(释放后没改指向NULL)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s);</span><br><span class="line">    <span class="built_in">strcpy</span>(s, <span class="string">"Delphi Tang"</span>);</span><br><span class="line">    func(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);      <span class="comment">//OOPS!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1f0e010</span></span><br><span class="line">Delphi Tang</span><br><span class="line"></span><br><span class="line"><span class="number">0x1f0e010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序是可以正常执行的。但是在执行结果第三行：打印野指针指向的内存为空白。首先我们先重新明确上面的概念：<strong>“野指针”不是NULL指针，是指向“垃圾”内存的指针。</strong>内存的申请释放和指针没有太大关系，内存释放后，<code>printf</code>能正常打印出指针指向的地址，但是地址所在的内存内容就有问题了(为下次调用埋雷)。</p><h2 id="例3：指针所指向的变量在指针之前被销毁"><a href="#例3：指针所指向的变量在指针之前被销毁" class="headerlink" title="例3：指针所指向的变量在指针之前被销毁"></a>例3：指针所指向的变量在指针之前被销毁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"Delphi Tang"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);  <span class="comment">//OOPS!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我测试用的多个编译器，结果都不相同；局部变量在函数执行完，内存是已经释放的，还调用指向该内存的指针，即野指针调用；造成的结果在每个编译器都不太相同。</p><h1 id="四、strcpy引发的段错误"><a href="#四、strcpy引发的段错误" class="headerlink" title="四、strcpy引发的段错误"></a>四、<code>strcpy</code>引发的段错误</h1><p>&emsp;&emsp;很多人讲解 未初始化的指针 导致的 野指针的时候，很多实例代码都是用到<code>strcpy</code>来讲解 指针未初始化 的问题。这是很不严谨的，从上面的案例分析，稍微改下代码，系统就能分配一块内存 或者 置<code>NULL</code>。</p><h2 id="4-1-错误的例子1"><a href="#4-1-错误的例子1" class="headerlink" title="4.1 错误的例子1"></a>4.1 错误的例子1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                             <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Shatang"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shatang</span><br><span class="line"><span class="number">0x7ffc79832540</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>在编译器2环境下，注释<code>strcpy(s1 , s2);</code>和<code>printf("%s\n", s1);</code>，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就说，用<code>strcpy</code>来举例 未初始化指针 的问题是有问题的。当编译器给 未初始化指针 置<code>NULL</code>时，这时候已经不算是野指针了，反而会出现段错误；当随机分配内存，编译却通过了，说明这个问题跟野指针无关，这是由<code>strcpy</code>引发的段错误。</p><h2 id="4-2-strcpy语法"><a href="#4-2-strcpy语法" class="headerlink" title="4.2 strcpy语法"></a>4.2 <code>strcpy</code>语法</h2><p><code>strcpy</code>的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(char* dest, const char *src);</span><br></pre></td></tr></table></figure><p>被覆盖的 <code>dest</code>首先是个变量，变量就必须有内存存放；而一个指向<code>NULL</code>的指针没有指向任何内存。没有内存，怎么存储覆盖过来的值？</p><p>&emsp;&emsp;或者来个更直接的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1=<span class="literal">NULL</span>;                        <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Shatang"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所有的</strong>编译器程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> Segmentation fault</span><br></pre></td></tr></table></figure><h2 id="4-3-错误的例子2"><a href="#4-3-错误的例子2" class="headerlink" title="4.3 错误的例子2"></a>4.3 错误的例子2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1=<span class="string">"Shatang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2); <span class="comment">// OOPS!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：这里我们将字符串指针初始化，指向一块明确内存(不是野指针了)；但程序执行还会报 理所应当的 <code>Segmentation fault</code>的错误。<code>strcpy</code>函数的<code>dest</code>是一个变量，不能指向字符串常量；字符串常量存放在内存位置的字符常量区(详情看内存知识)， 字符串指针指向这个区域，而且这个区域是一个const 属性的不可修改的；因此 再进行拷贝覆盖的时候会出现段错误。</p><h2 id="4-4-正确的例子1"><a href="#4-4-正确的例子1" class="headerlink" title="4.4 正确的例子1"></a>4.4 正确的例子1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">10</span>]=<span class="string">"Shatang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zhu</span><br><span class="line"><span class="number">0x7ffff41e089e</span></span><br></pre></td></tr></table></figure><h2 id="4-5-正确的例子2"><a href="#4-5-正确的例子2" class="headerlink" title="4.5 正确的例子2"></a>4.5 正确的例子2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                           <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    </span><br><span class="line">    s1=(<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));   <span class="comment">//重新分配一块内存给指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zhu</span><br><span class="line"><span class="number">0x144e010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此可见<code>strcpy</code>引发的段错误，并非是野指针引起的；而是编程人对<code>strcpy</code>的用法不了解导致的。</p><h2 id="4-6-得出来的结论"><a href="#4-6-得出来的结论" class="headerlink" title="4.6 得出来的结论"></a>4.6 得出来的结论</h2><p>&emsp;&emsp;只要调用该指针前，先把指针赋值指向对应的内存，就不会影响到系统的健壮性。如果严谨一点，还是把对指针进行 初始化赋值 或 置为<code>NULL</code>吧！ (抽风编译器牛逼!)</p><h1 id="五、经典野指针错误"><a href="#五、经典野指针错误" class="headerlink" title="五、经典野指针错误"></a>五、经典野指针错误</h1><p>&emsp;&emsp;<strong>野指针犯错方式是花式的、神奇的</strong>。随着编译器的不同，野指针造成的结果也不相同；甚至在同一个编译器下，你定义变量的数量不同，多一个或少一个，系统就可能让 未初始化的指针 置<code>NULL</code>或者是分配随机内存。<strong>野指针，强就强在，随机神秘翻车！不仅如此，还是编译通过的后续翻车(关键点)！！！</strong></p><p>&emsp;&emsp;因此，大家也不要对野指针编译的结果不同太诧异。具体的错误例子可以看 <a href="https://shatang.github.io/2020/03/15/32-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/#more">内存分配方式</a> 一节内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="内存" scheme="http://shatang.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="野指针" scheme="http://shatang.github.io/tags/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
