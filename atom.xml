<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大道至简，悟在天成</title>
  
  <subtitle>It&#39;s not hard to give up, but it must be cool to stick to it.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shatang.github.io/"/>
  <updated>2020-05-30T04:11:54.192Z</updated>
  <id>http://shatang.github.io/</id>
  
  <author>
    <name>Shatang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>嵌入式总线_基本概念&amp;比较</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E6%AF%94%E8%BE%83/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式总线-基本概念-比较/</id>
    <published>2020-05-30T03:43:58.000Z</published>
    <updated>2020-05-30T04:11:54.192Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇宏观介绍嵌入式的各种通讯总线，用来比较各总线之间的差别、加深理解。</p><h1 id="一、部分总线概念-可跳着看"><a href="#一、部分总线概念-可跳着看" class="headerlink" title="一、部分总线概念(可跳着看)"></a>一、部分总线概念(可跳着看)</h1><h2 id="1-1-UART"><a href="#1-1-UART" class="headerlink" title="1.1 UART"></a>1.1 UART</h2><p>&emsp;&emsp;UART是一种通用串行数据总线，用于异步通信。该总线双向通信，可以实现全双工传输和接收。在嵌入式设计中，UART用于主机与辅助设备通信，如汽车音响与外接AP之间的通信，与PC机通信包括与监控调试器和其它器件，如EEPROM通信。</p><h3 id="1-1-1-接口"><a href="#1-1-1-接口" class="headerlink" title="1.1.1 接口"></a>1.1.1 接口</h3><p>&emsp;&emsp;在单片机中UART可以说是一种最基本的配置，很多与电脑进行通信的设备都采用到它，按计算机最常规的说法就是串行通信。</p><ul><li>TX - 数据发送接口</li><li>RX - 数据接受接口</li></ul><p>&emsp;&emsp;两个设备间将TX与RX相连，RX与TX相连即可正常工作。最常用到的就是我们电脑上的USB那就是个最典型的UART接口。</p><h3 id="1-1-2-工作原理"><a href="#1-1-2-工作原理" class="headerlink" title="1.1.2 工作原理"></a>1.1.2 工作原理</h3><blockquote><p>发送接收</p></blockquote><p>&emsp;&emsp;发送逻辑对从发送FIFO 读取的数据执行“并→串”转换。控制逻辑输出起始位在先的串行位流，并且根据控制寄存器中已编程的配置，后面紧跟着数据位（注意：最低位 LSB 先输出）、奇偶校验位和停止位。<br>在检测到一个有效的起始脉冲后，接收逻辑对接收到的位流执行“串→并”转换。此外还会对溢出错误、奇偶校验错误、帧错误和线中止（line-break）错误进行检测，并将检测到的状态附加到被写入接收FIFO 的数据中。</p><hr><blockquote><p>波特率产生</p></blockquote><p>&emsp;&emsp;波特率除数（baud-rate divisor）是一个22 位数，它由16 位整数和6 位小数组成。波特率发生器使用这两个值组成的数字来决定位周期。通过带有小数波特率的除法器，在足够高的系统时钟速率下，UART 可以产生所有标准的波特率，而误差很小。</p><hr><blockquote><p>数据收发</p></blockquote><p>&emsp;&emsp;发送时，数据被写入发送FIFO。如果UART 被使能，则会按照预先设置好的参数（波特率、数据位、停止位、校验位等）开始发送数据，一直到发送FIFO 中没有数据。一旦向发送FIFO 写数据（如果FIFO 未空），UART 的忙标志位BUSY 就有效，并且在发送数据期间一直保持有效。BUSY 位仅在发送FIFO 为空，且已从移位寄存器发送最后一个字符，包括停止位时才变无效。即 UART 不再使能，它也可以指示忙状态。BUSY 位的相关库函数是UARTBusy( )<br>在UART 接收器空闲时，如果数据输入变成“低电平”，即接收到了起始位，则接收计数器开始运行，并且数据在Baud16 的第8 个周期被采样。如果Rx 在Baud16 的第8 周期仍然为低电平，则起始位有效，否则会被认为是错误的起始位并将其忽略。<br>如果起始位有效，则根据数据字符被编程的长度，在 Baud16 的每第 16 个周期（即一个位周期之后）对连续的数据位进行采样。如果奇偶校验模式使能，则还会检测奇偶校验位。<br>最后，如果Rx 为高电平，则有效的停止位被确认，否则发生帧错误。当接收到一个完整的字符时，将数据存放在接收FIFO 中。</p><hr><blockquote><p>中断控制</p></blockquote><p>出现以下情况时，可使UART 产生中断：</p><ul><li>FIFO 溢出错误</li><li>线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）</li><li>奇偶校验错误</li><li>帧错误（停止位不为1）</li><li>接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）</li><li>发送</li><li>接收</li></ul><p>&emsp;&emsp;由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数UARTIntStatus( )，软件可以在同一个中断服务函数里处理多个中断事件（多个并列的if 语句）。</p><h2 id="1-2-I2C"><a href="#1-2-I2C" class="headerlink" title="1.2 I2C"></a>1.2 I2C</h2><p>&emsp;&emsp;I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。</p><p>&emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p><h3 id="1-2-1-接口"><a href="#1-2-1-接口" class="headerlink" title="1.2.1 接口"></a>1.2.1 接口</h3><ul><li>SCL - 串行时钟线</li><li>SDA - 串行数据线接口</li></ul><p>&emsp;&emsp;<strong>SDA（串行数据线）和SCL（串行时钟线）都是双向I/O线，接口电路为开漏输出．需通过上拉电阻接电源VCC。</strong> 当总线空闲时．两根线都是高电平，连接总线的外同器件都是CMOS器件，输出级也是开漏电路．在总线上消耗的电流很小，因此，总线上扩展的器件数量主要由电容负载来决定，因为每个器件的总线接口都有一定的等效电容．而线路中电容会影响总线传输速度．当电容过大时，有可能造成传输错误．所以，其负载能力为400pF，因此可以估算出总线允许长度和所接器件数量。</p><p>&emsp;&emsp;主器件用于启动总线传送数据，并产生时钟以开放传送的器件，此时任何被寻址的器件均被认为是从器件．在总线上主和从、发和收的关系不是恒定的，而取决于此时数据传送方向。如果主机要发送数据给从器件，则主机首先寻址从器件，然后主动发送数据至从器件，最后由主机终止数据传送；如果主机要接收从器件的数据，首先由主器件寻址从器件．然后主机接收从器件发送的数据，最后由主机终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。</p><h3 id="1-2-2-特点"><a href="#1-2-2-特点" class="headerlink" title="1.2.2 特点"></a>1.2.2 特点</h3><p>I2C总线特点可以概括如下：</p><ul><li>在硬件上，I2C总线只需要一根数据线和一根时钟线两根线，总线接口已经集成在芯片内部，不需要特殊的接口电路，而且片上接口电路的滤波器可以滤去总线数据上的毛刺．因此I2C总线简化了硬件电路PCB布线，降低了系统成本，提高了系统可靠性。因为I2C芯片除了这两根线和少量中断线，与系统再没有连接的线，用户常用IC可以很容易形成标准化和模块化，便于重复利用。</li><li>I2C总线是一个真正的多主机总线，如果两个或多个主机同时初始化数据传输，可以通过冲突检测和仲裁防止数据破坏，每个连接到总线上的器件都有唯一的地址，任何器件既可以作为主机也可以作为从机，但同一时刻只允许有一个主机。数据传输和地址设定由软件设定，非常灵活。总线上的器件增加和删除不影响其他器件正常工作。</li><li>I2C总线可以通过外部连线进行在线检测，便于系统故障诊断和调试，故障可以立即被寻址，软件也利于标准化和模块化，缩短开发时问。</li><li>连接到相同总线上的IC数量只受总线最大电容的限制，串行的8位双向数据传输位速率在标准模式下可达100Kbit/s，快速模式下可达400Kbit/s，高速模式下可达3．4Mbit/s。</li><li>总线具有极低的电流消耗．抗高噪声干扰，增加总线驱动器可以使总线电容扩大10倍，传输距离达到15m；兼容不同电压等级的器件，工作温度范围宽。</li></ul><h3 id="1-2-3-数据传输方式"><a href="#1-2-3-数据传输方式" class="headerlink" title="1.2.3 数据传输方式"></a>1.2.3 数据传输方式</h3><blockquote><p>字节格式</p></blockquote><p>&emsp;&emsp;发送到SDA 线上的每个字节必须为8 位，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位（MSB），如果从机要完成一些其他功能后（例如一个内部中断服务程序）才能接收或发送下一个完整的数据字节，可以使时钟线SCL 保持低电平，迫使主机进入等待状态，当从机准备好接收下一个数据字节并释放时钟线SCL 后数据传输继续。</p><hr><blockquote><p>应答响应</p></blockquote><p>&emsp;&emsp; 数据传输必须带响应，相关的响应时钟脉冲由主机产生。在响应的时钟脉冲期间发送器释放SDA 线（高）。在响应的时钟脉冲期间，接收器必须将SDA线拉低，使它在这个时钟脉冲的高电平期间保持稳定的低电平。通常被寻址的接收器在接收到的每个字节后，除了用CBUS 地址开头的数据，必须产生一个响应。当从机不能响应从机地址时（例如它正在执行一些实时函数不能接收或发送），从机必须使数据线保持高电平，主机然后产生一个停止条件终止传输或者产生重复起始条件开始新的传输。</p><p>&emsp;&emsp;如果从机接收器响应了从机地址，但是在传输了一段时间后不能接收更多数据字节，主机必须再一次终止传输。这个情况用从机在第一个字节后没有产生响应来表示。从机使数据线保持高电平，主机产生一个停止或重复起始条件。<br>如果传输中有主机接收器，它必须通过在从机发出的最后一个字节时产生一个响应，向从机发送器通知数据结束。从机发送器必须释放数据线，允许主机产生一个停止或重复起始条件。</p><hr><blockquote><p>时钟同步</p></blockquote><p>&emsp;&emsp;所有主机在SCL线上产生它们自己的时钟来传输I2C总线上的报文。数据只在时钟的高电平周期有效，因此需要一个确定的时钟进行逐位仲裁。</p><p>&emsp;&emsp;时钟同步通过线与连接I2C 接口到SCL 线来执行。这就是说SCL 线的高到低切换会使器件开始数它们的低电平周期，而且一旦器件的时钟变低电平，它会使SCL 线保持这种状态直到到达时钟的高电平。但是如果另一个时钟仍处于低电平周期，这个时钟的低到高切换不会改变SCL 线的状态。因此SCL 线被有最长低电平周期的器件保持低电平。此时低电平周期短的器件会进入高电平的等待状态。</p><p>&emsp;&emsp;当所有有关的器件数完了它们的低电平周期后，时钟线被释放并变成高电平。之后，器件时钟和SCL线的状态没有差别，而且所有器件会开始数它们的高电平周期。首先完成高电平周期的器件会再次将SCL线拉低。这样产生的同步SCL 时钟的低电平周期由低电平时钟周期最长的器件决定，而高电平周期由高电平时钟周期最短的器件决定。</p><h2 id="1-3-SPI"><a href="#1-3-SPI" class="headerlink" title="1.3 SPI"></a>1.3 SPI</h2><p>&emsp;&emsp;SPI接口的全称是”Serial Peripheral Interface”，意为串行外围接口,是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在EEPROM、FLASH、实时时钟、AD转换器，还有数字信号处理器和数字信号解码器之间。<br>SPI接口是在CPU和外围低速器件之间进行同步串行数据传输，在主器件的移位脉冲下，数据按位传输，高位在前，低位在后，为全双工通信，数据传输速度总体来说比I2C总线要快，速度可达到几Mbps。</p><h3 id="1-3-1-接口"><a href="#1-3-1-接口" class="headerlink" title="1.3.1 接口"></a>1.3.1 接口</h3><ul><li>MOSI – 主器件数据输出，从器件数据输入</li><li>MISO – 主器件数据输入，从器件数据输出</li><li>SCLK –时钟信号，由主器件产生,最大为fPCLK/2，从模式频率最大为fCPU/2</li><li>NSS – 从器件使能信号，由主器件控制,有的IC会标注为CS(Chip select)</li></ul><p>&emsp;&emsp;在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信，显得简单高效。<strong>在多个从器件的系统中，每个从器件需要独立的使能信号，硬件上比I2C系统要稍微复杂一些。</strong> SPI接口在内部硬件实际上是两个简单的移位寄存器，传输的数据为8位，在主器件产生的从器件使能信号和移位脉冲下，按位传输，高位在前，低位在后。</p><h3 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h3><ul><li>协议简单，相对数据速率高。</li><li>占用的Pin口较多</li><li>没有指定的流控制，没有应答机制确认是否接收到数据。</li></ul><h1 id="二、速率对比"><a href="#二、速率对比" class="headerlink" title="二、速率对比"></a>二、速率对比</h1><ul><li>UART： 无限制，常用9600、115200bps等保证双方通信速度相同。</li><li>IIC：通讯速率400Kbps</li><li>CAN：一般为1Mbps</li><li>SPI：通信速率为 fosc/4；其理论传输速度可达几Mb/s(其速率可以通过限制其SPI的时钟来实现限制速率)<ul><li>缺点：抗干扰能力差。SPI采用的是单端非平衡的传输方式，即传输的数据位的电压电平是以公共地作为参考的。在这种传输方式中对于已进入信号中的干扰是无法消除和减弱的。而信号在传输过程中总会受到干扰，而且距离越长干扰越严重，以致于信号传输产生错误。在这种条件下，信号传输就变得毫无意义了。另外，由于单端非平衡传输方式以公共地作为参考点，地线作为信号回流线，因此也存在信号电流。当传输线两端的系统之间存在交流电位差时，这个电位差将直接窜到信号中，形成噪声干扰。所以，为了解决抗干扰问题，通常采用平衡传输(balanced transmission)方式，这里采用比较常见的RS-422。</li><li>应用：读写flash（存有字库，图片等等）芯片，与触摸屏控制器通信，还有就是读写sd卡了，你手机里的sd卡就是通过spi和处理器传数据的，目前高速都用SDIO了。    </li></ul></li><li>SDIO： 10M及已上</li><li>SDRAM：（非总线）16位的，100m频率就是1.6Gbit读写</li><li>PCI：（网卡）传输速率高最大数据传输率为132MB/s（工作在33MHz 频率之下），当数据宽度升级到64位，数据传输率可达264MB/s。这是其他总线难以比拟的。它大大缓解了数据I/O瓶颈，使高性能CPU的功能得以充分发挥，适应高速设备数据传输的需要。</li><li>PCI Express 2.0 ： 理论值 10Gbps，实际大于100MB</li><li>USB2.0 ： 一般30~40MB</li><li>Ethenet ：一般70~80MB</li></ul><h1 id="三、常见通讯总线疑问"><a href="#三、常见通讯总线疑问" class="headerlink" title="三、常见通讯总线疑问"></a>三、常见通讯总线疑问</h1><h2 id="3-1-USART-amp-UART"><a href="#3-1-USART-amp-UART" class="headerlink" title="3.1 USART &amp; UART"></a>3.1 USART &amp; UART</h2><ul><li>USART：通用同步和异步收发器</li><li>UART：通用异步收发器</li></ul><p>&emsp;&emsp;当进行异步通信时,这两者是没有区别的。区别在于USART比UART多了同步通信功能。<br>这个同步通信功能可以把USART当做SPI来用，比如用USART来驱动SPI设备。</p><ul><li>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。  </li><li>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</li></ul><hr><p>同步是阻塞模式，异步是非阻塞模式。</p><p><strong><font color="red">Ps：</font></strong><br>其中SPI 、IIC为同步通信，Uart为异步通信, Usart为同步&amp;异步通信。</p><h2 id="3-2-单工、半双工、全双工"><a href="#3-2-单工、半双工、全双工" class="headerlink" title="3.2 单工、半双工、全双工"></a>3.2 单工、半双工、全双工</h2><ul><li>单工数据传输只支持数据在一个方向上传输；</li><li>半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输；它实际上是一种切换方向的单工通信；</li><li>全双工数据通信允许数据同时在两个方向上传输；因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 </li></ul><p><strong><font color="red">Ps：</font></strong><br>I2C是半双工，SPI的全双工，Usart是全双工；串口232是全双工 ，串口485是半双工。</p><h2 id="3-3-波特率-计算-发送速率"><a href="#3-3-波特率-计算-发送速率" class="headerlink" title="3.3 波特率 计算 发送速率"></a>3.3 波特率 计算 发送速率</h2><ul><li>B = byte表示“字节”</li><li>b = bit表示“比特”</li><li>bps就是比特每秒</li></ul><blockquote><p>1 Kb=1024 bit，1 KB=1024 byte，1 byte=8 bit</p></blockquote><p>举例，115200bps就是每秒传输115200比特(115200bit)，所以115200bps=每秒112.5kb=每秒14.0625kB。</p><hr><blockquote><p>举例计算速率</p></blockquote><ul><li>波特率115200 ＝ 115200 (位/秒)</li><li>根据常规串口发送协议,一个起始位,8个数据位,0个校验位,1个停止位,共计10位二进制数</li><li>如果没有校验位，就应该除以 10，得到的是每秒字节数：<ul><li>波特率115200 ＝ 115200 (位/秒) ＝ 11520 (字节/秒) </li><li>再除以 1024，就是每秒 KB 数</li><li>波特率115200 ＝ 115200 (位/秒) ＝ 11.25 (KB/秒) </li></ul></li><li>如果有一位奇偶校验位，就应该除以 11，得到的是每秒字节数。<ul><li>最后：波特率115200 ＝ 115200 (位/秒) ＝ 10.27 (KB/秒)</li></ul></li></ul><h2 id="3-4-RS485-amp-Modbus"><a href="#3-4-RS485-amp-Modbus" class="headerlink" title="3.4 RS485 &amp; Modbus"></a>3.4 RS485 &amp; Modbus</h2><ul><li>RS485 ：是一个物理接口，简单的说是硬件。</li><li>MODBUS ：是一种国际标准的通讯协议，用于不同厂商之间的设备交换数据（一般是工业用途）；所谓协议，也可以理解为上面有人说的“语言”吧，简单的说是软件。</li></ul><hr><ul><li>RS485属于有线传输，所以就要硬件传输媒介，实际就是两根线就可以了，在这两根线上传输的实际是同一个信号，只是发送端把这个信号一分为二，不过在接收端会把它还原为原来的信号，这样做的好处还要得和RS232来比较；RS232也需要两根线，更多的时候还要加上地线，所以是三根线，地线咱不管它，其余的两根只有一根线传输的数据信号，而另一根传输的时钟，也就是信号原来什么样发送端就怎样发送出来，同样接收端也做同样的处理。所以485的接收端可以把信号在传输过程中引入的干扰就可以抵消掉，而232的接收端不能，所以485的抗干扰能力强可以传输信号上千米，而232只能传输十几米。 </li><li>MODBUS只是通信协议的一种，就像汉语和英语一样，就是一种交流的语言，一种机器之间交流的语言。那么在交流之前肯定要有沟通的桥梁吧，那就是传输媒介485或232或其他电气规则，<strong>同一种协议可以用不同的传输媒介方式，如485或232；但是同一传输线路上不能同时存在两种协议。</strong></li></ul><p>&emsp;&emsp;一般情况下，两台设备通过MODBUS协议传输数据：<br>最早是用RS232C作为硬件接口(也就是普通电脑上的串行通讯口(串口))；<br>也有用RS422的；也有常用的RS485，这种接口传输距离远，在一般工业现场用的比较多。</p><h2 id="3-5-RS485-amp-CAN"><a href="#3-5-RS485-amp-CAN" class="headerlink" title="3.5 RS485 &amp; CAN"></a>3.5 RS485 &amp; CAN</h2><p>&emsp;&emsp;为什么会有这个的比较？</p><p>其实，RS485和CAN是很相似的：</p><ol><li>均为差分信号，抗干扰强；(即，都为半双工)</li><li>均为双线连接</li><li>均可挂多个子设备</li></ol><hr><blockquote><p>CAN总线特点：</p></blockquote><ol><li>国际标准的工业级现场总线，传输可靠，实时性高；  </li><li>传输距离远（最远10Km），传输速率快（最高1MHz bps）； </li><li>单条总线最多可接110个节点，并可方便的扩充节点数；  </li><li>多主结构，各节点的地位平等，方便区域组网，总线利用率高；  </li><li>实时性高，非破坏总线仲裁技术，优先级高的节点无延时；  </li><li>出错的CAN节点会自动关闭并切断和总线的联系，不影响总线的通讯；  </li><li>报文为短帧结构并有硬件CRC校验，受干扰概率小，数据出错率极低；  </li><li>自动检测报文发送成功与否，可硬件自动重发，传输可靠性很高；  </li><li>硬件报文滤波功能，只接收必要信息，减轻cpu负担，简化软件编制；  </li><li>通讯介质可用普通的双绞线，同轴电缆或光纤等；  </li><li>CAN总线系统结构简单，有极高的性价比。</li></ol><hr><blockquote><p>RS485接口标准特点：</p></blockquote><ol><li>RS-485的电气特性：逻辑”1”以两线间的电压差为+（2-6）V表示；逻辑”0”以两线间的电压差为-（2-6）V表示。接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL 电路连接。</li><li>RS-485的数据最高传输速率为10Mbps</li><li>RS-485接口是采用平衡驱动器和差分接收器的组合，抗共模干能力增强，即抗噪声干扰性好。</li><li>RS-485接口的最大传输距离标准值为4000英尺，实际上可达 3000米，另外RS-232-C接口在总线上只允许连接1个收发器，即单站能力。而RS-485接口在总线上是允许连接多达128个收发器。即具有多站能力,这样用户可以利用单一的RS-485接口方便地建立起设备网络。但RS-485总线上任何时候只能有一发送器发送。</li><li>因RS-485接口具有良好的抗噪声干扰性，长的传输距离和多站能力等上述优点就使其成为首选的串行接口。 </li><li>因为RS485接口组成的半双工网络，一般只需二根连线，所以RS485接口均采用屏蔽双绞线传输。 </li></ol><hr><blockquote><p>CAN总线与RS485的比较：</p></blockquote><ul><li><strong>速度与距离</strong>：CAN与RS485以1Mbit/S的高速率传输的距离都不超过100M，可谓高速上的距离差不多。但是在低速时CAN以5Kbit/S时，距离可达10KM，而485再低的速率也只能到1219米左右（都无中继）。可见CAN在长距离的传输上拥有绝对的优势。</li><li><strong>总线利用率</strong>：RS485是单主从结构，就是一个总线上只能有一台主机，通讯都由它发起的，它没有下命令，下面的节点不能发送，而且要发完即答，受到答复后，主机才向下一个节点询问，这样是为了防止多个节点向总线发送数据，而造成数据错乱。而CAN－bus是多主从结构，每个节点都有CAN控制器，多个节点发送时，以发送的ID号自动进行仲裁，这样就可以实现总线数据不错乱，而且一个节点发完，另一个节点可以探测到总线空闲，而马上发送，这样省去了主机的询问，提高了总线利用率，增强了快速性。所以在汽车等实性要求高的系统，都是用CAN总线，或者其他类似的总线。</li><li><strong>错误检测机制</strong>：RS485只规定了物理层，而没有数据链路层，所以它对错误是无法识别的，除非一些短路等物理错误。这样容易造成一个节点破坏了，拼命向总线发数据（一直发1），这样造成整个总线瘫痪。所以RS485一旦坏一个节点，这个总线网络都挂。而CAN总线有CAN控制器，可以对总线任何错误进行检测，如果自身错误超过128个，就自动闭锁。保护总线。如果检测到其他节点错误或者自身错误，都会向总线发送错误帧，来提示其他节点，这个数据是错误的。大家小心。这样CAN总线一旦有一个节点CPU程序跑飞了，它的控制器自动闭锁。保护总线。所以在安全性要求高的网路，CAN是很强的。</li><li><strong>价格与培训成本</strong>：CAN器件的价格大约是485的2倍这样，485的通讯从软件上是很方便的，只要懂串行通讯，就可以编程，而CAN需要底层工程师了解CAN复杂的层，编写上位机软件也要了解CAN的协议。可谓培训成本较高。</li><li>CAN总线通过CAN控制器接口芯片82C250的两个输出端CANH和CANL与物理总线相连，而CANH端的状态只能是高电平或悬浮状态，CANL端只能是低电平或悬浮状态。这就保证不会出现象在RS-485网络中，当系统有错误，出现多节点同时向总线发送数据时，导致总线呈现短路，从而损坏某些节点的现象。而且CAN节点在错误严重的情况下具有自动关闭输出功能，以使总线上其他节点的操作不受影响，从而保证不会出现象在网络中，因个别节点出现问题，使得总线处于“死锁”状态。</li><li>CAN具有完善的通信协议，可由CAN控制器芯片及其接口芯片来实现，从而大大降低了系统的开发难度，缩短了开发周期，这些是只仅仅有电气协议的RS-485所无法比拟的。</li></ul><table><thead><tr><th>特性</th><th align="center">RS-485</th><th align="center">CAN-bus</th></tr></thead><tbody><tr><td>单点成本</td><td align="center">低廉</td><td align="center">稍高</td></tr><tr><td>系统成本</td><td align="center">高</td><td align="center">较低</td></tr><tr><td>总线利用率</td><td align="center">低</td><td align="center">高</td></tr><tr><td>网络特性</td><td align="center">单主网络</td><td align="center">多主网络</td></tr><tr><td>数据传输率</td><td align="center">低</td><td align="center">高</td></tr><tr><td>容错机制</td><td align="center">无</td><td align="center">可靠的错误处理和检错机制</td></tr><tr><td>通讯失败率</td><td align="center">高</td><td align="center">极低</td></tr><tr><td>节点错误的影响</td><td align="center">导致整个网络的瘫痪</td><td align="center">无任何影响</td></tr><tr><td>通讯距离</td><td align="center">&lt;1.5km</td><td align="center">可达10km（5kbps）</td></tr><tr><td>网络调试</td><td align="center">困难</td><td align="center">非常容易</td></tr><tr><td>开发难度</td><td align="center">标准Modbus协议</td><td align="center">标准CAN-bus协议</td></tr><tr><td>后期维护成本</td><td align="center">高</td><td align="center">低</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;这篇宏观介绍嵌入式的各种通讯总线，用来比较各总线之间的差别、加深理解。&lt;/p&gt;
&lt;h1 id=&quot;一、部分总线概念-可跳着看&quot;&gt;&lt;a href=&quot;#一、部分总线概念-可跳着看&quot; class=&quot;headerlink&quot; title=&quot;一、部分总线概念(可跳
      
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>微库 &amp; 断言 &amp; (Keil)代码优化</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%BE%AE%E5%BA%93-%E6%96%AD%E8%A8%80-Keil-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>http://shatang.github.io/2020/05/30/微库-断言-Keil-代码优化/</id>
    <published>2020-05-30T03:31:09.000Z</published>
    <updated>2020-05-30T03:34:20.668Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍 在Keil平台开发嵌入式遇到的一些东西：MicroLIB、Assert、代码优化。</p><a id="more"></a><h1 id="一、MicroLIB"><a href="#一、MicroLIB" class="headerlink" title="一、MicroLIB"></a>一、MicroLIB</h1><h2 id="1-1-Use-MicroLIB-amp-printf"><a href="#1-1-Use-MicroLIB-amp-printf" class="headerlink" title="1.1 Use MicroLIB &amp; printf"></a>1.1 Use MicroLIB &amp; printf</h2><p>&emsp;&emsp;大多人一般之所以使用 <code>Use MicroLIB</code>，是因为使能后能够直接调用<code>printf()</code>等函数。</p><p>&emsp;&emsp;<code>printf()</code>之类的库函数，是一些很骚的东西；使用printf、 fopen等库函数库函数调用，会让软件进入半主机模式。但是<code>printf()</code>库函数本身 不需要半主机模式(关掉,当然也能用printf)。</p><p>使用C标准库(stdio.h)中的函数，例如<code>printf()</code>之类的函数，会进入半主机模式，<br>发生软件异常，会导致程序无法运行 ,以下是解决方法 :</p><ul><li>方法 1.使用微库 ,因为使用微库的话 ,不会使用半主机模式。MDK 勾选 <code>Use MicroLIB</code>这样以后就可以<br>使用 <code>printf</code> ，<code>sprintf</code> 函数了</li><li>方法 2.仍然使用标准库 ,在主程序添加下面代码 :<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此段代码可以在正点原子例程Uart处找到</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> import(__use_no_semihosting)  <span class="comment">//确保没有从 C 库链接使用半主机的函数</span></span></span><br><span class="line">_sys_exit(<span class="keyword">int</span>  x) <span class="comment">//定义 _sys_exit() 以避免使用半主机模式</span></span><br><span class="line">&#123;</span><br><span class="line">x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span>  // 标准库需要的支持函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;选上<code>Use MicroLIB</code>，例如你用<code>printf()</code>函数的时候，就会从串口1输出字符串，直接默认定向到串口1。</p><hr><ul><li>法1可实现串口1数据输出，但要定向到串口2，串口3，microLIB就不合用了；</li><li>法2虽然能够映射其他串口，但是如果同时涉及到多串口也是有问题。</li></ul><p>&emsp;&emsp;总而言之，实际上 法1 &amp; 法2 都不推荐用于实际项目，顶多就用于快速搭建Demo 或 做测试用。</p><h2 id="1-2-半主机-amp-printf"><a href="#1-2-半主机-amp-printf" class="headerlink" title="1.2 半主机 &amp; printf"></a>1.2 半主机 &amp; printf</h2><p>&emsp;&emsp;半主机模式是这么一种机制：它使得在ARM目标上跑的代码，如果主机电脑运行了调试器，那么该代码可以使用该主机电脑的输入输出设备。这点非常重要，因为开发初期，可能开发者根本不知道该ARM器件上有什么输入输出设备，而半主机机制使得你不用知道ARM器件的外设，利用主机电脑的外设就可以实现输入输出调试。</p><p>&emsp;&emsp;所以，如果不用主机电脑的外设就可以实现输入输出调试，而是要利用目标ARM器件的输入输出设备，首先要关掉半主机机制。然后再将输入输出重定向到ARM器件上，如printf和scanf，你需要重写fputc和fgetc函数(原有的输入输出，标准库函数的默认输出设备是显示器)。</p><h2 id="1-3-MicroLIB"><a href="#1-3-MicroLIB" class="headerlink" title="1.3 MicroLIB"></a>1.3 MicroLIB</h2><p>&emsp;&emsp;之所以在代码优化提及到MicroLIB，是因为微库本身由于有精简代码的效果，因此它可以用来压缩代码量。</p><p>MicroLIB 与 缺省C库 之间的主要差异是： </p><ol><li>microlib 不符合 ISO C 库标准。 不支持某些 ISO 特性，并且其他特性具有的功能也较少。 </li><li>microlib 不符合 IEEE 754 二进制浮点算法标准。 </li><li>microlib 进行了高度优化以使代码变得很小。</li></ol><p>&emsp;&emsp;还有更多细节上的差异就不罗列出来了，直接网上一查一大把。但是，也正是这些零零碎碎的差异，可能就导致你做项目时疯狂翻车，所以一般不建议使用 MicroLIB (还有其他原因等等，尤其是项目刚开发的时候真不建议使用)。</p><hr><p>以下是我对该库的总结：</p><ul><li>MicroLIB库 虽然能够进行代码大小优化。<ul><li>但是实际测试的效果真的是杯水车薪，可以忽略不计；还不如自己去优化代码 or 提高优化等级。如果是其他方式都用了后，只能通过MicroLIB库优化代码，建议直接换硬件(真的是优化没多少的)。</li><li>由于microlib中进行了优化，以尽量减少代码大小，一些功能将会比ARM编译工具提供了标准C库函数更慢执行；例如，memcpy()。效率换空间，在项目大部分是 空间换效率，这当然是不建议的。</li></ul></li><li>MicroLIB库 不支持浮点数运算。<ul><li>ST除了F4xx系列，其他是没有FPU单元，都是采用软件模拟运算。</li><li>故，移植UcosII在F4xx系列，不选 Use MicroLIB，开了FPU就会死机</li></ul></li><li>MicroLIB库 不支持半主机模式，进而支持<code>printf()</code>函数。但是实际用起来还是不太好用</li></ul><p>&emsp;&emsp;一般来讲，最好不要加。它和标准库有很多繁琐区别，对代码的维护性不好。</p><p>常见的有以下情况：</p><p>&emsp;&emsp;当旧的项目工程要换新的硬件平台，迁移的时候发现异常。建议查看一下旧项目工程是否采用了微库；然后查看旧代码是不是调用了<code>printf</code>之类的C库函数。如果调用就用上述的方法，Use MicroLIB 或者 关闭半主机模式(+重定向)。</p><h1 id="二、assert"><a href="#二、assert" class="headerlink" title="二、assert"></a>二、assert</h1><p>&emsp;&emsp;assert() 不仅仅是个(字面意义上)报错函数！<strong>对于在开发过程中的程序员来说，加断言是个好习惯，可以帮助调试。</strong></p><p>程序在假设条件下，能够正常良好的运作，那assert()其实就相当于一个 if 语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(假设成立)</span><br><span class="line">&#123;</span><br><span class="line">     程序正常运行；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      报错&amp;&amp;终止程序！（避免由程序运行引起更大的错误）  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可能有人说，断言的功能可以用if语句对异常情况进行处理来代替。以下列举 断言 的好处：</p><ul><li>实现效果最后不会增加代码量<ul><li>if是实的，真正的增加代码量，降低执行效率；</li><li>断言是虚的，在Debug的时候可以帮助调试，在Release的时候并不存在。</li></ul></li><li>断言，实际上也是一种文档。断言设定了，函数的入口条件。增加了代码的可读性。</li><li>断言用于在开发阶段监测BUG，进行调试。<ul><li>断言其存在的意义在于检测代码在开发过程中是否出现了问题。</li><li>而”if… “,更准确的说是错误处理，是在你的release版本中也实实在在应该有的，处理程序运行过程中产生的错误并进行处理，以提高程序的健壮性。</li></ul></li></ul><p>&emsp;&emsp;如果是看过Stm32的库函数实现方式的话，肯定会看到<code>assert_param(expr) ((void)0)</code>。这也是断言，不过是ST官方自己写的断言函数；而且有个宏定义用来是否失活该断言函数。当你打开一份Stm32的例程，进去库函数就会发现这些<code>assert_param(expr) ((void)0)</code>是失活的。</p><p><strong><font color="red">Ps：</font>MicroLIB 库并不支持assert()函数，两者同时用产生报错。</strong></p><p>&emsp;&emsp;microlib是一个比ARM标准C库小的独立库。为了节省大小，arm microlib c库不支持或实现几乎所有与操作系统交互的函数，例如abort（）、exit（）或assert（）。</p><hr><p>&emsp;&emsp;如何在Release版本去掉assert？</p><p>方法一：常见任何平台处理</p><p>&emsp;&emsp;在调试结束后，可以通过在包含<code>#include <assert.h></assert.h></code>的语句之前插入 <code>#define NDEBUG</code> 来禁用assert调用，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法二：在Keil平台上</p><p>&emsp;&emsp;在工程参数设置一栏，在“Preprocessor Symbols”的“Define”栏输入“NDEBUG”。等同于在代码中添加宏定义“#define NDEBUG”。实际为上面方法。</p><p>方法三：在Keil平台上</p><p>&emsp;&emsp;提高代码优化等级至2。在代码优化Level 0时，断言是占用空间可执行的；当代码优化提升为Level 2。这个时候就能够去掉assert()函数处理</p><h1 id="三、Keil的代码优化等级"><a href="#三、Keil的代码优化等级" class="headerlink" title="三、Keil的代码优化等级"></a>三、Keil的代码优化等级</h1><h2 id="3-1-代码优化等级"><a href="#3-1-代码优化等级" class="headerlink" title="3.1 代码优化等级"></a>3.1 代码优化等级</h2><p>&emsp;&emsp;C/C++的优化等级会对程序产生 <strong>不定性的影响</strong>，至于选择哪种优化等级必须从 现有的程序分析才行！</p><ul><li>Level 0 (-O0)：关闭大部分优化，除了一些简单的转换，生成的代码具有最佳的调试视图。</li><li>Level 1 (-O1)：应用受限优化。<br>比如：删除未使用的内联函数和静态函数，删除冗余代码和重新排序指令等。生成的代码经过合理优化，具有良好的调试视图。</li><li>Level 2 (-O2): 高度优化，目标代码到源代码的映射并不一定对应，因此，不利于调试。</li><li>Level 3 (-O3)：最大级别优化。级别3与时间优化相结合可能生成比级别2更多的代码。</li></ul><hr><p>&emsp;&emsp;经实际测试，<code>Level 2</code>升<code>Level 3</code>并不能节省很多的空间；相反，<code>Level 3</code>更高几率造成程序运行问题。从 <code>Level 0</code>升<code>Level 2</code>，相当于20%时间获取80%成果；从 <code>Level 2</code>升<code>Level 3</code>，相当于80%时间获取20%成果。如果对程序没有太过严苛的要求，建议程序整体在<code>Level 2</code>即可。</p><h2 id="3-2-优化随之带来的Bug"><a href="#3-2-优化随之带来的Bug" class="headerlink" title="3.2 优化随之带来的Bug"></a>3.2 优化随之带来的Bug</h2><p>代码优化产生的Bug情况：</p><ol><li>有更新的变量被优化而没有重新读取值，导致错误</li><li>优化后，代码段被跳过(不执行)</li><li>Keil软件自带的软件Bug</li><li>小心一些驱动，尤其是涉及到文件管理，因为该底层驱动极有可能里面用了C库函数实现了某些功能；而C库函数有些一旦提高优化等级就会出问题(例如，SD卡文件系统)。</li></ol><blockquote><p>例子1</p></blockquote><p>&emsp;&emsp;楼主编写一个stm32F10x系列的SPI库函数驱动。程序未优化前(LEVEL 0)，MISO能正常接收信息，优化后(Level 2)，MISO接收的信息都是错误的。</p><p>&emsp;&emsp;IAP平台之前也出现这个问题，现在貌似被修复了；但是Keil平台看起来还有。</p><blockquote><p>例子2</p></blockquote><p>&emsp;&emsp;近日在移植LPC1788的lwip驱动和SD卡（带文件系统）驱动时，遇到单独移植每个驱动都正常，移植到一起就一直出现HardFault_Handler错误。单步调试后发现编译器优化导致部分代码被跳过的情况。</p><p>&emsp;&emsp;仔细检查后发现官网例程中的LWIP驱动使用的是最高级（LEVEL3）优化等级，而SD卡驱动使用LEVEL0等级的优化。移植后统一修改为LEVEL3导致初始化SD卡f_open文件失败。</p><p>网上查找资料后，处理此类问题有下面几种方法：</p><ol><li>单步调试，找到被优化的代码段，看是否有更新的变量被优化而没有重新读取值，导致错误。若有，加入valotile关键字。</li><li>通过options of file”…”将被优化文件的优化等级调成特定等级。</li></ol><h2 id="3-3-小总结"><a href="#3-3-小总结" class="headerlink" title="3.3 小总结"></a>3.3 小总结</h2><ul><li><strong>不建议小白直接上<code>Level 2</code>及<code>Level 3</code>搭建新工程！</strong></li><li>代码优化等级方面，我建议新建项目时，最好采用<code>Level 0</code> 搭建工程。等到项目比较完善的时候，再提升优化等级至<code>Level 2</code>，再根据优化等级出现的问题，进行逐步调试。</li><li>建议项目整体基本优化等级为<code>Level 2</code>，不需要升为<code>Level 3</code>。</li><li>有些底层驱动确实是不好提高代码优化等级(尤其涉及到文件系统)。</li></ul><hr><p>&emsp;&emsp;努力提高优化等级并不是厉害！在能力有限的情况下，费时费力；尤其是硬件Flash资源明显不够用时，虽然通过最高优化等级能应用，但是会对后面的升级更新、bug检查造成很大的麻烦：</p><ul><li>仿真无法查看，优化等级太高</li><li>一旦降低优化等级，硬件编译报错，Flash存储不够</li><li>唯一的途径，就是把程序其他代码删除，留下所需的代码进行仿真调试局部(无法调试整体)</li><li>建议还是更换有更大Flash的MCU，或者自己优化一下程序代码</li></ul><hr><p>&emsp;&emsp;最极端的代码压缩方法，即采用较高的Level2或Level3进行代码优化，然后再选用MicroLIB对代码量再进行压缩一下(最后一步再勾选微库，方便找出微库造成的问题)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍 在Keil平台开发嵌入式遇到的一些东西：MicroLIB、Assert、代码优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="keil" scheme="http://shatang.github.io/tags/keil/"/>
    
      <category term="Assert" scheme="http://shatang.github.io/tags/Assert/"/>
    
      <category term="MicroLIB" scheme="http://shatang.github.io/tags/MicroLIB/"/>
    
      <category term="代码优化" scheme="http://shatang.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>状态机</title>
    <link href="http://shatang.github.io/2020/05/30/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://shatang.github.io/2020/05/30/状态机/</id>
    <published>2020-05-30T03:25:04.000Z</published>
    <updated>2020-05-30T03:28:18.282Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇介绍 搞嵌入式萌新 听别人吹牛的计算机概念——状态机</p><a id="more"></a><h1 id="一、什么是状态机？"><a href="#一、什么是状态机？" class="headerlink" title="一、什么是状态机？"></a>一、什么是状态机？</h1><p>&emsp;&emsp;可能有些编写嵌入式程序的人，听过别人吹他已经用状态机方法写好了代码。听起来逼格贼高，但是实际上，即使你没了解过状态机，但我们在编写嵌入式程序，尤其是驱动编写，都会有意无意以(类似)状态机思想来编写程序，只不过写得时候不知道这个叫状态机。</p><h1 id="二、状态机"><a href="#二、状态机" class="headerlink" title="二、状态机"></a>二、状态机</h1><p>&emsp;&emsp;状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型，一种思想。重复一下：状态机是<strong>有限状态自动机</strong>的简称，是现实事物运行规则抽象而成的一个数学模型。</p><h2 id="2-1-状态机的四大概念"><a href="#2-1-状态机的四大概念" class="headerlink" title="2.1 状态机的四大概念"></a>2.1 状态机的四大概念</h2><ul><li>State ，状态<ul><li>一个状态机至少要包含两个状态。例如bool类型，有 true 和 false 两个状态。</li></ul></li><li>Event ，事件<ul><li>事件就是执行某个操作的触发条件或者口令。不同状态对应产生各自事件。</li></ul></li><li>Action ，动作<ul><li>事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。</li></ul></li><li>Transition ，变换<ul><li>通过多种动作满足一定条件，开始切换状态</li></ul></li></ul><p>&emsp;&emsp;主要概念还是状态，后三者往往在代码实现的时候糅合在一起比较模糊。</p><h2 id="2-2-举例应用"><a href="#2-2-举例应用" class="headerlink" title="2.2 举例应用"></a>2.2 举例应用</h2><p>&emsp;&emsp;状态机，是(快速)写(驱动)程序的好帮手。</p><p>街上的自动售货机中明显能看到状态机逻辑；我们做一下简化，假设这是一台只卖2元一瓶的汽水的售货机，只接受五毛和一块的硬币。</p><ul><li>初始状态是”未付款“，中间状态有”已付款5毛“，”已付款1块“，”已付款1.5块“，”已足额付款“，四个状态。</li><li>状态切换的触发条件是”投一块硬币“和”投5毛硬币“两种。</li><li>到达“已足额付款”状态，还要进行余额清零和弹出汽水操作。然后重新进入初始化状态</li></ul><p>所以如果画出一张完整的状态转换图，也会是比较复杂的一张图了。而实际中的售货机对应的状态机就会更加复杂了。</p><h2 id="2-3-实际代码实现"><a href="#2-3-实际代码实现" class="headerlink" title="2.3 实际代码实现"></a>2.3 实际代码实现</h2><p>&emsp;&emsp;实际从C的代码层面，更容易看到状态机的影子。最经典的就是 <code>switch</code> 和 <code>enum</code> 的搭配了。</p><p><code>switch</code> 罗列出状态机的所有可能状态。<code>enum</code> 产生对应的各种状态。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    DISCONNECT,</span><br><span class="line">    CONNECT,</span><br><span class="line">    RECONNECT,</span><br><span class="line">&#125;_enumGPRSState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(_enumGPRSState GPRSState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(GPRSState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DISCONNECT:<span class="keyword">break</span>;  <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">case</span> CONNECT:<span class="keyword">break</span>;     <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">case</span> RECONNECT:<span class="keyword">break</span>;   <span class="comment">//执行对应的事件、动作</span></span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">//特殊处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就是很常见、很普通的状态机写法，很适用于快速开发底层驱动。当然，这是一个很简单的例子。还有更复杂的状态机，甚至多状态机相互影响切换其他状态机的状态。状态机也只是一种思想而已。</p><p>&emsp;&emsp;可以去看FreeModbus的通讯库。它就是一个很经典的状态机写法，但是涉及到多状态机。它的状态机有：(轮询)事件，串口发送中断，串口接收中断，其中还有个定时器能够变换 串口接收中断 状态机。</p><h2 id="2-4-FreeModbus库讲解-RTU模式为例"><a href="#2-4-FreeModbus库讲解-RTU模式为例" class="headerlink" title="2.4 FreeModbus库讲解(RTU模式为例)"></a>2.4 FreeModbus库讲解(RTU模式为例)</h2><ol><li>Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态</li><li>串口接收中断 在初始化状态下，打开定时器</li><li>等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将<code>eMBPoll</code>的 事件状态机 置为 初始化。</li><li><strong>以上就是初始化完成，接下来就是数据收发的流程了</strong></li><li>串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。</li><li>每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。</li><li>当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态</li><li>由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。</li><li>eMBPoll的 事件状态机 为<code>Frame received</code>接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功</li><li>核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 <code>MB_EIO</code>的错误。</li><li>经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为<code>Execute function</code> 执行数据函数(事件)。开始对数据进行处理。</li><li>这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。</li><li>如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 <code>功能码|0x80 + 错误代码</code>。</li><li>举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。</li><li>在处理完后会返回一个enum状态值。如果状态 不为<code>MB_ENOERR</code>，即内部使用的错误代码，根据内部使用的<code>enum</code>错误代码，<code>switch</code>生成 对外的错误代码</li><li>返回的CRC会在发送前先把CRC校验完成。</li><li>发送前，检查能不能数据接收，能接收则报硬件错误<code>MB_EIO</code>，因为协议规定只能单向收发</li><li>发送一个字节数据，然后开启发送中断，一直发送，直到完成</li><li>发送完成后，将 eMBPoll的 事件状态机 置为 发送完成</li><li>事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲</li></ol><p>&emsp;&emsp;以上就是FreeModbus库实现<code>Modbus RTU</code>通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。写的很好，这份源码还是很推荐看的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇介绍 搞嵌入式萌新 听别人吹牛的计算机概念——状态机&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础概念 &amp; 算法" scheme="http://shatang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机概念" scheme="http://shatang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式IIC总线</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8FIIC%E6%80%BB%E7%BA%BF/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式IIC总线/</id>
    <published>2020-05-30T03:17:49.000Z</published>
    <updated>2020-05-30T03:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇详细介绍嵌入式的IIC总线，方便以后写该总线的器件驱动。</p><a id="more"></a><h1 id="一、IIC总线讲解"><a href="#一、IIC总线讲解" class="headerlink" title="一、IIC总线讲解"></a>一、IIC总线讲解</h1><p>&emsp;&emsp;IIC的硬件管脚为 VCC，GND，SDA，SCL。IIC的主要构成只有两个双向的信号线，一个是数据线SDA,一个是时钟线SCL。IIC总线有主从之分。</p><p>&emsp;&emsp;IIC总线实现的方式分为两种：硬件IIC &amp; 软件模拟IIC。硬件IIC有主从之分；当然，软件I2C也是标准的I2C协议，当然有分主从，但一般情况下，软件IIC为主机模式，即发送请求接收响应信息。为什么要写从机呢？mcu 对 mcu ？)。由于每种MCU的硬件IIC总线配置各不相同，且有些芯片的IIC有Bug(Stm32)，故接下来只讲 软件IIC。</p><ul><li>由于实际应用上，IIC总线通讯速率本身就不高，因此，硬件IIC总线 &amp; 软件IIC总线<br>本身速率方面就没多差大差距，不需要考虑IIC总线切换为软、硬件实现方式会给程序带来隐患。</li><li>无论是 硬件IIC 还是 软件IIC ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应IIC从器件的datasheet。IIC总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。</li></ul><h1 id="二、-软件-IIC总线"><a href="#二、-软件-IIC总线" class="headerlink" title="二、 (软件)IIC总线"></a>二、 (软件)IIC总线</h1><h2 id="2-1-基本知识"><a href="#2-1-基本知识" class="headerlink" title="2.1 基本知识"></a>2.1 基本知识</h2><p>&emsp;&emsp;软件IIC，也能更好让我们了解IIC总线协议的实现方式。</p><img src="/2020/05/30/嵌入式IIC总线/0.png" title="IIC总线"><p>&emsp;&emsp;<strong>I2C总线通过上拉电阻接正电源。即当总线空闲时，两根线均为高电平</strong>。如此，连在总线上的任一器件输出的低电平，都可以使得总线的信号变低，也就是说各器件的SDA和SCL都是线”与”关系。 </p><img src="/2020/05/30/嵌入式IIC总线/1.png" title="数据有效性规定"><p>数据位(1\0)有效性规定：<strong>I2C总线进行数据传送时，时钟信号为高电平期间，SDA线上的数据必须保持稳定</strong>；只有在SCL线的信号为低电平器件，SDA线的才可进行高低电平状态变化。</p><blockquote><p>起始信号、终止信号、应答信号</p></blockquote><img src="/2020/05/30/嵌入式IIC总线/2.png" title="起始信号和终止信号"><ul><li>起始信号：SCL线为高电平期间，SDA线由高电平向低电平跳变(下降沿)—-是一种电平跳变时序信号</li><li>终止信号：SCL线为高电平期间，SDA线由低电平向高电平跳变(上升沿)—-是一种电平跳变的时序信号</li></ul><img src="/2020/05/30/嵌入式IIC总线/3.png" title="应答信号"><ul><li>应答信号：在接收数据的IC(接收器)在接收到8bit数据后，向发送数据的IC(发送器)发出特定的低电平脉冲，表示已收到数据。即发送器在时钟脉冲9期间释放数据线，这样接收器就可以反馈一个应答信号。ACK(低电平)—-规定为有效应答位，NACK(高电平)，规定为非应答位，表示接收器接收该字节咩有成功。</li></ul><h2 id="2-2-软件模拟IIC驱动程序函数编写"><a href="#2-2-软件模拟IIC驱动程序函数编写" class="headerlink" title="2.2 软件模拟IIC驱动程序函数编写"></a>2.2 软件模拟IIC驱动程序函数编写</h2><p>&emsp;&emsp;在IIC程序设计中，都是以8bit为基础进行数据的传输</p><img src="/2020/05/30/嵌入式IIC总线/4.png" title="信号要求"><ul><li>IO管教初始化</li><li>发出起始信号</li><li>发出终止信号</li><li>发出应答ACK<ul><li>功能要求：由于IIC为双向数据通信，当从机发送完数据，主机也需要发送应答信号来说我接收到你的信息了，此时从机才可变为接收状态，接收来自主机的数据。</li></ul></li><li>发出应答NACK<ul><li>功能要求：当IIC程序运行到主机读取从机数据完成，需要停止此次数据传输时，主机发送一个发出主无应答信号，从机接收到后就停止发送数据，并释放SDA线；之后主机才可发送终止信号，停止此次数据的传输。</li></ul></li><li>发送一个字节数据<ul><li>基本思路：SCL在为0时，可以进行SDA数据的配置，当SCL为1时，SDA数据一定要锁定。其次为数据的移位，将待发送数据与0x80进行与运算，获得最高位的数据，通过8次循环完成1byte的数据发送。</li></ul></li><li>读取一个字节，并发送ACK或NACK(发送NACK基通知从机发送器结束数据发送，释放SDA线(SDA接口置1)<ul><li>功能要求：发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号(故读取完需要发送 ACK 或 NACK )</li></ul></li><li>等待ACK应答<ul><li>功能要求：当IIC主机进行获取数值时，主机需要等待从机的应答信号，以此来判断从机是否完成了数据的接收。从主机方看，为IIC等待ASK函数。</li><li>基本思路：通过 延时等待从机的ACK是否发送出来，如果发送出来，则函数返回0，主机可继续发送数据，如果返回1，则从机没有应答，此时需要停止IIC数据传输。防止出现错误数据。</li></ul></li></ul><h2 id="2-3-从具体I2C器件中读写数据"><a href="#2-3-从具体I2C器件中读写数据" class="headerlink" title="2.3 从具体I2C器件中读写数据"></a>2.3 从具体I2C器件中读写数据</h2><blockquote><p><strong>主机写(发送)从机数据</strong></p></blockquote><img src="/2020/05/30/嵌入式IIC总线/5.png" title="主机写从机数据"><blockquote><p><strong>主机读(接收)从机数据</strong></p></blockquote><img src="/2020/05/30/嵌入式IIC总线/6.png" title="主机读从机数据"><p><strong><font color="red">Ps：</font>IIC器件往往是 器件地址+0 为写数据 ，器件地址+1 为读数据</strong></p><p>主机读从机的情况分为两种：</p><ul><li><strong>读操作之前，都是需要进行一次写操作(写入读地址)，表明你要读的是哪个地址的数据，然后在进行一次读操作(故有两个器件地址)；</strong>(这是一般情况)</li><li>直接进行读操作，截取所需数据段</li></ul><p>&emsp;&emsp;因为有些IIC器件(从机)，例如24C02，当你需要读取它的数据，你要跟它说读取哪个地址数据，故先进行写操作；有些IIC器件，例如SD2403，它的时间日期地址是固定的（寄存器地址：00H-06H），因此读取该器件数据时，直接进行读操作，然后读出来7个数据，截取00H-06H的数据后，停止读取(这是特殊情况)</p><blockquote><p>DEVICEADDRESS(器件地址)</p></blockquote><p>&emsp;&emsp;器件地址的8位地址信息因器件而异；</p><h1 id="三、软件IIC实例"><a href="#三、软件IIC实例" class="headerlink" title="三、软件IIC实例"></a>三、软件IIC实例</h1><h2 id="3-1-EEPROM-24C02通信基础——IIC协议"><a href="#3-1-EEPROM-24C02通信基础——IIC协议" class="headerlink" title="3.1 EEPROM_24C02通信基础——IIC协议"></a>3.1 EEPROM_24C02通信基础——IIC协议</h2><p>&emsp;&emsp;24C02是一个可储存 256(8bit)字节数据的EEPROM，因此他的<code>Word Address</code>为8bit(单字节)；而他的器件地址如下：</p><img src="/2020/05/30/嵌入式IIC总线/7.png" title="24C02地址信息"><p>据2.3.1图所示，主机对从机写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_WriteOneByte</span><span class="params">(u16 WriteAddr, u8 DataToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IIC_Starts();<span class="comment">//发出起始信号</span></span><br><span class="line">IIC_Send_Byte(<span class="number">0xA0</span>);<span class="comment">//写器件地址+写操作</span></span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC_Send_Byte(WriteAddr&gt;&gt;8);//发送高地址，适用于更高容量的EEPROM</span></span><br><span class="line"><span class="comment">//IIC_Wait_Ack();</span></span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(WriteAddr%<span class="number">256</span>);<span class="comment">//发送低地址</span></span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line">IIC_Send_Byte(DataToWrite);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line">IIC_Stop();</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//等AT24C02写数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据2.3.1图所示，主机对从机读操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u8 <span class="title">AT24CXX_ReadOneByte</span><span class="params">(u16 ReadAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 temp=<span class="number">0</span>;</span><br><span class="line">IIC_Start();  </span><br><span class="line">IIC_Send_Byte(<span class="number">0XA0</span>);<span class="comment">//发送器件地址0XA0,写操作</span></span><br><span class="line">IIC_Wait_Ack(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC_Send_Byte(ReadAddr/256);//发送高地址，适用于更高容量的EEPROM</span></span><br><span class="line"><span class="comment">//IIC_Wait_Ack();</span></span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(ReadAddr%<span class="number">256</span>);<span class="comment">//发送低地址</span></span><br><span class="line">IIC_Wait_Ack();    </span><br><span class="line">IIC_Start();      </span><br><span class="line">IIC_Send_Byte(<span class="number">0XA1</span>);<span class="comment">//进入接收模式</span></span><br><span class="line">IIC_Wait_Ack(); </span><br><span class="line">temp=IIC_Read_Byte(<span class="number">0</span>);<span class="comment">//读一个字节数据完成，并发出No_Ack(输入参数：0)</span></span><br><span class="line">IIC_Stop();    </span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-24C02程序拓展——datasheet"><a href="#3-2-24C02程序拓展——datasheet" class="headerlink" title="3.2 24C02程序拓展——datasheet"></a>3.2 24C02程序拓展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始写入长度为Len的数据</span></span><br><span class="line"><span class="comment">//该函数用于写入16bit或者32bit的数据.</span></span><br><span class="line"><span class="comment">//WriteAddr  :开始写入的地址  </span></span><br><span class="line"><span class="comment">//DataToWrite:数据数组首地址</span></span><br><span class="line"><span class="comment">//Len        :要写入数据的长度2,4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_WriteLenByte</span><span class="params">(u16 WriteAddr,u32 DataToWrite,u8 Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 t;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;Len;t++)</span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite&gt;&gt;(<span class="number">8</span>*t))&amp;<span class="number">0xff</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始读出长度为Len的数据</span></span><br><span class="line"><span class="comment">//该函数用于读出16bit或者32bit的数据.</span></span><br><span class="line"><span class="comment">//ReadAddr   :开始读出的地址 </span></span><br><span class="line"><span class="comment">//返回值     :数据</span></span><br><span class="line"><span class="comment">//Len        :要读出数据的长度2,4</span></span><br><span class="line"><span class="function">u32 <span class="title">AT24CXX_ReadLenByte</span><span class="params">(u16 ReadAddr,u8 Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">u8 t;</span><br><span class="line">u32 temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;Len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp&lt;&lt;=<span class="number">8</span>;</span><br><span class="line">temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t<span class="number">-1</span>);     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查AT24CXX是否正常</span></span><br><span class="line"><span class="comment">//这里用了24XX的最后一个地址(255)来存储标志字.</span></span><br><span class="line"><span class="comment">//如果用其他24C系列,这个地址要修改</span></span><br><span class="line"><span class="comment">//返回1:检测失败</span></span><br><span class="line"><span class="comment">//返回0:检测成功</span></span><br><span class="line"><span class="function">u8 <span class="title">AT24CXX_Check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 temp;</span><br><span class="line">temp=AT24CXX_ReadOneByte(<span class="number">255</span>);<span class="comment">//避免每次开机都写AT24CXX   </span></span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0X55</span>)<span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line"><span class="keyword">else</span><span class="comment">//排除第一次初始化的情况</span></span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(<span class="number">255</span>,<span class="number">0X55</span>);</span><br><span class="line">    temp=AT24CXX_ReadOneByte(<span class="number">255</span>);  </span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0X55</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始读出指定个数的数据</span></span><br><span class="line"><span class="comment">//ReadAddr :开始读出的地址 对24c02为0~255</span></span><br><span class="line"><span class="comment">//pBuffer  :数据数组首地址</span></span><br><span class="line"><span class="comment">//NumToRead:要读出数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_Read</span><span class="params">(u16 ReadAddr,u8 *pBuffer,u16 NumToRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(NumToRead)</span><br><span class="line">&#123;</span><br><span class="line">*pBuffer++=AT24CXX_ReadOneByte(ReadAddr++);</span><br><span class="line">NumToRead--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//在AT24CXX里面的指定地址开始写入指定个数的数据</span></span><br><span class="line"><span class="comment">//WriteAddr :开始写入的地址 对24c02为0~255</span></span><br><span class="line"><span class="comment">//pBuffer   :数据数组首地址</span></span><br><span class="line"><span class="comment">//NumToWrite:要写入数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AT24CXX_Write</span><span class="params">(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(NumToWrite--)</span><br><span class="line">&#123;</span><br><span class="line">AT24CXX_WriteOneByte(WriteAddr,*pBuffer);</span><br><span class="line">WriteAddr++;</span><br><span class="line">pBuffer++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-实时时钟-SD2403——IIC总线"><a href="#3-3-实时时钟-SD2403——IIC总线" class="headerlink" title="3.3 实时时钟_SD2403——IIC总线"></a>3.3 实时时钟_SD2403——IIC总线</h2><p>&emsp;&emsp;SD2403是一个实时时钟，他的<code>Word Address</code>为8bit(单字节)；而他的器件地址如下：</p><img src="/2020/05/30/嵌入式IIC总线/8.png" title="SD2403地址信息"><p>据2.3图所示，主机对从机写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteOneByte</span><span class="params">(<span class="keyword">uint8_t</span> addr,<span class="keyword">uint8_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!SD2403_start())<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">SD2403_SendByte(<span class="number">0x64</span>);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_SendByte(addr);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_SendByte(data);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据2.3图所示，主机对从机读操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> SD2403_ReakOneByte(<span class="keyword">uint8_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint8_t</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//先写入要读取的寄存器</span></span><br><span class="line"><span class="keyword">if</span>(!SD2403_start()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">SD2403_SendByte(<span class="number">0x64</span>);  </span><br><span class="line"><span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">&#123;</span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SD2403_SendByte(addr); </span><br><span class="line">SD2403_WaitAck();</span><br><span class="line"></span><br><span class="line"><span class="comment">//再读取的寄存器数据</span></span><br><span class="line">SD2403_start();</span><br><span class="line">SD2403_SendByte(<span class="number">0x65</span>);</span><br><span class="line">SD2403_WaitAck();</span><br><span class="line">res=SD2403_ReceiveByte(<span class="number">0</span>); </span><br><span class="line">SD2403_stop();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-SD2403程序拓展——datasheet"><a href="#3-4-SD2403程序拓展——datasheet" class="headerlink" title="3.4 SD2403程序拓展——datasheet"></a>3.4 SD2403程序拓展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> SD2403_ReadTimeDate(_strTimeDate *pstrTimeDate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i,dat[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_start()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    SD2403_SendByte(<span class="number">0x65</span>);</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">    &#123;</span><br><span class="line">        SD2403_stop();</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dat[i]=SD2403_ReceiveByte();</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">            dat[<span class="number">2</span>]=BCDTODEC(dat[<span class="number">2</span>]&amp;<span class="number">0x7F</span>);<span class="comment">//24小时舍弃最高位(区分12/24小时制)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dat[i]=BCDTODEC(dat[i]);</span><br><span class="line">        *(&amp;pstrTimeDate-&gt;ucSec +i)=dat[i];</span><br><span class="line">        <span class="keyword">if</span> (i!=<span class="number">6</span>)         <span class="comment">//最后一个数据不应答</span></span><br><span class="line">        &#123;</span><br><span class="line">            SD2403_ACK();<span class="comment">////ACK 低</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_No_ACK();<span class="comment">//ACK 高结束</span></span><br><span class="line">    SD2403_stop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint8_t</span> SD2403_WriteTimeDate(<span class="keyword">uint8_t</span> *pstrTimeDate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *set_time,i;</span><br><span class="line">    set_time=pstrTimeDate;</span><br><span class="line">    SD2403_WriteTimeOn();</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_start())<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    SD2403_SendByte(<span class="number">0x64</span>);</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WaitAck())</span><br><span class="line">    &#123;</span><br><span class="line">        SD2403_stop();</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_SendByte(<span class="number">0x00</span>);<span class="comment">//设置写起始地址</span></span><br><span class="line">    SD2403_WaitAck();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">            SD2403_SendByte(<span class="number">0x80</span>|DECTOBCD(*set_time));<span class="comment">//最高位区分12/24小时制(1为24小时制)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SD2403_SendByte(DECTOBCD(*set_time));</span><br><span class="line">        SD2403_WaitAck();</span><br><span class="line">        set_time++;</span><br><span class="line">    &#125;</span><br><span class="line">    SD2403_stop();</span><br><span class="line">    SD2403_WriteTimeOff();</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******写SD2403允许程序******/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteTimeOn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WriteOneByte(<span class="number">0x10</span>,<span class="number">0x80</span>))<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">    SD2403_WriteOneByte(<span class="number">0x0f</span>,<span class="number">0x84</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******写SD2403禁止程序******/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">SD2403_WriteTimeOff</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!SD2403_WriteOneByte(<span class="number">0x0f</span>,<span class="number">0</span>))<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">      SD2403_WriteOneByte(<span class="number">0x10</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、拓展——软件IIC从机"><a href="#四、拓展——软件IIC从机" class="headerlink" title="四、拓展——软件IIC从机"></a>四、拓展——软件IIC从机</h1><p>&emsp;&emsp;要实现IIC从机功能，最核心的部分就是如何精确的抓住IIC_SCL，也就是IIC主机发出来的时钟信号。只有抓住精确的时钟SCL，才能正确的读取到SDA的数据，才能真正模拟出IIC时序。</p><p>&emsp;&emsp;但是要抓住SCL信号可不容易，IIC最高速度有400K，最小有效脉宽达到1.4us(数字0/1)，最小脉冲是0.8us(应答和STOP信号产生的尖刺)，采用中断来识别SCL是不可能的做到的，因为即使在最高主频72MHZ情况下，STM32最小指令周期是1/72(us)，从SCL中断发生到STM32进入中断响应，至少要要40个指令周期，也就是40/72(us)，加上堆栈操作及变量，很可能已经错过了SCL信号。</p><p>因此根据IIC主机的速度，从机实现方法分为两种：</p><ol><li>采用中断方式识别SCL(适用于总线速度较慢)</li><li>采用查询方式识别SCL(适用于总线速度较快)</li></ol><p>&emsp;&emsp;反过来言之，当你做成一个(从机)模块，实现软件模拟IIC，实际上还会因为IIC主机的因素来决定你这个模块的实际使用效果。如果是做模块化，还是推荐使用硬件IIC的方式实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇详细介绍嵌入式的IIC总线，方便以后写该总线的器件驱动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
      <category term="IIC" scheme="http://shatang.github.io/tags/IIC/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式SPI总线</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8FSPI%E6%80%BB%E7%BA%BF/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式SPI总线/</id>
    <published>2020-05-30T03:14:26.000Z</published>
    <updated>2020-05-30T03:23:10.444Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇详细介绍嵌入式的SPI总线，方便以后写该总线的器件驱动。</p><a id="more"></a><h1 id="一、SPI总线讲解"><a href="#一、SPI总线讲解" class="headerlink" title="一、SPI总线讲解"></a>一、SPI总线讲解</h1><p>&emsp;&emsp;SPI的主要构成有三根线，一个是数据输出线MOSI,一个是数据输入线MISO，一个是时钟线SCLK。</p><p>&emsp;&emsp;SPI总线实现的方式分为两种：硬件IIC &amp; 软件模拟SPI。硬件SPI有主从之分；当然，软件SPI也是标准的SPI协议，当然有分主从，但一般情况下，(MCU)软件SPI为主机模式，即发送请求接收从机的响应信息。</p><p>&emsp;&emsp;可能大家不知道为什么我这MCU就是SPI主机，凭啥？你可以反过来想一下，MCU通讯的其他器件实质上都是从机，MCU要你的数据才会去找你；如果你MCU也是从机模式，从机与从机怎么通信？由于每种MCU的硬件SPI总线配置各不相同，故接下来主要讲 软件SPI。</p><ul><li>SPI通信是串行同步全双工(同时收发)</li><li>IIC通信是串行同步半双工(单收或单发)</li><li>无论是 硬件SPI 还是 软件SPI ，两种方式只是提供最基础的桥梁——提供了读、写1字节方式。如何调用IIC从器件，还是得查对应SPI从器件的datasheet。SPI总线好比中文的拼音，具体要怎么说话、说什么话，还是得看datasheet。</li></ul><p><strong><font color="red">Ps：</font>硬件SPI总线 &amp; 软件SPI总线 速率方面是有点差距的。具体没有实测，但是既然是用了软件SPI总线，就不要纠结速度问题了。但是硬件SPI总线的速度也不是无上限的，而且还要根据主、从机的配置。</strong></p><hr><p>&emsp;&emsp;以W5500为例，该芯片的SPI总线速率最高达到80Mhz。如果主控采用stm32f103,主频为72Mhz，SPI时钟最大为18Mhz。因此stm32f103无法发挥W5500完全的性能。</p><p>&emsp;&emsp;而如果使用STM40x处理器，SPI时钟使用42Mhz，使用DMA方式，可以达到回环测试17Mbps的速率（收+发），单独发送可以达到13Mbps的速率。</p><p>&emsp;&emsp;也就是说，SPI的速率本身就受器件限制。如果从机SPI时钟较低，主机被限制；主机时钟较低，从机性能被限制。编写硬件SPI驱动的时候，要多注意 主控芯片、从机器件 的datasheet。</p><h1 id="二、-主机-软件SPI总线"><a href="#二、-主机-软件SPI总线" class="headerlink" title="二、(主机)软件SPI总线"></a>二、(主机)软件SPI总线</h1><p>&emsp;&emsp;硬件上为4根线：</p><ul><li><code>MISO</code> ：主设备数据输入，从设备数据输出。</li><li><code>MOSI</code> ：主设备数据输出，从设备数据输入。</li><li><code>SCLK</code> ：时钟信号，由主设备产生。</li><li><code>CS</code> ：从设备片选信号，由主设备控制。</li></ul><p><strong><font color="red">Ps：</font>外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。</strong></p><img src="/2020/05/30/嵌入式SPI总线/1.png" title="硬件SPI时钟信号的相位和极性"><p>&emsp;&emsp;由上图的(硬件)SPI通信协议可知，时钟信号的相位和极性，决定了获取数据的方式；2*2=4，于是有四种模式；</p><img src="/2020/05/30/嵌入式SPI总线/2.png" title="SPI通信模式"><p>CPOL决定时钟空闲状态(1为空闲高电平，0为空闲低电平)</p><img src="/2020/05/30/嵌入式SPI总线/3.png" title="SPI通信模式"><p>CPHA决定获取数据的时钟相位(1为延迟一个相位，第二次SCLK突变为空闲状态获取数据；0为直接相位，SCLK空闲状态突变时，直接获取数据)</p><img src="/2020/05/30/嵌入式SPI总线/4.png" title="SPI通信模式总结"><p>&emsp;&emsp;以上就是软件SPI的要点；实现具体的软件SPI，需要对器件的datasheet进行查阅，看是哪种模式。</p><table><thead><tr><th>模式</th><th>CPOL</th><th>CPHA</th></tr></thead><tbody><tr><td>MODE0</td><td>0</td><td>0</td></tr><tr><td>MODE1</td><td>0</td><td>1</td></tr><tr><td>MODE2</td><td>1</td><td>0</td></tr><tr><td>MODE3</td><td>1</td><td>1</td></tr></tbody></table><p>下面简单列一个 CPOL=1，CPHA=1的SPI写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">函数：SOFT_SPI_RW() </span></span><br><span class="line"><span class="comment">描述: 根据SPI协议，写一字节数据到从机，同时从从机 读出一字节</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function">u8 <span class="title">SOFT_SPI_RW</span><span class="params">(u8 byte)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">u8 i,Temp=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">// 循环8次 </span></span><br><span class="line">&#123; </span><br><span class="line">SPI1_SCK = <span class="number">0</span><span class="comment">//拉低时钟</span></span><br><span class="line"><span class="keyword">if</span>(byte&amp;<span class="number">0x80</span>)</span><br><span class="line">SPI1_MOSI = <span class="number">1</span>;<span class="comment">//若最到位为高，则输出高</span></span><br><span class="line"> <span class="keyword">else</span>       </span><br><span class="line">SPI1_MOSI = <span class="number">0</span>;<span class="comment">//若最到位为低，则输出低 </span></span><br><span class="line">byte &lt;&lt;= <span class="number">1</span>;<span class="comment">//低一位移位到最高位 </span></span><br><span class="line">SPI1_SCK = <span class="number">1</span>;<span class="comment">//拉高时钟</span></span><br><span class="line">Temp &lt;&lt;= <span class="number">1</span>;<span class="comment">//数据左移 </span></span><br><span class="line"><span class="keyword">if</span>(SPI1_MISO) </span><br><span class="line">Temp++;<span class="comment">//若从从机接收到高电平，数据自加一</span></span><br><span class="line"> SPI1_SCK = <span class="number">0</span>;<span class="comment">//拉低时钟</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (Temp);<span class="comment">//返回数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-FRAM-FM25L256为例——软件SPI"><a href="#2-1-FRAM-FM25L256为例——软件SPI" class="headerlink" title="2.1 FRAM_FM25L256为例——软件SPI"></a>2.1 FRAM_FM25L256为例——软件SPI</h2><p>&emsp;&emsp;FM25L256支持SPI模式的0和3，下面为CPOL=1，CPHA=1。基本的字节读写操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write8bits</span></span><br><span class="line"><span class="comment">* 功  能 :  向存储器中写入一个字节</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write8bits</span><span class="params">(<span class="keyword">uint8_t</span> u8Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u8Data &amp; <span class="number">0x80</span>)         </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>          </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u8Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Read8bits</span></span><br><span class="line"><span class="comment">* 功  能 :  从存储器中读出一个字节的数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">FRAM_Read8bits</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">uint8_t</span> u8Data=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        u8Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        <span class="keyword">if</span>(FRAM_SDO_READ)</span><br><span class="line">            u8Data |= <span class="number">0x01</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    <span class="keyword">return</span>  u8Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-FRAM-FM25L256程序扩展——datasheet"><a href="#2-2-FRAM-FM25L256程序扩展——datasheet" class="headerlink" title="2.2 FRAM_FM25L256程序扩展——datasheet"></a>2.2 FRAM_FM25L256程序扩展——datasheet</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write16bits</span></span><br><span class="line"><span class="comment">* 功  能 :  发送16位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write16bits</span><span class="params">(<span class="keyword">uint16_t</span> u16Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u16Data &amp; <span class="number">0x8000</span>) </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>                 </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u16Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write32bits</span></span><br><span class="line"><span class="comment">* 返  回 :  写入的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FRAM_Write32bits</span><span class="params">(<span class="keyword">uint32_t</span> u32Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        <span class="keyword">if</span>(u32Data &amp; <span class="number">0x80000000</span>) </span><br><span class="line">            FRAM_SDI_H;</span><br><span class="line">        <span class="keyword">else</span>              </span><br><span class="line">            FRAM_SDI_L;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">        FRAM_SCLK_H;</span><br><span class="line">        u32Data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        DelayTime(SPI_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Read4Bytes</span></span><br><span class="line"><span class="comment">* 功  能 :  读取指定地址的4字节数据</span></span><br><span class="line"><span class="comment">* 入  参 :  address  : 读取数据的首地址</span></span><br><span class="line"><span class="comment">* 返  回 :  uint32_t : 读出的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="keyword">uint32_t</span> FRAM_Read4Bytes(<span class="keyword">uint32_t</span> address)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_READ);</span><br><span class="line">    FRAM_Write16bits((<span class="keyword">uint16_t</span>)(address));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp  = temp &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        temp |= FRAM_Read8bits();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************** </span></span><br><span class="line"><span class="comment">* 函数名 :  FRAM_Write4Bytes</span></span><br><span class="line"><span class="comment">* 功  能 :  写入指定地址的4字节数据</span></span><br><span class="line"><span class="comment">* 入  参 :  address  : 写入数据的首地址</span></span><br><span class="line"><span class="comment">*           FramData : 写入的32位数据</span></span><br><span class="line"><span class="comment">**************************************************/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FRAM_Write4Bytes</span><span class="params">(<span class="keyword">uint32_t</span> address, <span class="keyword">uint32_t</span> FramData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> u8Temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_WREN);</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_L;</span><br><span class="line">    FRAM_Write8bits(FRAM_CMD_WRITE);</span><br><span class="line">    FRAM_Write16bits((<span class="keyword">uint16_t</span>)(address));</span><br><span class="line">    FRAM_Write32bits(FramData);</span><br><span class="line">    FRAM_SCLK_L;</span><br><span class="line">    FRAM_CS_H;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        FRAM_CS_L;</span><br><span class="line">        FRAM_Write8bits(FRAM_CMD_RDSR);<span class="comment">//读取状态寄存器</span></span><br><span class="line">        u8Temp = FRAM_Read8bits();</span><br><span class="line">        FRAM_SCLK_L;</span><br><span class="line">        FRAM_CS_H;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该位表示写入启用状态(为0时，WPEN和 /WP 寄存器标志位不起作用)</span></span><br><span class="line"><span class="comment">//防止软件误改动铁电芯片寄存器配置</span></span><br><span class="line">        <span class="keyword">if</span>(!(u8Temp &amp; <span class="number">0x02</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇详细介绍嵌入式的SPI总线，方便以后写该总线的器件驱动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="SPI" scheme="http://shatang.github.io/tags/SPI/"/>
    
      <category term="嵌入式总线" scheme="http://shatang.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式存储器</title>
    <link href="http://shatang.github.io/2020/05/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://shatang.github.io/2020/05/30/嵌入式存储器/</id>
    <published>2020-05-30T03:09:32.000Z</published>
    <updated>2020-05-30T03:10:36.111Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备的存储器科普。</p><a id="more"></a><h1 id="一、存储器科普"><a href="#一、存储器科普" class="headerlink" title="一、存储器科普"></a>一、存储器科普</h1><p>&emsp;&emsp;<code>RAM</code>、<code>SRAM</code>、<code>SDRAM</code>、<code>ROM</code>、<code>EPROM</code>、<code>EEPROM</code>、<code>Flash</code>存储器可以分为很多种类;其中根据掉电数据是否丢失可以分为RAM（随机存取存储器）和ROM（只读存储器），其中RAM的访问速度比较快，但掉电后数据会丢失，而ROM掉电后数据不会丢失。</p><h2 id="1-1-常见存储器"><a href="#1-1-常见存储器" class="headerlink" title="1.1 常见存储器"></a>1.1 常见存储器</h2><p>&emsp;&emsp;在嵌入式开发过程中，往往会涉及到存储器(掉电存储等功能)；其中的 <strong>Flash</strong>，<strong>EEPROM</strong>，<strong>SRAM</strong>耳熟能详。 </p><ol><li><strong>Flash，适用于速度要求高，容量要求大，掉电时要求数据不丢失的场合</strong></li><li><strong>EEPROM，适用于速度不高，容量不大，掉电时要求数据不丢失的场合</strong></li><li><strong>SRAM，一般就相当于计算机的内存，断电不保存，读写速度比flash, eeprom快N倍</strong></li></ol><p>&emsp;&emsp;在单片机中，往往RAM主要是做运行时数据存储器,FLASH主要是程序存储器,EEPROM主要是用以在程序运行保存一些需要掉电不丢失的数据。</p><ul><li>FLASH:单片机运行的程序存储的地方</li><li>SRAM：存储单片机运行过程中产生的了临时数据</li><li>EEPROM：视用户的需要而定，一般用来存储系统的一些参数，这些参数可能需要修改，也可能不会修改。</li></ul><h2 id="1-2-EEPPROM-和-Flash-混淆来由"><a href="#1-2-EEPPROM-和-Flash-混淆来由" class="headerlink" title="1.2 EEPPROM 和 Flash 混淆来由"></a>1.2 EEPPROM 和 Flash 混淆来由</h2><p>&emsp;&emsp;EEPROM的全称是“电可擦除可编程只读存储器”，即Electrically Erasable Programmable Read-Only Memory。是相对于紫外擦除的rom来讲的。但是今天已经存在多种EEPROM的变种，变成了一类存储器的统称。</p><p><strong>狭义的EEPROM</strong>：这种rom的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。这是最传统的一种EEPROM，掉电后数据不丢失，可以保存100年，可以擦写100w次。具有较高的可靠性，但是电路复杂/成本也高。因此目前的EEPROM都是几十千字节到几百千字节的，绝少有超过512K的。</p><p><strong>Flash</strong>：属于广义的EEPROM，因为它也是电擦除的ROM。但是为了区别于一般的按字节为单位的擦写的EEPROM，我们都叫它Flash。</p><p>&emsp;&emsp;<strong>FLASH按扇区操作，EEPROM则按字节操作</strong>；二者寻址方法不同，存储单元的结构也不同，FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因而适合用作程序存储器，EEPROM则更多的用作非易失的数据存储器。当然用FLASH做数据存储器也行，但操作比EEPROM麻烦的多；所以更“人性化”(成本)的MCU设计会集成FLASH和EEPROM两种非易失性存储器，而廉价型设计往往只有 FLASH，早期可电擦写型MCU则都是EEPRoM结构，现在已基本上停产了。</p><p>&emsp;&emsp;EEPROM：电可擦除可编程只读存储器，Flash的操作特性完全符合EEPROM的定义，属EEPROM无疑，首款Flash推出时其数据手册上也清楚的标明是EEPROM，现在的多数Flash手册上也是这么标明的，<strong>二者的关系是“白马”和“马”</strong>。至于为什么业界要区分二者，主要的原因是 Flash EEPROM的操作方法和传统EEPROM截然不同，次要的原因是为了语言的简练，非正式文件和口语中Flash EEPROM就简称为Flash，这里要强调的是白马的“白”属性而非其“马”属性以区别Flash和传统EEPROM。</p><p>&emsp;&emsp;Flash的特点是结构简单，同样工艺和同样晶元面积下可以得到更高容量且大数据量下的操作速度更快，但<strong>Flash缺点是操作过程麻烦，特别是在小数据量反复重写时</strong>，所以<strong>在MCU中的Flash结构适于不需频繁改写的程序存储器</strong>。</p><p>&emsp;&emsp;很多应用中，<strong>需要频繁的改写某些小量数据且需掉电非易失，传统结构的EEPROM在此非常适合</strong>。所以很多MCU内部设计了两种EEPROM结构，FLASH的和传统的以期获得成本和功能的均衡，这极大的方便了使用者。随着ISP、IAP的流行，特别是在程序存储地址空间和数据存储地址空间重叠的MCU系中，现在越来越多的MCU生产商用支持IAP的程序存储器来模拟EEPROM对应的数据存储器，这是低成本下实现非易失数据存储器的一种变通方法。为在商业宣传上取得和双EEPROM工艺的“等效”性，不少采用Flash程序存储器“模拟”（注意，技术概念上并非真正的模拟）EEPROM数据存储器的厂家纷纷宣称其产品是带EEPROM的，严格说，这是非常不严谨的，但商人有商人的目的和方法，<strong>用Flash“模拟”EEPROM</strong>可以获取更大商业利益，所以在事实上，技术概念混淆的始作俑者正是他们。</p><h2 id="1-3-Flash的粗分"><a href="#1-3-Flash的粗分" class="headerlink" title="1.3 Flash的粗分"></a>1.3 Flash的粗分</h2><p>&emsp;&emsp;目前Flash主要有两种，NOR Flash和NADN Flash。</p><ul><li><strong>NOR Flash</strong>：NOR Flash的读取和我们常见的SDRAM的读取是一样，用户可以直接运行装载在NOR FLASH里面的代码，这样可以减少SRAM的容量从而节约了成本。</li><li><strong>NAND Flash</strong>：NAND Flash没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价。</li></ul><p><strong>Ps ：用户不能直接运行NAND Flash上的代码，因此很多使用NAND Flash的开发板除了使用NAND Flash以外，还作上了一块小的NOR Flash来运行启动代码</strong></p><p>&emsp;&emsp;一般小容量的用NOR Flash，因为其读取速度快，多用来存储操作系统等重要信息，而大容量的用NAND FLASH，最常见的NAND FLASH应用是嵌入式系统采用的DOC（Disk On Chip）和我们通常用的“闪盘”，可以在线擦除。目前市面上的FLASH 主要来自Intel，AMD，Fujitsu和Toshiba，而生产NAND Flash的主要厂家有Samsung和Toshib</p><h1 id="二、Flash的前世今生"><a href="#二、Flash的前世今生" class="headerlink" title="二、Flash的前世今生"></a>二、Flash的前世今生</h1><h2 id="2-1-Flash起源"><a href="#2-1-Flash起源" class="headerlink" title="2.1 Flash起源"></a>2.1 Flash起源</h2><p>&emsp;&emsp;Nand Flash 和 Nor Flash<br>是现在市场上两种主要的非易失闪存技术。Intel于1988年首先开发出NOR Flash 技术，彻底改变了原先由EPROM（Electrically Programmable Read-Only-Memory电可编程序只读存储器）和EEPROM（电可擦只读存储器Electrically Erasable Programmable Read - Only Memory）一统天下的局面。紧接着，1989年，东芝公司发表了NAND Flash 结构，强调降低每比特的成本，有更高的性能，并且像磁盘一样可以通过接口轻松升级。NOR Flash 的特点是芯片内执行（XIP ，eXecute In Place），这样应用程序可以直接在Flash闪存内运行，不必再把代码读到系统RAM。</p><hr><p><strong><font color="red">注：</font></strong><br>片内执行不是说程序在存储器内执行，CPU的基本功能就是取指、译码和执行。<strong>Nor Flash能在芯片内执行，就是指CPU的取指模块能够直接从NorFlash中把指令取出来，供后面的译码和执行模块使用。</strong></p><h2 id="2-2-Flash的差异"><a href="#2-2-Flash的差异" class="headerlink" title="2.2 Flash的差异"></a>2.2 Flash的差异</h2><p>&emsp;&emsp;由于Nor Flash的接口与RAM完全相同，可以随机访问任意地址的数据。因此，Nor Flash进行读操作的效率非常高，但是擦除和写操作的效率很低，另外，Nor Flash的容量一般比较小。</p><p>&emsp;&emsp;而NAND Flash的接口仅仅包含几个I/O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得Nor Flash适合于运行程序，而NAND Flash更适合于存储数据。</p><p>&emsp;&emsp;容量相同的情况下，NAND Flash的体积更小。市场上Nor Flash的容量通常为1MB<del>4MB(也有32MB的Nor Flash)，NAND Flash的容量为8MB</del>512MB。对于空间有严格要求的系统，NAND Flash可以节省更多空间。<strong>容量的差别也使得Nor Flash多用于存储程序，NAND Flash多用于存储数据。</strong></p><p>&emsp;&emsp;对于Flash存储器件的可靠性需要考虑3点：<strong>位反转、坏块和可擦除次数</strong>。所有Flash器件都遭遇位反转的问题：由于Flash固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误（这种概率很低），而NAND Flash出现的概率远大于Nor Flash，当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。当仅仅是报告位反转，重新读取即可：如果确实发生了位反转，则必须有相应的错误检测/恢复措施。在NAND Flash上发生位反转的概率史高，推荐使用EDC/ECC进行错误检测和恢复。NAND Flash上面会有坏块随机分布在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。</p><p>&emsp;&emsp;NAND Flash每块的可擦除次数通常在100000次左右，是Nor Flash的10倍。另外，因为NAND Flash的块大小通常是Nor Flash的1/8，单块的擦除需求更少，所以NAND Flash的寿命远远超过Nor Flash。</p><table><thead><tr><th align="center">-</th><th align="center">Nor</th><th align="center">NAND</th></tr></thead><tbody><tr><td align="center">XIP(代码可以直接运行)</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">性能(擦除)</td><td align="center">块大，非常慢(5s)</td><td align="center">块小，快(3ms)</td></tr><tr><td align="center">性能(写)</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">性能(读)</td><td align="center">快</td><td align="center">快</td></tr><tr><td align="center">可靠性</td><td align="center">较高，位反转的比例小于NAND Flash的10%</td><td align="center">比较低，位反转比较常见，必须有校验措施。且比如TNR必须有坏块管理措施</td></tr><tr><td align="center">可擦除次数</td><td align="center">10000 ~ 100000</td><td align="center">100000 ~ 1000000</td></tr><tr><td align="center">生命周期</td><td align="center">低于NAND Flash的10%</td><td align="center">是Nor Flash的10倍以上</td></tr><tr><td align="center">接口</td><td align="center">与RAM接口相同</td><td align="center">I/O接口</td></tr><tr><td align="center">易用性</td><td align="center">容易</td><td align="center">复杂</td></tr><tr><td align="center">主要用途</td><td align="center">常用于保存代码和关键数</td><td align="center">用于保存数据</td></tr><tr><td align="center">价格</td><td align="center">高</td><td align="center">低</td></tr></tbody></table><h1 id="三、-Nand-Flash"><a href="#三、-Nand-Flash" class="headerlink" title="三、 Nand Flash"></a>三、 Nand Flash</h1><p>&emsp;&emsp;由于Nand Flash的可靠性(位反转、坏块)，在比较低端的嵌入式设备并不采用Nand Flash，其容量大、擦写次数多在低端嵌入式设备中体现不出优势。Nand Flash会被采用于 嵌入式Linux设备，常见于使用NAND Flash的开发板除了使用NAND Flash以外，还作上了一块小的NOR Flash来运行启动代码。在linux上很多现成、高级的驱动，因此这里就不多讲Nand Flash。</p><p>&emsp;&emsp;我们写Nand Flash驱动，是写Nand Flash 控制器的驱动，而不是Nand Flash 芯片的驱动，因为独立的Nand Flash芯片，一般来说，是很少直接拿来用的，多数都是硬件上有对应的硬件的Nand Flash的控制器，去操作和控制Nand Flash，包括提供时钟信号，提供硬件ECC校验等等功能，我们所写的驱动软件，是去操作Nand Flash的控制器，然后由控制器去操作Nand Flash芯片，实现我们所要的功能。</p><h1 id="四、Nor-Flash"><a href="#四、Nor-Flash" class="headerlink" title="四、Nor Flash"></a>四、Nor Flash</h1><p>&emsp;&emsp;Nand Flash需要高级(算法处理)驱动，对低端嵌入式设备是一种考验。由于低端嵌入式设备往往对数据量要求不大，且对可靠性要求较高，往往采用Nor Flash。常见的用法是用于存储设备的历史记录，常见芯片有W25Qx系列的Nor Flash。</p><h2 id="4-1-Flash的擦除"><a href="#4-1-Flash的擦除" class="headerlink" title="4.1 Flash的擦除"></a>4.1 Flash的擦除</h2><p>&emsp;&emsp;像EEPROM等其他储存芯片是没有擦除这一说的。例如，iic接口的AT24Cx芯片，想要写入的数据直接覆盖在对应地址的数据上。</p><p>&emsp;&emsp;Nor Flash的物理特性是，写入之前需要先进行擦除。<strong>擦除从0变1，写入从1变0</strong>。<br>擦除后数据为全0xFF，此时写入操作，实际上是将数据从1改成0。</p><p>&emsp;&emsp;一般先擦后写(常见于W25Qx驱动)，但实际上擦除后每个位置是可以写入多次的，只要每次写入都是让某些bit从1变0即可。</p><p>&emsp;&emsp;例如，在擦除后数据为0xFF，此时写入0x0F，可读出0x0F，再写入0x01，可读出0x01，再写入0x00，可读出0x00。而对于0x00，就无法再改写成任何值了，因为此时每个bit都是0，想要改写就必须先擦除，让其恢复到0xFF，再进行写入改成目标值。</p><h2 id="4-2-“块，扇，页”的区别"><a href="#4-2-“块，扇，页”的区别" class="headerlink" title="4.2 “块，扇，页”的区别"></a>4.2 “块，扇，页”的区别</h2><p>&emsp;&emsp;从上面的擦除概念，引申出(硬件)磁盘的最小擦除单位(Sector)。这里的单位概念有：<strong>块(Block)，扇(Sector)，页</strong>。</p><ul><li>从底层驱动层面上看，Sector是最小存储单位(而且从驱动层面看并没有block的概念)</li><li>从软件(OS、文件系统)层面上看，Block才是文件存取的最小单位</li></ul><hr><p>&emsp;&emsp;OS、文件系统不是一个扇区一个扇区的来读数据，太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，Block才是文件存取的最小单位)。</p><ul><li>Block由一个或多个Sector组成；</li><li>Block是软件(OS、文件系统)中最小的操作单位</li><li>Sector是 底层驱动的最小操作单位(擦写)</li><li>Block值一般与sector值是不相等的</li></ul><hr><p>&emsp;&emsp;因此，在其他地方看到块为最小单位、扇为最小单位时，就可以知道他是以什么层面来看待存储的。</p><ul><li>Block是文件系统上的概念，一般文件系统block大小为4K(可以灵活设置块的大小)</li><li>Sector是磁介质硬盘最小单元，一般为512字节(现在有4K的了)</li><li>至于页，是为了驱动方便擦写、检测扇内部的写入情况，提出来的一个概念；实际上并没有多大关系。如果进行擦除，还是会以Sector做为最小单位进行擦除操作</li></ul><h2 id="4-3-坏块-amp-写平衡"><a href="#4-3-坏块-amp-写平衡" class="headerlink" title="4.3 坏块 &amp; 写平衡"></a>4.3 坏块 &amp; 写平衡</h2><p>&emsp;&emsp;这里先讲 坏块 这个概念。由于刚接触Flash底层的人，然后又经常听谁谁谁的移动硬盘坏块很多，或者是建议买硬盘后先做个坏块检测之类的事情。</p><blockquote><p>真正意义的 “坏块”</p></blockquote><p>&emsp;&emsp;闪存内的坏块处理，是指生产出的闪存并不是完美的，总会有某些比特或者某些区域不可使用，这时候就要对闪存进行坏块处理。</p><p>&emsp;&emsp;一开始生产的时候，发现到这个问题，想处理这些坏块。但是呢，由于处理起来成本太高(即，良品率太低)，索性就让他坏块，出厂前做下坏块处理，检测一下坏块数量不多就出厂了。</p><p>&emsp;&emsp;Nand Flash是存在挺多坏块的。我们那些移动硬盘，那么大容量，当然是采用Nand Flash做成的。至于遇到所谓的黑心商家，就是把坏块率高的(或者寿命较短，用过的)移动硬盘(Nand Flash)卖给你。</p><p>&emsp;&emsp;<strong>Nor Flash没有坏块</strong>(你可以认为)。实际上 Nor Flash 是存在坏块的，只不过是在内对坏块进行了处理。</p><blockquote><p>另类的 “坏块”</p></blockquote><p>&emsp;&emsp;另类的坏块，即寿命到了产生的不可写区域。一般人会混淆，认为不能用就是坏块(其实也算)。寿命到了不一定就不能用，只不过是容易产生”坏块”。尤其是嵌入式设备的Flash，由于对数据量要求不高，且对稳定性有高要求，往往采用的是Nor Flash做数据存储。</p><p>&emsp;&emsp;但是Nor Flash的擦写寿命相对较短，寿命将至闪存可能会工作异常(产生”坏块”)。写平衡(又名 磨损平衡、负载平衡)便应运而生。</p><p>&emsp;&emsp;由于Nor Flash的Sector(block)，都是有一定寿命限制的，所以如果你每次都往同一个Sector(block)擦除然后写入数据，稍微长时间，那么那个Sector(block)就很容易被用坏了。所以我们要去管理一下，将这么多次的对同一个Sector(block)的操作，平均分布到其他一些Sector(block)上面，使得在Sector(block)的使用上，相对较平均，这样相对来说，可以更能充分利用Nor Flash。</p><p>&emsp;&emsp;只进行一次大规模的擦除，后续的操作只需要进行写和读；写过的区域不再重写，读取的数据根据自己的需求算法，查出在Nor Flash的位置地址，读取想要的数据。当整个Nor Flash接近写满时，重新大规模擦除前，需要注意先擦除小部分区域，把所需的数据先读取出来，再重写入新擦除区域保存。</p><p><strong>写平衡</strong>，将空闲的Sector(Block)运用起来，进而将Nor Flash的寿命变相翻倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备的存储器科普。&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Flash" scheme="http://shatang.github.io/tags/Flash/"/>
    
      <category term="ROM" scheme="http://shatang.github.io/tags/ROM/"/>
    
      <category term="SRAM" scheme="http://shatang.github.io/tags/SRAM/"/>
    
  </entry>
  
  <entry>
    <title>TCP通讯_宏观</title>
    <link href="http://shatang.github.io/2020/05/30/TCP%E9%80%9A%E8%AE%AF-%E5%AE%8F%E8%A7%82/"/>
    <id>http://shatang.github.io/2020/05/30/TCP通讯-宏观/</id>
    <published>2020-05-30T03:00:58.000Z</published>
    <updated>2020-05-30T03:02:24.990Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;该篇介绍宏观层面的TCP/IP协议</p><img src="/2020/05/30/TCP通讯-宏观/1.png" title="TCP/IP 参考模型"><a id="more"></a><h1 id="一、TCP-IP-协议的层次结构-宏观"><a href="#一、TCP-IP-协议的层次结构-宏观" class="headerlink" title="一、TCP/IP 协议的层次结构(宏观)"></a>一、TCP/IP 协议的层次结构(宏观)</h1><p>&emsp;&emsp;TCP/IP参考模型分为四个层次：应用层、传输层、网络(互连)层和主机到网络层(数据链路层)</p><img src="/2020/05/30/TCP通讯-宏观/2.png" title="TCP/IP 模型层次"><h2 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h2><p>&emsp;&emsp;应用层面向不同的网络应用引入了不同的应用层协议。</p><ul><li>传输层采用<strong>TCP协议</strong>的有：<ul><li><code>HTTP</code>：超文本传输协议（Hyper Text Transfer Protocol）</li><li><code>HTTPS</code>:超文本传输安全协议（Hyper Text Transfer Protocol Secure）</li><li><code>FTP</code>：文件传输协议（File Transfer Protocol）它定义了本地登录用户与远程服务器之间的交互过程。</li><li><code>SFTP</code>：文件加密传输协议（Secure File Transfer Protocol）</li><li><code>TELNET</code>：远程登录（Telecommunications Network）提供远程访问其它主机功能,它允许用户登录 internet主机,并在这台主机上执行命令. </li></ul></li><li>传输层采用<strong>UDP协议</strong>的有：（一次性传输的数据需求很少）<ul><li><code>TFTP</code>：简单文件传输协议（Trivial File Transfer Protocol）FTP的简化版本</li><li><code>SNMP</code>：简单网络管理协议（Simple Network Management Protocol）该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等. </li><li><code>NTP</code>：网络时间协议（Network Time Protocol）</li></ul></li><li>传输层同时采用TCP和UDP协议的有：<ul><li><code>DNS</code>(域名系统)：该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. </li></ul></li></ul><img src="/2020/05/30/TCP通讯-宏观/3.png" title="应用层具体应用"><p><strong><font color="red">Ps：</font></strong><br>HTTP是面向网页（文本信息）的，而FTP是面向文件的</p><h2 id="1-2-传输层"><a href="#1-2-传输层" class="headerlink" title="1.2 传输层"></a>1.2 传输层</h2><p><code>TCP</code>：传输控制协议（transmission control protocol）<br><code>UDP</code>：用户数据报协议（user datagram protocol）</p><p><strong><code>TCP</code>与<code>UDP</code>的区别：</strong> </p><ol><li>基于连接与无连接;</li><li>对系统资源的要求（TCP较多，UDP少）;</li><li>UDP程序结构较简单;</li><li>流模式与数据报模式; </li><li>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证.</li></ol><p><strong><code>TCP</code> 与 <code>UDP</code> 的<font color="red">主要区别</font>：</strong></p><p>&emsp;&emsp;UDP具有TCP所望尘莫及的速度优势，但在于UDP不一定提供可靠的数据传输。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。</p><p><strong><font color="red">Ps：</font></strong><br>许多程序将使用单独的TCP连接和单独的UDP连接;重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。</p><h2 id="1-3-网络层（网络互连层）"><a href="#1-3-网络层（网络互连层）" class="headerlink" title="1.3 网络层（网络互连层）　"></a>1.3 网络层（网络互连层）　</h2><p>&emsp;&emsp;网络互连层定义了分组格式和协议。</p><p>&emsp;&emsp;网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。　　</p><ul><li><code>IP</code>：Internet 协议（Internet Protocol） </li><li><code>ICMP</code>：Internet控制信息协议 </li><li><code>ARP</code>：地址解析协议 </li><li><code>RARP</code>：反向地址解析协议</li></ul><h2 id="1-4-网络访问层（主机到网络层）"><a href="#1-4-网络访问层（主机到网络层）" class="headerlink" title="1.4 网络访问层（主机到网络层）　　　　　"></a>1.4 网络访问层（主机到网络层）　　　　　</h2><p>&emsp;&emsp;网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接。</p><h1 id="二、常见术语、疑问-介绍"><a href="#二、常见术语、疑问-介绍" class="headerlink" title="二、常见术语、疑问 介绍"></a>二、常见术语、疑问 介绍</h1><p>&emsp;&emsp;TCP/IP协议：是一组网络协议。<strong>在这些协议中，最重要、最著名的就是TCP和IP因此，大部分网络管理员称整个协议族为“TCP/IP”</strong>。包括：TCP，IP，UDP，ARP等，这些被称为子协议。</p><h2 id="2-1-TCP与IP的区别"><a href="#2-1-TCP与IP的区别" class="headerlink" title="2.1 TCP与IP的区别"></a>2.1 TCP与IP的区别</h2><p>&emsp;&emsp;由第一章的TCP/IP 协议的层次结构可知，<code>TCP</code> 和 <code>IP</code> 是在不同层的，因此两者本来就天差地别。</p><ul><li><code>TCP</code>：位于传输层，是一种面向连接的、端对端的、可靠的、基于IP的传输层协议。主要特点是3次握手建立连接，4次挥手断开连接。</li><li><code>IP</code>：位于网络层，IP协议规定了数据传输时的基本单元（数据包）和格式，IP协议还定义了数据包的递交办法和路由选择。</li></ul><p>总结：</p><ol><li>整个网络中的传输流程是：IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层——TCP层；相反，IP层也把从TCP接收来的数据包传送到更低层。</li><li>TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步加工，如提供端口号等等。</li></ol><h2 id="2-2-Telnet的衍生（SSH等）"><a href="#2-2-Telnet的衍生（SSH等）" class="headerlink" title="2.2 Telnet的衍生（SSH等）"></a>2.2 Telnet的衍生（SSH等）</h2><p>&emsp;&emsp;<code>TELNET</code>：远程登录（Telecommunications Network）提供远程访问其它主机功能;听起来很陌生，但实际上我们是经常使用远程登录的功能，即使用Telnet的衍生;</p><p>&emsp;&emsp;<code>Telnet</code>用来訪问远程计算机的TCP/IP协议以控制你的网络设备，是明码传输，缺乏安全性。因此诞生了远程登录的加密传输，如下：</p><p><code>SSH</code>：Secure Shell（包括SSH1和SSH2）<br><code>Telnet/SSL</code>： Secure Socket Layer。Telnet/SSL是带有SSL的Telnet。<br><code>Rlogin</code>：Rlogin和Telnet功能使用方法相似，可是简单非常多。<br><code>Serial</code>：串行指每次一个事件，它通常跟并行即一次发生多个事件相反，例如键盘和鼠标仅仅须要串行接口和线路<br><code>TAPI</code>：telephone Application Programming Interface （它能够使用户在电脑上通过电话或视频电话与电话还有一端的人进行交谈）电话应用编程接口<br><code>RAW</code>：大多数打印设备的默认协议</p><h2 id="2-3-VPN和SS、SSR"><a href="#2-3-VPN和SS、SSR" class="headerlink" title="2.3 VPN和SS、SSR"></a>2.3 VPN和SS、SSR</h2><p>&emsp;&emsp;这里讲一下大家常见到的VPN和SSR的来头。</p><h3 id="2-3-1-什么是VPN"><a href="#2-3-1-什么是VPN" class="headerlink" title="2.3.1 什么是VPN"></a>2.3.1 什么是VPN</h3><p>&emsp;&emsp;vpn在很多人心目中就是用来科学上网的工具，其实不是。vpn最主要的功能，并不是用来科学上网，只是它可以达到科学上网的目的。vpn–虚拟专用网络，它的功能是：在公用网络上建立专用网络，进行加密通讯。</p><h3 id="2-3-2-什么是ss-ssr"><a href="#2-3-2-什么是ss-ssr" class="headerlink" title="2.3.2 什么是ss/ssr"></a>2.3.2 什么是ss/ssr</h3><p>ss：ss作者是clowwindy，大约两年前，他自己为了科学上网写了shadowsocks，简称ss或者叫影梭，后来他觉得这个东西非常好用，速度快，而且不会被封锁，他就把源码共享在了github上，然后就火了，但是后来作者被请去喝茶，删了代码，并且保证不再参与维护更新。现在这个好像是一个国外的大兄弟在维护。</p><p>ssr：在ss作者被喝茶之后，github上出现了一个叫breakwa11(破娃)的帐号，声称ss容易被防火墙检测到，所以在混淆和协议方面做了改进，更加不容易被检测到，而且兼容ss，改进后的项目叫shadowsocks-R，简称ssr，然后ss用户和ssr用户自然分成了两个派别，互相撕逼，直到前阵子，破娃被人肉出来，无奈之下删除了ssr的代码，并且解散了所有相关群组。</p><p>ss和ssr它的原理都是一样的，就是socks5代理。socks代理只是简单的传递数据包，而不必关心是何种协议，所以socks代理比其他应用层代理要快的多。socks5代理是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地，这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理。通俗的说，现在你有一个代理服务器在香港，比如你现在想要访问google，你的电脑发出请求，流量通过socks5连接发到你在香港的服务器上，然后再由你在香港的服务器去访问google，再把访问结果传回你的电脑，这样就实现了科学上网。</p><h2 id="2-4-DNS"><a href="#2-4-DNS" class="headerlink" title="2.4 DNS"></a>2.4 DNS</h2><p>&emsp;&emsp;<strong>DNS是域名解析服务器，是把网址变成IP地址的服务器</strong>。DNS说白了是把<strong>域名</strong>翻译成IP地址用的。</p><p>举例 ，例如我们在浏览器里面输入<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>这个域名翻译成了IP地址<code>61.135.169.105</code>。</p><p>&emsp;&emsp;这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，<strong>如果不设置DNS的话，是无法正常访问网页的</strong>。</p><p>&emsp;&emsp;注意！是无法正常访问网页，还是能够上网的。如果没有填写DNS，可以直接使用形如 <code><a href="http://192.168.2.10" target="_blank" rel="noopener">http://192.168.2.10</a></code> IP地址的形式来进行 网页访问。</p><h2 id="2-5-Socket-和-端口号"><a href="#2-5-Socket-和-端口号" class="headerlink" title="2.5 Socket 和 端口号"></a>2.5 Socket 和 端口号</h2><p>&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。</p><h3 id="2-5-1-端口号来源"><a href="#2-5-1-端口号来源" class="headerlink" title="2.5.1 端口号来源"></a>2.5.1 端口号来源</h3><p>&emsp;&emsp;当两台机器通过IP链接通讯，当如果其中一台机器还想和别的机器搞事情呢？例如你浏览多个网页，那怎么办？现在都讲究多进程、多线程，那多进程怎么区分了链接，就衍生出端口号。同个IP，开放多个<strong>port</strong>(端口号)，多个进程执行数据交互。</p><p><strong><font color="red">Ps：</font></strong><br>端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。</p><p>&emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。</p><h3 id="2-5-2-Socket"><a href="#2-5-2-Socket" class="headerlink" title="2.5.2 Socket"></a>2.5.2 Socket</h3><p><strong>Socket</strong>：就是 传输层TCP协议 到 应用层<code>HTTP</code>、<code>HTTPS</code>、<code>FTP</code>的基石。中文：套接字。指代承载这种通讯的TCP系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号)。</p><p>&emsp;&emsp;无论是什么模块进行连接网络通信，最终都会进行应用层的数据交互(除了裸流)。但是传输层和应用层的TCP连接是有基石的，那就是Socket。</p><p>&emsp;&emsp;由于往往是听过应用层协议连接，而Socket是作为应用层基石。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）。通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</p><p>&emsp;&emsp;Socket虽然是 传输层TCP协议&amp;应用层的基石。但是也可以不需要应用层，也就是裸流连接。常见于菜鸟的服务器，即没有任何通信协议，就像是用串口调试助手直接连一样。外面的人常直接称呼 TCP通信。</p><p><strong><font color="red">Ps：</font></strong><br>这种Socket连接方式，常见于嵌入式物联网、简单物联设备等。</p><p>&emsp;&emsp;Socket如果是严格区分的话，它带有的资源应该是：本地端口号、远地IP地址、远地端口号。因为本地IP定义下来后就不会再更改，实现多Socket链接通信，其实需要的就是多个 本地端口号、远地IP地址、远地端口号，组合成多Socket通信。</p><h2 id="2-6-内网穿透"><a href="#2-6-内网穿透" class="headerlink" title="2.6 内网穿透"></a>2.6 内网穿透</h2><p>&emsp;&emsp;内网穿透概念往往用于 大学、公司内部。</p><p>&emsp;&emsp;简单来说内网就是我们常说的局域网（LAN），而外网则是指广域网（WAN）。比如大学、医院、或者政府机构这些单位中，给每一个人分配一个IP地址，这显然是不现实的：一方面是因为这些单位的人员数量庞大，另一方面是因为人员数量也是变动的。为了解决这个问题，就出现了内网。</p><p>&emsp;&emsp;也就是说分配真实的IP，实际上只分配给广域网。局域网则是由网络管理员给的虚拟IP。</p><blockquote><p>内网和外网的区别</p></blockquote><p>以大学的校园网为例：</p><ul><li>一个大学的校园网至少有一个真实的IP地址，这个真实IP地址会作为整个校园网的出口，而其他的IP地址被称为假IP地址，假的IP地址发送的网络请求会通过真实的IP地址发送到因特网上，并将获得的资源再通过这个真实的IP地址返回过来。就这样完成了网络通讯的过程。</li><li>你连学校内网，登上你的百度账号，下载百度文库的文件，会显示你是xx学校的，然后免费下载，就是因为你的网络请求实际上是从 学校真实的IP 发出去的。因此百度才会知道你是xx学校的。</li></ul><p><strong>假IP地址的特点：它能够访问外网IP地址，但外网IP地址却无法找这个假的IP地址。</strong></p><p>&emsp;&emsp;因此如果想要从外网IP地址找到该虚拟IP地址，这台内网电脑就要实现<strong>内网穿透</strong>，常见的有花生壳。</p><h2 id="2-7-现实的网络插口"><a href="#2-7-现实的网络插口" class="headerlink" title="2.7 现实的网络插口"></a>2.7 现实的网络插口</h2><p>&emsp;&emsp;在现实生活中的网络插口，则是有两个灯，一绿一橙。</p><ul><li>绿灯表示物理连接线正常，即网线有插好</li><li>橙灯表示网络通讯，如果在闪烁，说明在通讯；接近常亮，就说明通讯频率高</li><li>如果两个灯都正常，而网络异常；就要考虑是不是外部网络出现问题，例如DNS之类的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;该篇介绍宏观层面的TCP/IP协议&lt;/p&gt;
&lt;img src=&quot;/2020/05/30/TCP通讯-宏观/1.png&quot; title=&quot;TCP/IP 参考模型&quot;&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="TCP/IP" scheme="http://shatang.github.io/tags/TCP-IP/"/>
    
      <category term="SSH" scheme="http://shatang.github.io/tags/SSH/"/>
    
      <category term="TCP" scheme="http://shatang.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://shatang.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>TCP通讯_微观</title>
    <link href="http://shatang.github.io/2020/05/30/TCP%E9%80%9A%E8%AE%AF-%E5%BE%AE%E8%A7%82/"/>
    <id>http://shatang.github.io/2020/05/30/TCP通讯-微观/</id>
    <published>2020-05-30T03:00:40.000Z</published>
    <updated>2020-05-30T03:08:23.838Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;该篇介绍微观层面的TCP/IP协议————基于W5500的嵌入式TCP通讯开发</p><a id="more"></a><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><p>&emsp;&emsp;这里将会连续引申出微观TCP/IP协议的一些概念。嵌入式的TCP通讯最重要的一个概念，就是IP地址。</p><h2 id="1-1-IP地址"><a href="#1-1-IP地址" class="headerlink" title="1.1 IP地址"></a>1.1 IP地址</h2><h3 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1 概念"></a>1.1.1 概念</h3><p>&emsp;&emsp;IP地址，英文名为IP Address，是internet protocol address的缩写，译为互联网协议地址，又译为网际协议地址。它是IP协议（internet protocol ）提供的一种统一的地址格式，分配给使用IP协议的设备的数字标签。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。更通俗的来说，IP地址给网上的每个通信设备分配了一个编号，每台联网的主机都需要有这个编号来通信。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。</p><h3 id="1-1-2-表示"><a href="#1-1-2-表示" class="headerlink" title="1.1.2 表示"></a>1.1.2 表示</h3><p>通常所说的IP地址，是指IPv4。IP地址是一个32位的二进制数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000111111110000000011111111</span></span><br></pre></td></tr></table></figure><p>通常被分割为4个8位二进制数，例如上面这个IP地址，可以分割为如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>    <span class="number">11111111</span>     <span class="number">00000000</span>     <span class="number">11111111</span></span><br></pre></td></tr></table></figure><p>再使用十进制数来表示每个8位二进制数，十进制数之间使用点号分隔，IP地址最终表示成如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.b.c.d</span><br></pre></td></tr></table></figure><p>因为一个8位二进制数表示的范围00000000 ~ 11111111正好对应十进制数0 ~ 255，所以a、b、c和d都是0 ~ 255的十进制整数。例如上面IP地址，可以表示为0.255.0.255.<br>（1）冒分十六进制表示法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X:X:X:X:X:X:X:X</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中每个X表示地址中的16b，以十六进制表示，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCD:EF01:<span class="number">2345</span>:<span class="number">6789</span>:ABCD:EF01:<span class="number">2345</span>:<span class="number">6789</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种表示法中，每个X的前导0是可以省略的，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2001</span>:<span class="number">0</span>DB8:<span class="number">0000</span>:<span class="number">0023</span>:<span class="number">0008</span>:<span class="number">0800</span>:<span class="number">200</span>C:<span class="number">417</span>A→ <span class="number">2001</span>:DB8:<span class="number">0</span>:<span class="number">23</span>:<span class="number">8</span>:<span class="number">800</span>:<span class="number">200</span>C:<span class="number">417</span>A</span><br></pre></td></tr></table></figure><p>（2）0位压缩表示法<br>&emsp;&emsp;在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FF01:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1101</span> → FF01::<span class="number">1101</span></span><br><span class="line"><span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span> → ::<span class="number">1</span></span><br><span class="line"><span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span> → ::</span><br></pre></td></tr></table></figure><p>（3）内嵌IPv4地址表示法<br>为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X:X:X:X:X:X:d.d.d.d</span><br></pre></td></tr></table></figure><p>前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>与::FFFF:<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用。</p><h3 id="1-1-3-IPv4地址分类"><a href="#1-1-3-IPv4地址分类" class="headerlink" title="1.1.3 IPv4地址分类"></a>1.1.3 IPv4地址分类</h3><p>网络号或网络地址（NetID）：用于识别主机所在的网络；<br>主机号或主机地址（HostID）：用于识别该网络中的主机；<br>&emsp;&emsp;为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。<br><strong>私有地址：所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址。</strong></p><table><thead><tr><th>类别</th><th>用途</th><th>网络号和主机号</th><th>最高位</th><th>地址范围</th><th>私有地址和保留地址</th><th>子网掩码</th></tr></thead><tbody><tr><td>A</td><td>保留给政府机构</td><td>第一段表示网络地址，剩下三段表示主机地址</td><td>0</td><td>0.0.0.0——127.255.255.255</td><td>①10.X.X.X是私有地址 ②127.X.X.X是保留地址</td><td>255.0.0.0</td></tr><tr><td>B</td><td>分配给中等规模的公司</td><td>前两段表示网络地址，后两段表示主机地址</td><td>10</td><td>128.0.0.0——191.255.255.255</td><td>①172.16.0.0—172.31.255.255是私有地址②169.254.X.X是保留地址；191.255.255.255是广播地址，不能分配。</td><td>255.255.0.0</td></tr><tr><td>C</td><td>分配给任何需要的人</td><td>前三段表示网络地址，剩下一段表示主机地址</td><td>110</td><td>192.0.0.0——223.255.255.255</td><td>192.168.X.X是私有地址</td><td>255.255.255.0</td></tr><tr><td>D</td><td>用于组播</td><td>不分网络地址和主机地址</td><td>1110</td><td>224.0.0.0——239.255.255.255</td><td></td><td></td></tr><tr><td>E</td><td>用于实验</td><td>不分网络地址和主机地址</td><td>11110</td><td>240.0.0.0——255.255.255.254</td><td></td><td></td></tr></tbody></table><p>如图：</p><p>&emsp;&emsp;这里就不再详细介绍IP地址中的一些特殊地址了；我们目前主要用的是C类别，也就是192.168.X.X的私有地址</p><h2 id="1-2-子网掩码"><a href="#1-2-子网掩码" class="headerlink" title="1.2 子网掩码"></a>1.2 子网掩码</h2><p>&emsp;&emsp;IP地址填完后，网段不同，是并不能够直接通讯的；(平常)路由器连接的是不同的网络，网桥连接的是不同网段，这里的网络和网段有什么区别呢？</p><h3 id="1-2-1-网段"><a href="#1-2-1-网段" class="headerlink" title="1.2.1 网段"></a>1.2.1 网段</h3><p>&emsp;&emsp;路由器连接的是不同的网络，这里的网络就是网段不同的网段和不同的网络是同一个概念；专业点就说网段，通俗一点就说网络，其实就是一个意思。</p><ul><li>那什么是同一网段？<br>同一网段指的是IP地址和子网掩码相与得到相同的网络地址；<br>想在同一网段，必需做到网络标识相同；各类IP的网络标识算法都是不一样的，需要根据子网掩码的位数来判断。</li></ul><ul><li>那什么是掩码？</li></ul><ul><li>想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？</li></ul><h3 id="1-2-2-掩码"><a href="#1-2-2-掩码" class="headerlink" title="1.2.2 掩码"></a>1.2.2 掩码</h3><p>&emsp;&emsp;掩码，是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。<br>用途：将源码与掩码经过按位运算或逻辑运算得出新的操作数。其中要用到按位运算如OR运算和AND运算。用于如将ASCII码中大写字母改作小写字母。</p><p>举例：如A的ASCII码值为65= (01000001)2，a的ASCII码值为97=(01100001)2，要想把大写字母A转化为小写字母只需要将A的ASCII码与(00100000)2进行或运算就可以得到小写字母a。<br>&emsp;&emsp;子网掩码，即就是用来算网络标识的掩码.</p><h3 id="1-2-3-网络标识"><a href="#1-2-3-网络标识" class="headerlink" title="1.2.3 网络标识"></a>1.2.3 网络标识</h3><ol><li><p>算法只要把IP和子网掩码的每位数AND就可以了。</p></li><li><p>AND方法：0&amp;1=0　0&amp;0=0　1&amp;1=1</p></li><li><p>如：And　<code>192.168.0.1</code>，<code>255.255.255.0</code>，先转换为二进制，然后AND每一位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP            <span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.00000001</span></span><br><span class="line">子网掩码      <span class="number">11111111.11111111</span><span class="number">.11111111</span><span class="number">.00000000</span></span><br><span class="line">得出AND结果   <span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.00000000</span></span><br></pre></td></tr></table></figure></li><li><p>转换为十进制192.168.0.0，这就是网络标识，</p></li><li><p>再将子网掩码反取，也就是00000000.00000000.00000000.11111111，与IP　AND</p></li><li><p>得出结果00000000.00000000.00000000.00000001，转换为10进制，即0.0.0.1；这0.0.0.1就是主机标识。要想在同一网段，必需做到网络标识一样。</p></li></ol><p>这里介绍最常用的两种子网掩码，它们分别是“<code>255.255.255.0</code>”和“<code>255.255.0.0</code>”。</p><h2 id="1-3-网关地址"><a href="#1-3-网关地址" class="headerlink" title="1.3 网关地址"></a>1.3 网关地址</h2><p>&emsp;&emsp;如果网段不同，就实现不了通信，但现实生活中那么多设备肯定不在同个网段；那么不同网段确能够通信，就需要 网关 了.<br>&emsp;&emsp;网关（gateway）是一个网络连接到另一个网络的“关口”，网关地址实质上是一个网络通向其他网络的IP地址，主要用于不同网络间数据传输。网关在网段内的可用ip中选一个，一般选择是第一个或最后一个。</p><p>举例:比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1 ~ 192. 168.1.254”，子网掩码是255.255.255.0；如果需要与其他网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为网段内其他的一个IP地址。网络B的IP地址范围是“192.168.2.1 ~ 192.168.2.254”，子网掩码255.255.255.0。如果需要与其他网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为网段内其它的一个ip地址。</p><ul><li>网关是如何实现通信？<br>&emsp;&emsp;在没有路由器的情况下，不同的网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的的主机不再本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。所以说，设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。</li></ul><ul><li>网关设置方式有哪些？</li></ul><ol><li>手动设置：手动设置适用于电脑数量比较少、TCP/IP参数基本不变的情况，比如只有几台到十几台电脑。因为这种方法需要在联入网络的每台电脑上设置“默认网关”，非常费劲，一旦因为迁移等原因导致必须修改默认网关的IP地址，就会给网管带来很大的麻烦，所以不推荐使用。</li><li>自动设置：利用DHCP服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。这种方法适用于网络规模较大、TCP/IP参数有可能变动的网络。</li></ol><h2 id="1-4-MAC地址"><a href="#1-4-MAC地址" class="headerlink" title="1.4 MAC地址"></a>1.4 MAC地址</h2><p>&emsp;&emsp;媒体访问控制（media access control，MAC）是物理地址、硬件地址，用来定义网络设备的位置。</p><p>ip是虚拟地址；mac是网卡地址全世界只有一种没重复的。MAC是网络中用来识别网卡设备的唯一网络地址；由相关硬件制造商统一分配，每台电脑的MAC地址都是唯一的</p><h2 id="1-5-DNS"><a href="#1-5-DNS" class="headerlink" title="1.5 DNS"></a>1.5 DNS</h2><p>&emsp;&emsp;DNS是域名解析服务器，是把网址变成IP地址的服务器。DNS说白了是把域名翻译成IP地址用的；</p><p>举例 ，例如我们在浏览器里面输入<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把<code><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></code>这个域名翻译成了IP地址<code>61.135.169.105</code>。</p><p>这就是DNS的作用，所以你的本地连接里面写DNS才能正常浏览网页，如果不设置的话，是无法正常访问网页的。</p><h2 id="1-6-Socket-和-端口号"><a href="#1-6-Socket-和-端口号" class="headerlink" title="1.6 Socket 和 端口号"></a>1.6 Socket 和 端口号</h2><p>&emsp;&emsp;TCP通讯：两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。另一个做主动方，叫做客户端。</p><p>这里引入 <strong>端口号</strong> 的概念：一个计算机上可以有多个进程作为(多个)服务器 or 客户端 ，但是 ip 每个机器只有一个，所以通过不同的 <strong>port</strong> 数字加以区分。</p><p><strong><font color="red">Ps：</font></strong>端口是TCP/IP协议中的概念，描述的是TCP协议上的对应的应用，可以理解为基于TCP的系统服务，或者说系统进程！特定的服务往往需要特定的端口；例如，FTP就需要占用特定的TCP端口。</p><p>&emsp;&emsp;因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。两个进程通过网络建立起通讯渠道，然后就可以通过 recv 和 send 来收发一些信息，完成通讯。</p><p><strong>Socket</strong>   ：  就是指代承载这种通讯的系统资源的标识。(系统资源：协议，本地地址，本地端口号，远地地址，远地端口号)</p><p><strong><font color="red">Ps：</font></strong>Socket是一个接口，在用户进程与TCP/IP协议之间充当中间人，完成TCP/IP协议的书写，用户只需理解接口即可。</p><h1 id="二、基于W5500的TCP通讯"><a href="#二、基于W5500的TCP通讯" class="headerlink" title="二、基于W5500的TCP通讯"></a>二、基于W5500的TCP通讯</h1><p>&emsp;&emsp;等待更新中。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;该篇介绍微观层面的TCP/IP协议————基于W5500的嵌入式TCP通讯开发&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="TCP/IP" scheme="http://shatang.github.io/tags/TCP-IP/"/>
    
      <category term="TCP" scheme="http://shatang.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://shatang.github.io/tags/UDP/"/>
    
      <category term="Socket" scheme="http://shatang.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Modbus协议_具体实现</title>
    <link href="http://shatang.github.io/2020/05/30/Modbus%E5%8D%8F%E8%AE%AE-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://shatang.github.io/2020/05/30/Modbus协议-具体实现/</id>
    <published>2020-05-30T02:52:04.000Z</published>
    <updated>2020-05-30T02:53:42.569Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式</p><a id="more"></a><h1 id="一、搭建环境-amp-简介"><a href="#一、搭建环境-amp-简介" class="headerlink" title="一、搭建环境&amp;简介"></a>一、搭建环境&amp;简介</h1><ol><li>采用的是stm32f103RBT6为例</li><li>从机实现采用 FreeModbus库</li><li>Modbus TCP通讯是基于 W5500 实现的</li></ol><p>&emsp;&emsp;这里主要讲解的是Modbus从机(Server)的实现。因为实际产品常用于采集数据或做动作处理，一般是作为从设备，接入Plc(Modbus主机)。</p><h1 id="二、Modbus主机-Master"><a href="#二、Modbus主机-Master" class="headerlink" title="二、Modbus主机(Master)"></a>二、Modbus主机(Master)</h1><p>&emsp;&emsp;Modbus主机一般很少用到。主要用途，一般用于：实际产品分为前后台，后台做所有的数据处理，作为Modbus从机；而前台主要用于做界面显示，即作为Modbus主机，界面数据修改通过串口Modbus通讯。</p><p>&emsp;&emsp;由于是前后台的内置通讯，常用的Modbus主机 当然是采用<strong>方便、可靠</strong>的 Modbus RTU通讯。</p><p>&emsp;&emsp;当然由于前后台通讯占用一个硬件串口Modbus通讯。因此，常见的Modbus从机，往往是具有多串口Modbus通讯，共享一套地址处理数据(当然，可能前后台内置通讯在实际产品说明书中被隐藏)。</p><hr><p>&emsp;&emsp;Modbus主机，在网上是没有开源，只有收费版本的。其实只要根据Modbus协议，很容易就能写一个Modbus主机。</p><p>唯一需要注意的点：每个数据帧发送之间的间隔为 3.5T；防止从机接收到的数据黏合。</p><p>&emsp;&emsp;但是由于Modbus主机一般要处理其他事宜，往往本身每个数据帧发送之间的间隔都 &gt; 3.5T。因此实际上，写得不标准也能用；当然严谨一点的话，写一个定时器，发送就开启定时器，定时器溢出置标志位才能再次发送也是可以的。</p><h1 id="三、Modbus从机-Slave"><a href="#三、Modbus从机-Slave" class="headerlink" title="三、Modbus从机(Slave)"></a>三、Modbus从机(Slave)</h1><p>&emsp;&emsp;这里的Modbus从机是基于 FreeModbus库 实现的。  </p><p>&emsp;&emsp;Freemodbus库的代码是写得很好的，如果C语言学得好，且对Modbus协议了解的话，建议直接看源码，多看多观察可以提高自己的代码水平。</p><h2 id="3-1-FreeModbus移植-RTU模式"><a href="#3-1-FreeModbus移植-RTU模式" class="headerlink" title="3.1 FreeModbus移植(RTU模式)"></a>3.1 FreeModbus移植(RTU模式)</h2><p>&emsp;&emsp;FreeModbus详细移植方法可以参照以下博主：</p><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=69081&extra=page%3D2" target="_blank" rel="noopener">FreeModbus在STM32上移植</a></p><p><a href="https://blog.csdn.net/qq_33611327/article/details/77883787" target="_blank" rel="noopener">STM32上移植FreeModbus详细过程</a></p><h2 id="3-2-如何计算RTU模式的-3-5T-超时时间？"><a href="#3-2-如何计算RTU模式的-3-5T-超时时间？" class="headerlink" title="3.2 如何计算RTU模式的 3.5T 超时时间？"></a>3.2 如何计算RTU模式的 3.5T 超时时间？</h2><p><strong>波特率</strong>：每秒钟通过信道传输的信息量称为位传输速率，也就是每秒钟传送的二进制位数,简称比特率。</p><p><strong>比特率</strong>：表示有效数据的传输速率，用b/s 、bit/s、比特/秒，读作：比特每秒。</p><hr><p>通常的串口桢格式为10位：<code>开始位1bit + 数据位8bit + 停止位1bit</code></p><p>&emsp;&emsp;如9600b/s：指总线上每秒可以传输9600个bit；也就是说：在9600的波特率下，每秒可以传输出的桢数为：9600 / (1 + 8 + 1) = 960桢/秒，即960字节/秒(实际数据速率)；</p><p>反推：一帧或一字节数据需要的时间是多少呢？</p><p>1s / 960 = 1.4ms</p><p>而ModBus协议中超时时间定为：3.5个帧长度为超时时间；</p><ul><li>超时时间 <ul><li>= 3.5 * 1 / BaudRate / 10 秒</li><li>= 3.5 * 10 / BaudRate 秒</li><li>= 3.5 * 10  * 2 / BaudRate  * 2 秒</li><li>=  70 / BaudRate  * 2 秒</li></ul></li></ul><hr><p>FreeModBus是这样实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If baudrate &gt; 19200 then we should use the fixed timer values</span></span><br><span class="line"><span class="comment">* t35 = 1750us. Otherwise t35 must be 3.5 times the character time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>( ulBaudRate &gt; <span class="number">19200</span> )</span><br><span class="line">&#123;</span><br><span class="line">    usTimerT35_50us = <span class="number">35</span>;       <span class="comment">/* 1800us. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The timer reload value for a character is given by:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 )</span></span><br><span class="line"><span class="comment">    *             = 11 * Ticks_per_1s / Baudrate</span></span><br><span class="line"><span class="comment">    *             = 220000 / Baudrate</span></span><br><span class="line"><span class="comment">    * The reload for t3.5 is 1.5 times this value and similary</span></span><br><span class="line"><span class="comment">    * for t3.5.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    usTimerT35_50us = ( <span class="number">7U</span>L * <span class="number">220000U</span>L ) / ( <span class="number">2U</span>L * ulBaudRate );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>波特率大于19200使用定值：1800us</li></ul><p>&emsp;&emsp;由于将<code>usTimerT35_50us = 35;</code>直接带入，在定时器驱动初始化实际代入的计算值为 (35 = 36-1)，因此实际的定时时间为：36 * 50(基值) = 1800 us。</p><ul><li>波特率小于19200使用定值：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usTimerT35_50us = ( <span class="number">7U</span>L * <span class="number">220000U</span>L ) / ( <span class="number">2U</span>L * ulBaudRate );</span><br></pre></td></tr></table></figure></li></ul><hr><p>解析：由于Modbus的RTU模式是串口帧格式为11位，故</p><ul><li>超时时间 (50us为单位)<ul><li>= 3.5 * 1 / BaudRate / 11 秒</li><li>= 3.5 * 11 / BaudRate 秒</li><li>= 3.5 * 11  * 2 / BaudRate  * 2 秒</li><li>= 7 * 11 / BaudRate  * 2 秒</li><li>= 7 * 11 * 1000000 / 50 / BaudRate  * 2 (50us为单位)</li><li>= 7 * 220000 / BaudRate * 2 (50us为单位)</li></ul></li></ul><p>&emsp;&emsp;这usTimerT35_50us一个单位为50uS，将这个超时时间计算结果用于定时器驱动初始化。每中断一次为50us * usTimerT35_50us 微秒；<strong>且每次更改Modbus通信的波特率，Modbus的定时器驱动初始化都要更新一次，更新定时器计数溢出值</strong>。</p><h1 id="四、-FreeModbus库源码"><a href="#四、-FreeModbus库源码" class="headerlink" title="四、 FreeModbus库源码"></a>四、 FreeModbus库源码</h1><p>&emsp;&emsp;3.1所提到的移植，是把RTU模式通讯的底层给移植好，报文中的具体<strong>数据单元处理功能函数</strong>还是得自己继续写。</p><p>&emsp;&emsp;但暂先不讲具体的<strong>数据单元处理功能函数</strong>写法，先讲解整个FreeModbus源码的实现过程，使其后面更清晰如何写数据单元处理功能函数，甚至可以自己移植、扩展改动(ASCII、TCP模式)。</p><h2 id="4-1-实现的核心原理"><a href="#4-1-实现的核心原理" class="headerlink" title="4.1 实现的核心原理"></a>4.1 实现的核心原理</h2><p>&emsp;&emsp;每一帧的数据区分是采用3.5T的方法。那么MCU具体的实现方法思路如下：</p><p>&emsp;&emsp;使能串口接收中断，一但接收到数据(触发串口接收中断)，就开启定时器，每一次重新触发串口接收中断，就会重启定时器&amp;重新计数；直到不触发串口接收中断，导致定时器溢出，此时视为接收一帧完整数据，开始解析数据。再根据自己喜好响应主机的信息。</p><p>&emsp;&emsp;以上就是整体思路，你甚至可以根据这个思路自己实现Modbus通讯的从机部分。接下来就是FreeModbus同样思路实现方式的讲解</p><h2 id="4-2-FreeModbus库通讯实现讲解-RTU模式为例"><a href="#4-2-FreeModbus库通讯实现讲解-RTU模式为例" class="headerlink" title="4.2 FreeModbus库通讯实现讲解(RTU模式为例)"></a>4.2 FreeModbus库通讯实现讲解(RTU模式为例)</h2><ol><li>Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态</li><li>串口接收中断 在初始化状态下，打开定时器</li><li>等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将<code>eMBPoll</code>的 事件状态机 置为 初始化。</li><li><strong>以上就是初始化完成，接下来就是数据收发的流程了</strong></li><li>串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。</li><li>每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。</li><li>当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态</li><li>由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。</li><li>eMBPoll的 事件状态机 为<code>Frame received</code>接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功</li><li>核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 <code>MB_EIO</code>的错误。</li><li>经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为<code>Execute function</code> 执行数据函数(事件)。开始对数据进行处理。</li><li>这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。</li><li>如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 <code>功能码|0x80 + 错误代码</code>。</li><li>举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。</li><li>在处理完后会返回一个enum状态值。如果状态 不为<code>MB_ENOERR</code>，即内部使用的错误代码，根据内部使用的<code>enum</code>错误代码，<code>switch</code>生成 对外的错误代码</li><li>返回的CRC会在发送前先把CRC校验完成。</li><li>发送前，检查能不能数据接收，能接收则报硬件错误<code>MB_EIO</code>，因为协议规定只能单向收发</li><li>发送一个字节数据，然后开启发送中断，一直发送，直到完成</li><li>发送完成后，将 eMBPoll的 事件状态机 置为 发送完成</li><li>事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲</li></ol><p>&emsp;&emsp;以上就是FreeModbus库实现<code>Modbus RTU</code>通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。这个库源码写的很好，如果是嵌入式新手，这份源码还是很推荐看的。</p><p>&emsp;&emsp;如果顺着程序缕是能看得懂的，这里再留一份函数==笔记==，方便小白初次看时疑惑，可查阅一下。</p><h2 id="4-3-数据单元处理功能函数"><a href="#4-3-数据单元处理功能函数" class="headerlink" title="4.3 数据单元处理功能函数"></a>4.3 数据单元处理功能函数</h2><p>这里的写法思路分为3个部分：</p><ul><li>第一部分函数用于对应FreeModbus库编写的处理函数<ul><li>例如，库里面处理到最后，总是地址+1,；可以在这里去掉</li><li>这里用来区分 读、写 </li></ul></li><li>第二部分函数用于自己应用层的地址约束<ul><li>并可以对不同地址块进行不同处理</li></ul></li><li>第三部分函数用于具体地址的详细操作</li></ul><h2 id="4-3-1-数据单元初步处理"><a href="#4-3-1-数据单元初步处理" class="headerlink" title="4.3.1 数据单元初步处理"></a>4.3.1 数据单元初步处理</h2><p>&emsp;&emsp;编写具体如下四个函数对应FreeModbus库的处理：</p><ul><li>eMBRegCoilsCB</li><li>eMBRegHoldingCB</li><li>eMBRegDiscreteCB</li><li>eMBRegInputCB<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  eMBRegCoilsCB</span></span><br><span class="line"><span class="comment">* 功  能 :  线圈回复函数</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  *pucRegBuffer : 要添加到协议中的数据</span></span><br><span class="line"><span class="comment">*           usAddress     : 线圈地址(PLC地址)</span></span><br><span class="line"><span class="comment">*           usNRegs       : 要访问线圈的个数</span></span><br><span class="line"><span class="comment">*           eMode         : 访问类型（MB_REG_READ为读线圈状态，MB_REG_WRITE为写线圈）</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus       : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">eMBRegCoilsCB</span><span class="params">( UCHAR * pucRegBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                            USHORT usAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">                            USHORT usNCoils, </span></span></span><br><span class="line"><span class="function"><span class="params">                            eMBRegisterMode eMode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eMBErrorCode    eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    usAddress--;<span class="comment">// 由PLC地址转为协议地址  </span></span><br><span class="line">    <span class="keyword">switch</span> ( eMode )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MB_REG_READ:</span><br><span class="line">            eStatus = AppFMD_RdCoils(usNCoils,usAddress,pucRegBuffer);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MB_REG_WRITE:</span><br><span class="line">            eStatus = AppFMD_WrCoils(usNCoils,usAddress,pucRegBuffer);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eStatus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  eMBRegHoldingCB</span></span><br><span class="line"><span class="comment">* 功  能 :  保持寄存器回复函数</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  *pucRegBuffer : 要添加到协议中的数据</span></span><br><span class="line"><span class="comment">*           usAddress     : 寄存器地址</span></span><br><span class="line"><span class="comment">*           usNRegs       : 访问寄存器的个数</span></span><br><span class="line"><span class="comment">*           eMode         : 访问类型（MB_REG_READ为读保持寄存器，MB_REG_WRITE为写保持寄存器）</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus       : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">eMBRegHoldingCB</span><span class="params">(   UCHAR * pucRegBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                USHORT usAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                                USHORT usNRegs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                eMBRegisterMode eMode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eMBErrorCode    eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    usAddress--;<span class="comment">// 由PLC地址转为协议地址</span></span><br><span class="line">    <span class="keyword">if</span> (eMode == MB_REG_READ)</span><br><span class="line">        eStatus = AppFMD_RdRegs(usNRegs,usAddress,pucRegBuffer);</span><br><span class="line">    <span class="keyword">if</span>(eMode == MB_REG_WRITE)</span><br><span class="line">        eStatus = AppFMD_WrRegs(usNRegs,usAddress,pucRegBuffer);</span><br><span class="line">    <span class="keyword">return</span> eStatus; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-2-线圈和寄存器处理"><a href="#4-3-2-线圈和寄存器处理" class="headerlink" title="4.3.2 线圈和寄存器处理"></a>4.3.2 线圈和寄存器处理</h3><p>&emsp;&emsp;根据 <strong>4.3.1</strong>，只编写可读写线圈和寄存器的函数，具体对应函数如下：</p><ul><li>eMBErrorCode AppFMD_RdCoils(uint32_t si_num, uint32_t uiAddr, uint8_t *puc_txpointer)</li><li>eMBErrorCode AppFMD_WrCoils(uint32_t si_num, uint32_t uiAddr,uint8_t *puc_txpointer)</li><li>最好在这块函数进行总的地址划分<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  </span></span><br><span class="line"><span class="comment">* 功  能 :  </span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  si_num          : 待读的 线圈|寄存器 个数</span></span><br><span class="line"><span class="comment">*           uiAddr          : 地址索引  从0起始</span></span><br><span class="line"><span class="comment">*           *puc_txpointer  : 输出缓存</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus         : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">AppFMD_RdRegs</span><span class="params">(<span class="keyword">uint32_t</span> lNum, <span class="keyword">uint32_t</span> ulAddr,<span class="keyword">uint8_t</span> *puc_txpointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    eMBErrorCode eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部参数</span></span><br><span class="line">    <span class="keyword">if</span>(ulAddr&lt;<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(lNum)</span><br><span class="line">        &#123;</span><br><span class="line">            puc_txpointer = BuiltReadWord(ulAddr, puc_txpointer);</span><br><span class="line">            lNum -= <span class="number">1</span>; </span><br><span class="line">            ulAddr += <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户自定义参数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ulAddr&gt;=<span class="number">1000</span> &amp;&amp; ulAddr&lt;<span class="number">1400</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(lNum)</span><br><span class="line">        &#123;</span><br><span class="line">            puc_txpointer = BuiltReadWord_Double(ulAddr, puc_txpointer);</span><br><span class="line">            lNum -= <span class="number">2</span>; </span><br><span class="line">            ulAddr += <span class="number">2</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        eStatus = MB_ENOREG;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> eStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-3-用户自定义的-线圈-amp-寄存器-处理"><a href="#4-3-3-用户自定义的-线圈-amp-寄存器-处理" class="headerlink" title="4.3.3 用户自定义的 线圈 &amp; 寄存器 处理"></a>4.3.3 用户自定义的 线圈 &amp; 寄存器 处理</h3><p>&emsp;&emsp;根据 <strong>4.3.2</strong>，在对应的函数写具体到某个地址位的操作就行了。</p><h1 id="五、通讯报文讲解"><a href="#五、通讯报文讲解" class="headerlink" title="五、通讯报文讲解"></a>五、通讯报文讲解</h1><p>&emsp;&emsp;这里是方便没接触过Modbus的人，或者是长时间没用急用，直接来查阅Modbus报文的；好清楚是哪里出的问题(主机 or 从机？)。</p><h2 id="5-1-报文格式总结"><a href="#5-1-报文格式总结" class="headerlink" title="5.1 报文格式总结"></a>5.1 报文格式总结</h2><p>&emsp;&emsp;首先，如果从机是返回很短的(报错)报文，直接看功能码位，例如 0x83 ；去掉 &amp; 0x80 的操作，那就是 功能码 0x03 出现错误。</p><ul><li>主机的读取数据命令(长度)是固定的：ID + 功能码 + 地址 + 数据长度 + CRC16</li><li>从机返回的数据格式不是固定的：<ul><li>读取长度为1：ID + 功能码 + 数据长度 + 数据1 + CRC16</li><li>读取长度为2：ID + 功能码 + 数据长度 + 数据1 + 数据2 + CRC16</li></ul></li></ul><hr><ul><li>主机的写入数据格式不是固定的</li><li>从机返回数据格式(长度)是固定的(与上面的相反)</li></ul><h2 id="5-2-报文举例"><a href="#5-2-报文举例" class="headerlink" title="5.2 报文举例"></a>5.2 报文举例</h2><p>功能码0x03，读可读写模拟量寄存器：</p><ul><li>(主机)发送命令格式：</li><li>[设备地址] [功能码03] [起始寄存器地址高8位] [低8位] [读取的寄存器数高8位] [低8位] [CRC校验低8位] [CRC校验高8位]</li><li>例：[11][03][00][6B][00][03][CRC低][CRC高]</li><li>意义如下：<ul><li>11：设备地址，例子中的地址是11；</li><li>03：读模拟量的命令号固定为03，这是Modbus协议规定的。</li><li>00、6B：起始地址高8位（00）、低8位（6B）：表示想读取的模拟量的起始地址，比如例子中的起始地址为107。这个006B表示一个完整的地址，注意这里的地址是高8位在前，低8位在后。</li><li>00、03：寄存器数高8位（00）、低8位（03）：表示从起始地址开始读多少个模拟量（返回的每一个模拟量是用两个字节表示的）。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节同时这里的地址也是高8位在前，低8位在后。</li><li>[CRC低][CRC高]：帧尾的CRC-16校验，尤其需要注意的一点是校验结果的低8位在前，高8位在后，这个顺序不同于起始地址以及读取深度的地址顺序。</li></ul></li></ul><hr><ul><li>(从机)设备响应：</li><li>[设备地址] [命令号03] [返回的字节个数][数据1][数据2]…[数据n][CRC校验的低8位] [CRC校验的高8位]</li><li>例：[11][03][06][02][2B][00][00][00][64][CRC低][CRC高]</li><li>意义如下：<ul><li>11：设备地址（从机地址）；</li><li>03：功能码；</li><li>06：返回的字节个数（不高扩两字节的校验码）：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。<br>数据1…n：其中[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。</li><li>[CRC低][CRC高]：CRC校验同上。</li></ul></li></ul><h1 id="六、基于W5500的Modbus-TCP"><a href="#六、基于W5500的Modbus-TCP" class="headerlink" title="六、基于W5500的Modbus TCP"></a>六、基于W5500的Modbus TCP</h1><p>&emsp;&emsp;如果是理解了上面源码的讲解，那么这里将会异常简单。由于W5500芯片，集成了硬件TCP/IP协议，数据接收完成与否的判断，也在W5500内完成；因此，FreeModbus库内的TCP函数大部分都不需要用到(例如，初始化函数)，只需要FreeModbus库的 TCP_Poll事件状态机(初始化要置位事件状态)。</p><p>&emsp;&emsp;先根据W5500的数据手册、或者例程，先编写好W5500的通讯驱动；程序中，读取W5500中断，如果有产生接收完成中断，就把TCP_Poll事件状态机置为接收完成，然后接下来就是TCP_Poll自己处理了，沿用同一套的数据单元处理功能函数。这样就完成了！</p><h1 id="七、FreeModbus库-拓展"><a href="#七、FreeModbus库-拓展" class="headerlink" title="七、FreeModbus库_拓展"></a>七、FreeModbus库_拓展</h1><p>&emsp;&emsp;Freemodbus库虽然写得很好，但是它的思路框架是以1个通讯接口实现的。如果是在 <code>Modbus主机</code> 一节提到的：有多串口Modbus通讯，共享一套地址处理数据。当你多串口RTU通讯，且波特率不相同，定时器的配置也就要变动一下。甚至还有，一个实际产品，它不仅有Modbus 多串口通讯，它还可能要有Modbus TCP通讯，而且也还是共享一套地址处理数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Modbus" scheme="http://shatang.github.io/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>Modbus协议_概念讲解</title>
    <link href="http://shatang.github.io/2020/05/30/Modbus%E5%8D%8F%E8%AE%AE-%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3/"/>
    <id>http://shatang.github.io/2020/05/30/Modbus协议-概念讲解/</id>
    <published>2020-05-30T02:50:13.000Z</published>
    <updated>2020-05-30T02:50:53.186Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯</p><a id="more"></a><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>&emsp;&emsp;Modbus协议 是一个请求/应答协议，发起请求的为Master（client），响应请求的为Slave（server）;Modbus协议包括ASCII、RTU、TCP三种报文类型，并没有规定物理层。</p><p>&emsp;&emsp;标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。</p><hr><ul><li><strong>Master端发出读数据请求消息，Slave端接收到正确消息后，就发送对应数据到Master端以响应请求；</strong></li><li><strong>Master端发出写数据请求消息，Slave端接收到正确消息后，就修改Slave端的数据；</strong></li></ul><p>先发请求，再接收响应，从而实现 主机 对 从机 读/写操作。</p><h1 id="二、报文格式-通用部分"><a href="#二、报文格式-通用部分" class="headerlink" title="二、报文格式_通用部分"></a>二、报文格式_通用部分</h1><ul><li>(<strong>ADU</strong>)报文，指的是一串完整的指令数据；一个报文就是一帧数据，一个数据帧就一个报文</li><li>(<strong>MBAP</strong>)报文头，即报文的一部分，用于识别。当然也有些是部分数据在报文尾部，例如CRC数据校验。</li><li>(<strong>PDU</strong>)协议数据单元，这部分就是通信中的数据部分了。</li></ul><p>举例如下：</p><img src="/2020/05/30/Modbus协议-概念讲解/0.jpg" title="Modbus RTU报文模型"><p>&emsp;&emsp;由于报文类型的不同，报文之间也存在一些差异。先讲解通用的 功能码 &amp; 错误代码 部分。</p><h2 id="2-1-Modbus部分功能码"><a href="#2-1-Modbus部分功能码" class="headerlink" title="2.1 Modbus部分功能码"></a>2.1 Modbus部分功能码</h2><table><thead><tr><th>功能码（十六进制）</th><th>中文名称</th><th>位操作/字节操作</th><th>操作数量</th><th>错误功能码(&amp;0x80)</th></tr></thead><tbody><tr><td>01</td><td>读线圈状态</td><td>位操作</td><td>单个或多个</td><td>0x81</td></tr><tr><td>02</td><td>读离散状态</td><td>位操作</td><td>单个或多个</td><td>0x82</td></tr><tr><td>03</td><td>读保持寄存器</td><td>字节操作</td><td>单个或多个</td><td>0x83</td></tr><tr><td>04</td><td>读输入寄存器</td><td>字节操作</td><td>单个或多个</td><td>0x84</td></tr><tr><td>05</td><td>写单个线圈</td><td>位操作</td><td>单个</td><td>0x85</td></tr><tr><td>06</td><td>写单个保持寄存器</td><td>字节操作</td><td>单个</td><td>0x86</td></tr><tr><td>0F</td><td>写多个线圈</td><td>位操作</td><td>多个</td><td>0x8F</td></tr><tr><td>10</td><td>写多个保持寄存器</td><td>字节操作</td><td>多个</td><td>0x90</td></tr></tbody></table><p>&emsp;&emsp;Modbus协议规定，从机当执行对应功能码处理时发生错误，响应主机时需要将 <code>功能码 & 0x80</code> 将其返回。</p><h2 id="2-2-错误代码表"><a href="#2-2-错误代码表" class="headerlink" title="2.2 错误代码表"></a>2.2 错误代码表</h2><table><thead><tr><th>代码</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>01</td><td>非法功能</td><td>对于服务器（或从站）来说，询问中接收到的功能码是不可允许的操作，可能是因为功能码仅适用于新设备而被选单元中不可实现同时，还指出服务器（或从站）在错误状态中处理这种请求，例如：它是未配置的，且要求返回寄存器值。</td></tr><tr><td>02</td><td>非法数据地址</td><td>对于服务器（或从站）来说，询问中接收的数据地址是不可允许的地址，特别是参考号和传输长度的组合是无效的。对于带有100个寄存器的控制器来说，偏移量96和长度4的请求会成功，而偏移量96和长度5的请求将产生异常码02。</td></tr><tr><td>03</td><td>非法数据值</td><td>对于服务器（或从站）来说，询问中包括的值是不可允许的值。该值指示了组合请求剩余结构中的故障。例如：隐含长度是不正确的。modbus协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。</td></tr><tr><td>04</td><td>从站设备故障</td><td>当服务器（或从站）正在设法执行请求的操作时，产生不可重新获得的差错。</td></tr><tr><td>05</td><td>确认</td><td>与编程命令一起使用，服务器（或从站）已经接受请求，并且正在处理这个请求，但是需要长持续时间进行这些操作，返回这个响应防止在客户机（或主站）中发生超时错误，客户机（或主机）可以继续发送轮询程序完成报文来确认是否完成处理。</td></tr><tr><td>07</td><td>从属设备忙</td><td>与编程命令一起使用，服务器（或从站）正在处理长持续时间的程序命令，当服务器（或从站）空闲时，客户机（或主站）应该稍后重新传输报文。</td></tr><tr><td>08</td><td>存储奇偶性差错</td><td>与功能码20和21以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器（或从站）设备读取记录文件，但在存储器中发现一个奇偶校验错误。客户机（或主机）可重新发送请求，但可以在服务器（或从站）设备上要求服务。</td></tr><tr><td>0A</td><td>不可用网关路径</td><td>与网关一起使用，指示网关不能为处理请求分配输入端口值输出端口的内部通信路径，通常意味着网关是错误配置的或过载的。</td></tr><tr><td>0B</td><td>网关目标设备响应失败</td><td>与网关一起使用，指示没有从目标设备中获得响应，通常意味着设备未在网络中。</td></tr><tr><td>## 2.3 Modbus 寄存器地址分配</td><td></td><td></td></tr><tr><td>寄存器信息地址(PLC 地址)</td><td>适用功能码（十六进制）</td><td>寄存器种类</td></tr><tr><td>—-</td><td>—</td><td>—-</td></tr><tr><td>00001-09999</td><td>01 05 15</td><td>线圈状态</td></tr><tr><td>10001-19999</td><td>02</td><td>(开关)输入状态</td></tr><tr><td>30001-39999</td><td>04</td><td>输入寄存器</td></tr><tr><td>40001-49999</td><td>03 06 16</td><td>保持寄存器</td></tr><tr><td>## 2.4 小总结(心得)</td><td></td><td></td></tr><tr><td>&emsp;&emsp;一般情况下，只需要看一下返回的功能码就行了，错误代码可以不用看。Modbus通讯发生错误，往往出现的情况如下:</td><td></td><td></td></tr><tr><td>1. Modbus主机(PLC)读取有问题，例如读的地址写错，读的数据长度写错</td><td></td><td></td></tr><tr><td>2. Modbus从机压根就没写该 功能码 0r 地址 对应的处理，当主机对其操作自然报错。</td><td></td><td></td></tr><tr><td>3. 并不是符合Modbus协议规范的报文就一定通信正确，只能说是通讯成功，因为它返回给你一条报错指令。通讯无响应，说明是主机本身发的数据就有问题；通信有响应(可能返回错误报文)，说明该地址不可用，主机读歪了或者从机压根没写该功能处理。</td><td></td><td></td></tr></tbody></table><h1 id="三、各报文格式-详细解析"><a href="#三、各报文格式-详细解析" class="headerlink" title="三、各报文格式_详细解析"></a>三、各报文格式_详细解析</h1><p>&emsp;&emsp;每个报文都与其他报文格式有一定区分。<strong>在Modbus从机的角度看</strong>，讲解一下他们之间的类似之处。</p><ul><li>三者功能码是通用的</li><li>RTU 和 TCP的报文十分类似。TCP由于是可靠的协议，且通过IP连接，相比RTU就少了 设备ID &amp; CRC数据校验。<strong>数据单元部分</strong>是完全一样的。</li><li>RTU &amp; ASCII 都是通过串口通讯的，因此都是需要 定时器。但是定时器具体用法不相同。</li></ul><p><strong>Ps：</strong><br>ASCII模式，国内基本没用到。常用的是 RTU &amp; TCP 模式。</p><h2 id="3-1-RTU模式"><a href="#3-1-RTU模式" class="headerlink" title="3.1 RTU模式"></a>3.1 RTU模式</h2><p>&emsp;&emsp;Modbus RTU协议中没有明显的开始符和结束符，而是通过帧与帧之间的间隔时间来判断的。如果在指定的时间内，没有接收到新的字符数据，那么就认为新的帧接收完毕。接下来就是处理数据。Modbus通过时间来判断帧接收完成，自然需要 MCU 的定时器配合(3.5T)。<br>| 设备地址 | 功能代码 | 数据 | CRC校验 | 结束符(实际报文可没有这个！)<br>| — | —- | — | —- | —<br>| 1个字节 | 1个字节 | n个字节 | 2个字节 | T1-T2-T3-T4</p><ul><li><strong>地址码</strong>：每个从机都必须有唯一的地址码ID（从1到247，0是广播地址），并且只有符合地址码的从机才能响应回送。当从机回送信息时，相应的地址码表明该信息来自于何处。</li><li><strong>功能码</strong>：主机发送的功能码告诉从机执行什么任务。ModBus通讯规约定义功能号为1到127。表2-1列出部分常用功能码，以备查询。</li><li><strong>数据区</strong>：数据区包含需要从机执行什么动作或由从机采集的返送信息。应答包中，数据包括了数据字节长度+数据值，请求包中数据只包含数据值。</li><li><strong>校验码</strong>：主机或从机可用校验码进行判别接收信息是否出错。</li></ul><hr><ul><li>从Modbus主机角度上看<ul><li>使用RTU模式，<strong>消息发送至少要以3.5个字符时间的停顿间隔开始</strong>（如上图的T1-T2-T3-T4所示）。传输的第一个域是设备地址。可以使用的传输字符是十六进制的0…9,A…F。网络设备不断侦测网络总线，包括停顿间隔时间内。当第一个域（地址域）接收到，每个设备都进行解码以判断是否发往自己的。在最后一个传输字符之后，一个至少3.5个字符时间的停顿标定了消息的结束。一个新的消息可在此停顿后开始。</li><li>一旦连续发送间隔 小于3.5T，就会对从机数据接收造成 <strong>数据黏合</strong>。</li></ul></li><li>从Modbus从机角度上看<ul><li><strong>整个消息帧必须作为一连续的流传输，如果在帧完成之前有超过1.5个字符时间的停顿时间则为非法帧；</strong>如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续，这将导致一个错误，因为在最后的CRC域的值不可能是正确的。即<strong>帧之间的间隔必须大于3.5T，帧内字符的间隔必须小于1.5T</strong>。实际应用中1.5T一般不处理，只采用3.5T进行处理（FreeModBus开源代码就是这样)。</li><li>FreeModbus库，采用的是3.5T作为判断。只要是超过3.5T，就视为两个数据帧处理。当然，如果主机发送数据异常，让 某条报文中间字符发送相隔时间超过3.5T，那么就会造成 1条正确报文被分割成2条报文，造成 数据裂开。</li><li>数据裂开一般不会出现。采用FreeModbus库时，正常情况下，高波特率会对3.5T的值进行限制。如果解开该限制，导致3.5T实际值太小(高波特率转换计算出来)，这时候主机的字符发送间隔慢一点，从机将无法识别到正确的报文(数据被分裂)。</li></ul></li></ul><h2 id="3-2-ASCII模式"><a href="#3-2-ASCII模式" class="headerlink" title="3.2 ASCII模式"></a>3.2 ASCII模式</h2><p>&emsp;&emsp;除了数据域为ASCII码，其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码下个域（地址域）来判断是否发给自己的。消息中字符间发送的时间间隔(MCU 的定时器)最长不能超过1秒，否则接收的设备将认为传输错误。</p><table><thead><tr><th>起始位</th><th>设备地址</th><th>功能代码</th><th>数据</th><th>LRC校验</th><th>结束符</th></tr></thead><tbody><tr><td>：</td><td>2个字符</td><td>2个字符</td><td>n个字符</td><td>2个字符</td><td>2个字符</td></tr></tbody></table><p>&emsp;&emsp;<strong>使用ASCII模式，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）</strong></p><h2 id="3-3-TCP-IP模式"><a href="#3-3-TCP-IP模式" class="headerlink" title="3.3 TCP/IP模式"></a>3.3 TCP/IP模式</h2><p>&emsp;&emsp;与MODBUS RTU相比，少了校验域和地址码，其中地址码被放到MBAP报文头里面了(即 00 00)，没有校验域是因为TCP本身就有校验所以省略了。</p><img src="/2020/05/30/Modbus协议-概念讲解/1.png" title="Modbus TCP报文"><p>报文头MBAP，长度为7字节，组成如下：</p><ul><li>事务处理标识    ：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文(主机要注意的点，从机不对该数据进行识别处理)。</li><li>协议标识符    ：00 00表示ModbusTCP协议。</li><li>长度    ：表示接下来的数据长度，单位为字节。</li><li>单元标识符    ：可以理解为设备地址。</li></ul><table><thead><tr><th>事务处理标识</th><th>协议标识</th><th>长度</th><th>单元标识符</th><th>功能代码</th><th>数据</th></tr></thead><tbody><tr><td>2字节</td><td>2字节</td><td>2字节</td><td>1字节</td><td>1字节</td><td>n字节</td></tr></tbody></table><h1 id="四、调试工具"><a href="#四、调试工具" class="headerlink" title="四、调试工具"></a>四、调试工具</h1><ul><li>如果你做的是Modbus Master，可以使用modbus slave工具模拟从设备来调试，该工具下载地址：<a href="http://www.cr173.com/soft/21410.html" target="_blank" rel="noopener">Modbus Slave</a></li><li>如果你做的是Modbus Slave，可以使用modbus poll工具模拟主设备来调试，该工具下载地址：<a href="http://www.cr173.com/soft/21405.html" target="_blank" rel="noopener">Modbus Poll</a></li></ul><p>以上两个工具的使用方法，可以参考此博客：<a href="https://blog.csdn.net/byxdaz/article/details/77979114" target="_blank" rel="noopener">Modbus测试工具ModbusPoll与Modbus Slave使用方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Modbus" scheme="http://shatang.github.io/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>这段时间的总结</title>
    <link href="http://shatang.github.io/2020/05/30/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://shatang.github.io/2020/05/30/这段时间的总结/</id>
    <published>2020-05-30T02:34:34.000Z</published>
    <updated>2020-05-30T02:40:33.066Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;好久没更新博客了= =？</p><p>&emsp;&emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。</p><p>&emsp;&emsp;然后偶然，又和高中老同学聊了聊；这回会持续更新，而且要加很多新内容！！！</p><p>&emsp;&emsp;继续加油，奥力给！</p><img src="/2020/05/30/这段时间的总结/1.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;好久没更新博客了= =？&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="生活" scheme="http://shatang.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>野指针</title>
    <link href="http://shatang.github.io/2020/03/15/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    <id>http://shatang.github.io/2020/03/15/野指针/</id>
    <published>2020-03-15T07:20:24.000Z</published>
    <updated>2020-03-15T08:11:21.146Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、野指针由来"><a href="#一、野指针由来" class="headerlink" title="一、野指针由来"></a>一、野指针由来</h1><h2 id="1-1-野指针概念-简述"><a href="#1-1-野指针概念-简述" class="headerlink" title="1.1 野指针概念(简述)"></a>1.1 野指针概念(简述)</h2><p>概述：<strong>“野指针”不是NULL指针，是指向“垃圾”内存的指针。</strong>(内存能不能用另外一回事)</p><ol><li>(局部)指针变量没有初始化</li><li>使用已经释放后的指针</li><li>指针所指向的变量在指针之前被销毁</li></ol><h2 id="1-2-野指针概念-专业描述"><a href="#1-2-野指针概念-专业描述" class="headerlink" title="1.2 野指针概念(专业描述)"></a>1.2 野指针概念(专业描述)</h2><ul><li><p><strong>指针未初始化</strong><br>&emsp;&emsp;指针变量在定义时不会自动初始化成空指针，而是随机的一个值，可能指向任意空间，这就使得该指针成为野指针。因此指针在初始化时要么指向一个合理的地址，要么初始化为<code>NULL</code>。<strong>即使不初始化，调用指针前，一定要赋值！</strong></p></li><li><p><strong>指针指向的变量被<code>free</code>或<code>delete</code>后没有置为<code>NULL</code></strong><br>&emsp;&emsp;在调用free或delete释放空间后，指针指向的内容被销毁，空间被释放，但是指针的值并未改变，仍然指向这块内存，这就使得该指针成为野指针。因此在调用<code>free</code>或<code>delete</code>之后，应将该指针置为<code>NULL</code>。</p></li><li><p><strong>指针操作超过所指向变量的生存期</strong><br>&emsp;&emsp;当指针指向的变量的声明周期已经结束时，如果指针仍然指向这块空间，就会使得该指针成为野指针。这种错误很难防范，只有养成良好的编程习惯，才能避免这类情况发生。</p></li></ul><h2 id="1-3-野指针的要点-简单描述"><a href="#1-3-野指针的要点-简单描述" class="headerlink" title="1.3 野指针的要点(简单描述)"></a>1.3 野指针的要点(简单描述)</h2><ol><li>野指针通常是因为指针变量中保存的值不是一个合法的内存地址而造成的</li><li>野指针不是NULL，是一个指向不可用内存的指针</li><li>C语言中没有方法可以判断是否为野指针(可替换成NULL指针，NULL指针不容易弄错，可以通过if来判断是否为NULL指针)</li></ol><h2 id="1-4-野指针的要点-深度描述"><a href="#1-4-野指针的要点-深度描述" class="headerlink" title="1.4 野指针的要点(深度描述)"></a>1.4 野指针的要点(深度描述)</h2><blockquote><p><strong>野指针只能避免而无法判断</strong></p></blockquote><p>&emsp;&emsp;无法判断一个指针是否为野指针，因为野指针本身有值，指向某个内存空间，只是这个值是随机的或错误的。</p><p><strong><font color="red">Ps：</font>空指针并非野指针</strong>，它具有特殊性和确定性，可以进行判断；因此要避免在程序中出现野指针，可以做完操作及时将指针指向<code>NULL</code>。</p><blockquote><p><strong>野指针并非立马让系统出事</strong></p></blockquote><p>&emsp;&emsp;指针也是数据，首先如果是局部的，不置空也没关系反正用不到了；如果是全局的，得用的时候释放了可能也会立马再次新赋值，如果不是那肯定需要重置为null，这也是方便你后面的判断是否需要赋值，<strong>如果你再次用不到，那么(不重置)就完全不影响程序的健壮性</strong>。但是，如果 <strong>再调该(野)指针就会可能出现问题！</strong> 有的可能比较复杂不一定开始就初始化，那你在某个地方用的时候会判断是否为空，然后给它赋值。就像很多做逻辑判断的bool，初始也会有值，如果没值，那你就看系统给的初始值，区别就是指针如果没初始化，然后对指针进行操作(调用)，可能会导致崩溃。也就是说，野指针并不是直接让系统出事，而是自己无意识产生野指针但还调用的操作才是让系统出事的真正原因！</p><blockquote><p><strong>野指针的错误是严重的</strong></p></blockquote><ol><li>指向不可访问的地址<br>&emsp;&emsp;危害：触发段错误。</li></ol><hr><ol start="2"><li>指向一个可用的，但是没有明确意义的空间<br>&emsp;&emsp;危害：程序可以正确运行，但通常这种情况下，我们就会认为我们的程序是正确的没有问题的，然而事实上就是有问题存在，所以这样就掩盖了我们程序上的错误。</li></ol><hr><ol start="3"><li>指向一个可用的，而且正在被使用的空间<br>&emsp;&emsp;危害：如果我们对这样一个指针进行解引用，对其所指向的空间内容进行了修改，但是实际上这块空间正在被使用，那么这个时候变量的内容突然被改变，当然就会对程序的运行产生影响，因为我们所使用的变量已经不是我们所想要使用的那个值了。通常这样的程序都会崩溃，或者数据被损坏。</li></ol><h1 id="二、未初始化指针的神奇操作"><a href="#二、未初始化指针的神奇操作" class="headerlink" title="二、未初始化指针的神奇操作"></a>二、未初始化指针的神奇操作</h1><p>&emsp;&emsp;指针未初始化，<strong>系统一般会自动分配内存给未初始化的指针，但也有时候指向<code>NULL</code>。</strong>由于太过玄学，建议直接初始化置<null>或一个有用的内存。</null></p><h2 id="2-1-非字符串指针未初始化"><a href="#2-1-非字符串指针未初始化" class="headerlink" title="2.1 非字符串指针未初始化"></a>2.1 非字符串指针未初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">20</span>,*p;    <span class="comment">//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    p=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    *p=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x7ffe4b25dc04</span>：<span class="number">20</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0xfaa010</span>：<span class="number">0</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0xfaa010</span>：<span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="2-2-字符串指针未初始化"><a href="#2-2-字符串指针未初始化" class="headerlink" title="2.2 字符串指针未初始化"></a>2.2 字符串指针未初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a=<span class="string">"ShaTang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p;    <span class="comment">//这里定义了一个字符串指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p\n"</span>, a, p);</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line">    p=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShaTang-&gt;(nil)</span><br><span class="line">ShaTang-&gt;(nil)</span><br><span class="line">ShaTang-&gt;<span class="number">0x4006d4</span>：ShaTang</span><br><span class="line">ShaTang-&gt;<span class="number">0x134a010</span>：</span><br><span class="line">ShaTang-&gt;<span class="number">0x4006f1</span>：Zhu</span><br></pre></td></tr></table></figure><p><strong><font color="red">Ps：</font></strong>观察2.1和2.2，就会发现字符(数组)类型，引用数据和查看地址都是用指针。<br>&emsp;&emsp;编译器此时帮我们把 未初始化指针 指向 <code>NULL</code>。我们对野指针的定义：<strong>指针指向垃圾(未知)的内存</strong>；在这里，我们就不能称它为野指针。</p><h2 id="2-3-例1变形的玄学"><a href="#2-3-例1变形的玄学" class="headerlink" title="2.3 例1变形的玄学"></a>2.3 例1变形的玄学</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>  *d1,*p;<span class="comment">//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, d1);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a,d1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>-&gt;<span class="number">0x7ffde8b16b80</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x4004f0</span></span><br><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x4004f0</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;<span class="number">0x7fff890b4780</span></span><br><span class="line">-&gt;(nil)</span><br><span class="line">-&gt;(nil)</span><br><span class="line">-&gt;(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器此时分配内存给 未初始化指针，还是玄学分配,有时候置<code>NULL</code>(虚_野指针)，有时候又分配一块内存(真_野指针)。因此需要注意 <strong>要指针的初始化，或者调用时一定要(检查)赋值</strong>，带来不可估量的Bug。<br>&emsp;&emsp;编译器1和编译器2对 例2.1 编译的结果都是一样的，但是对 例2.3 的编译结果却各不相同。但是反过来，只是简单变动，编译器就能玄学分配，这是很恐怖的事情。</p><h1 id="三、野指针概念案例"><a href="#三、野指针概念案例" class="headerlink" title="三、野指针概念案例"></a>三、野指针概念案例</h1><p>&emsp;&emsp;按照野指针的概念，举如下例子</p><h2 id="例1：指针变量没有初始化"><a href="#例1：指针变量没有初始化" class="headerlink" title="例1：指针变量没有初始化"></a>例1：指针变量没有初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                           <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"><span class="comment">//    strcpy(s1 , s2);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0x7fffea4889f0</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里不采用<code>strcpy</code>举例说明 指针变量没有初始化 的问题，后面单独一节再讲解原因。<br>&emsp;&emsp;这里很明显，在编译器2上，<code>printf</code>打印 未初始化的指针，出现段错误(实际指针 指向<code>NULL</code>)。而编译器1，则是通过了，并得知编译器1给 未初始化的指针 赋了一块随机内存。你的代码在不同的编译器上，有的报错，有的通过，这也是野指针带来的危害。</p><h2 id="例2：使用已经释放后的指针-释放后没改指向NULL"><a href="#例2：使用已经释放后的指针-释放后没改指向NULL" class="headerlink" title="例2：使用已经释放后的指针(释放后没改指向NULL)"></a>例2：使用已经释放后的指针(释放后没改指向NULL)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s);</span><br><span class="line">    <span class="built_in">strcpy</span>(s, <span class="string">"Delphi Tang"</span>);</span><br><span class="line">    func(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);      <span class="comment">//OOPS!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1f0e010</span></span><br><span class="line">Delphi Tang</span><br><span class="line"></span><br><span class="line"><span class="number">0x1f0e010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序是可以正常执行的。但是在执行结果第三行：打印野指针指向的内存为空白。首先我们先重新明确上面的概念：<strong>“野指针”不是NULL指针，是指向“垃圾”内存的指针。</strong>内存的申请释放和指针没有太大关系，内存释放后，<code>printf</code>能正常打印出指针指向的地址，但是地址所在的内存内容就有问题了(为下次调用埋雷)。</p><h2 id="例3：指针所指向的变量在指针之前被销毁"><a href="#例3：指针所指向的变量在指针之前被销毁" class="headerlink" title="例3：指针所指向的变量在指针之前被销毁"></a>例3：指针所指向的变量在指针之前被销毁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"Delphi Tang"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);  <span class="comment">//OOPS!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我测试用的多个编译器，结果都不相同；局部变量在函数执行完，内存是已经释放的，还调用指向该内存的指针，即野指针调用；造成的结果在每个编译器都不太相同。</p><h1 id="四、strcpy引发的段错误"><a href="#四、strcpy引发的段错误" class="headerlink" title="四、strcpy引发的段错误"></a>四、<code>strcpy</code>引发的段错误</h1><p>&emsp;&emsp;很多人讲解 未初始化的指针 导致的 野指针的时候，很多实例代码都是用到<code>strcpy</code>来讲解 指针未初始化 的问题。这是很不严谨的，从上面的案例分析，稍微改下代码，系统就能分配一块内存 或者 置<code>NULL</code>。</p><h2 id="4-1-错误的例子1"><a href="#4-1-错误的例子1" class="headerlink" title="4.1 错误的例子1"></a>4.1 错误的例子1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                             <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Shatang"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shatang</span><br><span class="line"><span class="number">0x7ffc79832540</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>在编译器2环境下，注释<code>strcpy(s1 , s2);</code>和<code>printf("%s\n", s1);</code>，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就说，用<code>strcpy</code>来举例 未初始化指针 的问题是有问题的。当编译器给 未初始化指针 置<code>NULL</code>时，这时候已经不算是野指针了，反而会出现段错误；当随机分配内存，编译却通过了，说明这个问题跟野指针无关，这是由<code>strcpy</code>引发的段错误。</p><h2 id="4-2-strcpy语法"><a href="#4-2-strcpy语法" class="headerlink" title="4.2 strcpy语法"></a>4.2 <code>strcpy</code>语法</h2><p><code>strcpy</code>的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(char* dest, const char *src);</span><br></pre></td></tr></table></figure><p>被覆盖的 <code>dest</code>首先是个变量，变量就必须有内存存放；而一个指向<code>NULL</code>的指针没有指向任何内存。没有内存，怎么存储覆盖过来的值？</p><p>&emsp;&emsp;或者来个更直接的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1=<span class="literal">NULL</span>;                        <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Shatang"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所有的</strong>编译器程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> Segmentation fault</span><br></pre></td></tr></table></figure><h2 id="4-3-错误的例子2"><a href="#4-3-错误的例子2" class="headerlink" title="4.3 错误的例子2"></a>4.3 错误的例子2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1=<span class="string">"Shatang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2); <span class="comment">// OOPS!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：这里我们将字符串指针初始化，指向一块明确内存(不是野指针了)；但程序执行还会报 理所应当的 <code>Segmentation fault</code>的错误。<code>strcpy</code>函数的<code>dest</code>是一个变量，不能指向字符串常量；字符串常量存放在内存位置的字符常量区(详情看内存知识)， 字符串指针指向这个区域，而且这个区域是一个const 属性的不可修改的；因此 再进行拷贝覆盖的时候会出现段错误。</p><h2 id="4-4-正确的例子1"><a href="#4-4-正确的例子1" class="headerlink" title="4.4 正确的例子1"></a>4.4 正确的例子1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">10</span>]=<span class="string">"Shatang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zhu</span><br><span class="line"><span class="number">0x7ffff41e089e</span></span><br></pre></td></tr></table></figure><h2 id="4-5-正确的例子2"><a href="#4-5-正确的例子2" class="headerlink" title="4.5 正确的例子2"></a>4.5 正确的例子2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                           <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    </span><br><span class="line">    s1=(<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));   <span class="comment">//重新分配一块内存给指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zhu</span><br><span class="line"><span class="number">0x144e010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此可见<code>strcpy</code>引发的段错误，并非是野指针引起的；而是编程人对<code>strcpy</code>的用法不了解导致的。</p><h2 id="4-6-得出来的结论"><a href="#4-6-得出来的结论" class="headerlink" title="4.6 得出来的结论"></a>4.6 得出来的结论</h2><p>&emsp;&emsp;只要调用该指针前，先把指针赋值指向对应的内存，就不会影响到系统的健壮性。如果严谨一点，还是把对指针进行 初始化赋值 或 置为<code>NULL</code>吧！ (抽风编译器牛逼!)</p><h1 id="五、经典野指针错误"><a href="#五、经典野指针错误" class="headerlink" title="五、经典野指针错误"></a>五、经典野指针错误</h1><p>&emsp;&emsp;<strong>野指针犯错方式是花式的、神奇的</strong>。随着编译器的不同，野指针造成的结果也不相同；甚至在同一个编译器下，你定义变量的数量不同，多一个或少一个，系统就可能让 未初始化的指针 置<code>NULL</code>或者是分配随机内存。<strong>野指针，强就强在，随机神秘翻车！不仅如此，还是编译通过的后续翻车(关键点)！！！</strong></p><p>&emsp;&emsp;因此，大家也不要对野指针编译的结果不同太诧异。具体的错误例子可以看 <a href="https://shatang.github.io/2020/03/15/32-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/#more">内存分配方式</a> 一节内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="内存" scheme="http://shatang.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="野指针" scheme="http://shatang.github.io/tags/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>内存分配方式</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://shatang.github.io/2020/03/15/内存分配方式/</id>
    <published>2020-03-15T06:32:56.000Z</published>
    <updated>2020-03-18T15:41:19.841Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、内存分配方式"><a href="#一、内存分配方式" class="headerlink" title="一、内存分配方式"></a>一、内存分配方式</h1><p>&emsp;&emsp;一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ol><li><strong>栈区（stack）</strong>：<em>由编译器自动分配释放</em> ；存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li><strong>堆区（heap）</strong> ： <em>一般由程序员分配释放</em>； 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</li><li><strong>全局区(静态区)(static)</strong>：<em>程序结束后有系统释放</em>；全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</li><li><strong>文字(字符)常量区</strong> ：<em>程序结束后由系统释放</em>；常量字符串就是放在这里的。 </li><li><strong>程序代码区</strong> ：存放函数体的二进制代码。</li></ol><h1 id="二、例子程序"><a href="#二、例子程序" class="headerlink" title="二、例子程序"></a>二、例子程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//全局初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1;   <span class="comment">//全局未初始化区</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> b;              <span class="comment">//栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abc"</span>;   <span class="comment">//栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p2;           <span class="comment">//栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;<span class="comment">//123456在常量区，p3在栈上</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>；   <span class="comment">//全局（静态）初始化区</span></span><br><span class="line"></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//申请分配得来的10和20字节的区域就在堆区   </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//123456放在常量区</span></span><br><span class="line">    <span class="comment">//编译器可能会将它与p3所指向的"123456"优化成一个地方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、堆和栈的理论知识"><a href="#三、堆和栈的理论知识" class="headerlink" title="三、堆和栈的理论知识"></a>三、堆和栈的理论知识</h1><h2 id="3-1-申请方式"><a href="#3-1-申请方式" class="headerlink" title="3.1 申请方式"></a>3.1 申请方式</h2><blockquote><p><strong>stack</strong>：由系统自动分配。 </p></blockquote><p>例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间</p><blockquote><p><strong>heap</strong>：需要程序员自己申请，并指明大小(在c中为，malloc函数)</p></blockquote><p>例如，<code>p1 = (char *)malloc(10);</code></p><p><strong><font color="red">Ps：</font></strong> 但是要注意<code>p1</code>本身是在栈中的。</p><h2 id="3-2-申请后系统的响应"><a href="#3-2-申请后系统的响应" class="headerlink" title="3.2 申请后系统的响应"></a>3.2 申请后系统的响应</h2><p><strong>栈</strong>：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><p><strong>堆</strong>：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p><h2 id="3-3-申请大小的限制"><a href="#3-3-申请大小的限制" class="headerlink" title="3.3 申请大小的限制"></a>3.3 申请大小的限制</h2><p><strong>栈</strong>：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><p><strong>堆</strong>：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><h2 id="3-4-申请效率的比较"><a href="#3-4-申请效率的比较" class="headerlink" title="3.4 申请效率的比较"></a>3.4 申请效率的比较</h2><p><strong>栈</strong>：由系统自动分配，速度较快。但程序员是无法控制的。</p><p><strong>堆</strong>：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p><p>&emsp;&emsp;另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p><h2 id="3-5-堆和栈的存储内容"><a href="#3-5-堆和栈的存储内容" class="headerlink" title="3.5 堆和栈的存储内容"></a>3.5 堆和栈的存储内容</h2><p><strong>栈</strong>： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p><p>&emsp;&emsp;当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><p><strong>堆</strong>：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p><h2 id="3-6-存取效率的比较"><a href="#3-6-存取效率的比较" class="headerlink" title="3.6 存取效率的比较"></a>3.6 存取效率的比较</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] = <span class="string">"aaaaaaaaaaaaaaa"</span>;</span><br><span class="line"><span class="keyword">char</span> *s2 = <span class="string">"bbbbbbbbbbbbbbbbb"</span>;</span><br></pre></td></tr></table></figure><p>aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"1234567890"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p =<span class="string">"1234567890"</span>;</span><br><span class="line">    </span><br><span class="line">    a = c[<span class="number">1</span>];</span><br><span class="line">    a = p[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10: a = c[1];</span><br><span class="line"></span><br><span class="line">00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]</span><br><span class="line"></span><br><span class="line">0040106A 88 4D FC mov byte ptr [ebp-4],cl</span><br><span class="line"></span><br><span class="line">11: a = p[1];</span><br><span class="line"></span><br><span class="line">0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</span><br><span class="line"></span><br><span class="line">00401070 8A 42 01 mov al,byte ptr [edx+1]</span><br><span class="line"></span><br><span class="line">00401073 88 45 FC mov byte ptr [ebp-4],al</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。</p><h2 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h2><p>堆和栈的区别可以用如下的比喻来看出：<br>&emsp;&emsp;使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>&emsp;&emsp;使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><ol><li>内存分配方面：</li></ol><p><strong>堆</strong>：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。<br><strong>栈</strong>：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><ol start="2"><li>申请方式方面：</li></ol><p><strong>堆</strong>：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。<br><strong>栈</strong>：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。</p><ol start="3"><li>系统响应方面：</li></ol><p><strong>堆</strong>：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。<br><strong>栈</strong>：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><ol start="4"><li>大小限制方面：</li></ol><p><strong>堆</strong>：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br><strong>栈</strong>：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><ol start="5"><li>效率方面：</li></ol><p><strong>堆</strong>：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。<br><strong>栈</strong>：由系统自动分配，速度较快。但程序员是无法控制的。</p><ol start="6"><li>存放内容方面：</li></ol><p><strong>堆</strong>：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。<br><strong>栈</strong>：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><ol start="7"><li>存取效率方面：</li></ol><p><strong>堆</strong>：是在编译时就确定的；<br><strong>栈</strong>：是在运行时赋值的；</p><hr><p><code>char *s1 = "Hello Word";</code><br><code>char s1[] = "Hello Word";</code><br>&emsp;&emsp;用数组比用指针速度要快一些，因为指针在底层汇编中需要用<code>edx</code>寄存器中转一下，而数组在栈上直接读取。</p><hr><h1 id="四、C-的内存分配方式"><a href="#四、C-的内存分配方式" class="headerlink" title="四、C++的内存分配方式"></a>四、C++的内存分配方式</h1><p>&emsp;&emsp;在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 </p><p><strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。<br><strong>堆</strong>，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br><strong>自由存储区</strong>，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。<br><strong>全局/静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。<br><strong>常量存储区</strong>，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）</p><h1 id="五、内存分配方式引发的概念区别-C"><a href="#五、内存分配方式引发的概念区别-C" class="headerlink" title="五、内存分配方式引发的概念区别(C)"></a>五、内存分配方式引发的概念区别(C)</h1><h2 id="5-1-只读变量和常量"><a href="#5-1-只读变量和常量" class="headerlink" title="5.1 只读变量和常量"></a>5.1 只读变量和常量</h2><p>下面的例子用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br></pre></td></tr></table></figure><p>答案与分析:<br>1）这个问题讨论的是“常量”与“只读变量”的区别。常量肯定是只读的，例如 5， “abc”，等，肯定是只读的，因为程序中根本没有地方存放它的值(存放在字符常量区，不可修改，只读)，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时维度必须是“常量”，“只读变量”也是不可以的。<br>2）注意：在ANSI C中，这种写法是错误的，因为数组的大小应该是个常量，而const int n,n只是一个变量（常量 != 不可变的变量，但在标准C++中，这样定义的是一个常量，这种写法是对的），实际上，根据编译过程及内存分配来看，这种用法本来就应该是合理的，只是 ANSI C对数组的规定限制了它。<br>3）那么，在 ANSI C 语言中用什么来定义常量呢？答案是enum类型和#define宏，这两个都可以用来定义常量。</p><h2 id="5-2-指针-和-字符串常量"><a href="#5-2-指针-和-字符串常量" class="headerlink" title="5.2 指针 和 字符串常量"></a>5.2 指针 和 字符串常量</h2><p>请问下面的代码有什么问题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"i'm hungry!"</span>;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>]= <span class="string">'I'</span>;</span><br></pre></td></tr></table></figure><p>答案与分析：<br>&emsp;&emsp;上面的代码会造成内存的非法写操作。分析如下， “i’m hungry”实质上是字符串常量，而字符串常量被编译器放在只读的字符常量区内，不可写。指针p初始化，指向这个只读的内存区，是不能修改其中元素值(即存放值)；而<code>p[0] = 'I';</code>则企图修改内存存放值，编译器当然不会答应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"i'm hungry!"</span>;</span><br><span class="line">p = <span class="string">"I'm hungry!"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽说字符串常量(字符常量区)内容不可修改，但指针是变量，可以修改指针p指向的内存位置；即实际上又找了一个新的字符串常量(新申请在字符常量区)。</p><h2 id="5-3-字符串数组-和-字符串常量"><a href="#5-3-字符串数组-和-字符串常量" class="headerlink" title="5.3 字符串数组 和 字符串常量"></a>5.3 字符串数组 和 字符串常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">15</span>] = <span class="string">"i'm hungry!"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>]= <span class="string">'I'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br></pre></td></tr></table></figure><p>答案与分析：</p><p>&emsp;&emsp;相比较与5.2，由于字符串数组是存放在 栈 或 堆 ，该区是可以修改的，因此对字符串(数组,这里不是常量)的元素可以修改。</p><h2 id="5-4-指针-amp-内存"><a href="#5-4-指针-amp-内存" class="headerlink" title="5.4 指针 &amp; 内存"></a>5.4 指针 &amp; 内存</h2><p>&emsp;&emsp;往往别人在教指针知识的时候，往往强调指针存放着地址，并举出类似下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="number">0x12ff7c</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>,p);</span><br></pre></td></tr></table></figure><p>程序结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12f</span>f7c</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;的确是能够打印出来，<code>0x12ff7c</code>是在前面随便打印一个<code>int</code>类型变量的地址获取的。但是如果给这个内存进行赋值操作的话，就会出现 <strong>段错误</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="number">0x12ff7c</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>,p);</span><br><span class="line"></span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;地址和内存是两回事！！！每段内存都有自己的地址，地址映射可以通过指针操作；但是，你无权更改内存存放的值，除非这段内存是 栈 或 堆 分配给你的。需要注意：<strong>有地址，没空间</strong>(字符常量区也是这样)。</p><p><strong><font color="red">Ps：</font></strong> 如果有地址就能合法操作对应内存空间，那还要什么(手动)内存分配。</p><h1 id="六、内存知识的重新总结"><a href="#六、内存知识的重新总结" class="headerlink" title="六、内存知识的重新总结"></a>六、内存知识的重新总结</h1><p>一个程序分为：</p><ul><li>栈区（stack） –编译器自动分配释放，主要存放函数的参数值，局部变量值等；</li><li>堆区（heap）  –由程序员分配释放；</li><li>全局(静态)区 –存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区(.data)和全局未初始化区(.bss)；</li><li>字符常量区(.rodata)   –常量字符串放与此，程序结束时由系统释放；</li><li>程序代码区(.text)</li></ul><p><strong>栈</strong> ：(<strong>后进先出</strong>)栈在程序中用于维护函数的调用上下文；栈保存了一个函数调用所需要的维护信息。</p><pre><code>1)函数参数，函数返回地址2)局部变量3)函数调用上下文</code></pre><p><strong>堆</strong>：(<strong>堆内存需要主动申请</strong>)为什么有了栈还需要堆？</p><pre><code>1)栈上的数据在函数返回后就会被释放掉，无法传递到函数外部，如局部变量(关键原因)2)堆是程序中一块巨大的内存空间，可由程序自由支配3)堆中被程序申请使用的内存在程序主动释放前将一直有效</code></pre><p><strong>(全局)静态存储区</strong>：</p><pre><code>1)程序的静态存储区随着程序的运行而分配空间，直到程序运行结束2)在程序编译期间静态存储区的大小就已经确定3)程序的静态存储区主要用于保存程序中的全局变量和静态变量4)与栈和堆不同，静态存储区的信息最终会保存在可执行程序中</code></pre><h1 id="七、-非法内存操作分析"><a href="#七、-非法内存操作分析" class="headerlink" title="七、 非法内存操作分析"></a>七、 非法内存操作分析</h1><h2 id="7-1-指针没有初始化进行内存操作"><a href="#7-1-指针没有初始化进行内存操作" class="headerlink" title="7.1 指针没有初始化进行内存操作"></a>7.1 指针没有初始化进行内存操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* d1;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//问题1：不能直接赋值，因为并没有分配内存，也没有初始化。</span></span><br><span class="line">    &#123;</span><br><span class="line">        d1[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, *(d1+<span class="number">6</span>), d1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>-&gt;<span class="number">0x7ffeaaf62970</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里理所应当地出现两种情况：</p><ol><li>出现段错误，则是编译器自动将指针置<code>NULL</code></li><li>编译通过的，则是 野指针</li></ol><h2 id="7-2-没有给指针分配足够的内存"><a href="#7-2-没有给指针分配足够的内存" class="headerlink" title="7.2 没有给指针分配足够的内存"></a>7.2 没有给指针分配足够的内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *d2;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    d2=(<span class="keyword">int</span> *)<span class="built_in">calloc</span>(<span class="number">5</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//问题2：只分配了5个空间，却用了10个。</span></span><br><span class="line">    &#123;</span><br><span class="line">        d2[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, *(d2+<span class="number">6</span>), d2);</span><br><span class="line">    <span class="built_in">free</span>(d2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, *(d2+<span class="number">6</span>), d2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>-&gt;<span class="number">0x1b3d010</span></span><br><span class="line">*** Error in `./a.out': free(): invalid next size (fast): 0x0000000001b3d010 ***</span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>-&gt;<span class="number">0x1602010</span></span><br><span class="line"><span class="number">4113</span>-&gt;<span class="number">0x1602010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里会出现<code>free()</code>操作 非法(没有分配)的内存；还有个编译器神奇通过(野指针的恐怖之处)。</p><h2 id="7-3-内存分配成功但是没有初始化"><a href="#7-3-内存分配成功但是没有初始化" class="headerlink" title="7.3 内存分配成功但是没有初始化"></a>7.3 内存分配成功但是没有初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">'A'</span>;</span><br><span class="line">    <span class="comment">//s[1]='\0';</span></span><br><span class="line"> s[<span class="number">2</span>]=<span class="string">'B'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,s);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="number">0x14e5010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，上面虽然编译通过但是是有问题的。犯这个错误往往是由于没有初始化的概念或者是以为内存分配好之后其缺省初值自然为0。未初始化指针变量也许看起来不那么严重，但是它确确实实是个非常严重的问题，而且往往出现这种错误很难找到原因。(<strong>尤其在字库驱动</strong>)</p><p>&emsp;&emsp;内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，但这点在不同的编译器上会有不同的实现。所以好的做法，是手动给数组赋上初值。</p><p>&emsp;&emsp;当你只分配内存给字符(串)型指针，并没有缺省初值，严格意义上来讲是不算初始化；有些编译器自然里面都是<code>'\0'</code>，<code>printf</code>打印时，打印出来的数据自然会被其中字符的<code>'\0'</code>截胡。不然可以把上述例子的注释去掉再测试一遍。</p><p>也许这种严重的问题并不多见，但是也绝不能掉以轻心。所以在定义一个变量时，第一件事就是初始化。你可以把它初始化为一个有效的值。</p><h2 id="7-4-内存-数组-越界"><a href="#7-4-内存-数组-越界" class="headerlink" title="7.4 内存(数组)越界"></a>7.4 内存(数组)越界</h2><p>数组有两个特性，影响作用在数组上的函数：</p><ol><li>不能复制数组；</li><li>使用数组名时， 数组名会自动指向其第一个元素的指针。</li><li>因为不能复制，所以无法编写使用数组类型的形参，数组会自动转化为指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span><span class="comment">//这里面的[10]仅表示我们希望数组是多大；实际没有用处，传入是指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    f(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>编译器程序执行的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong><font color="red">数组作为形参时的一个陷阱：</font></strong>在数组当形参的函数中，使用sizeof来计算传入的实参数组的大小。但是当数组作为形参的时候，其退化为一个指针，如果sizeof其数组名将计算的是一个指针的大小！</p><h2 id="7-5-内存泄漏"><a href="#7-5-内存泄漏" class="headerlink" title="7.5 内存泄漏"></a>7.5 内存泄漏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( size % <span class="number">2</span> != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//奇数个size的情况直接跳转，但申请的内存没有free掉；内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="number">9</span>);</span><br><span class="line">    f(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：当函数申请了内存：采用单入口，单出口程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( size % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-多次释放指针"><a href="#7-6-多次释放指针" class="headerlink" title="7.6 多次释放指针"></a>7.6 多次释放指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);    <span class="comment">//第1次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    f(p, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);    <span class="comment">//第2次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多次释放内存的后果，就是强退出</strong></p><p><strong><font color="red"> Ps：</font></strong>分配多次完全可以，既然是变量那就是可变的！但是多次释放就是自杀！</p><h2 id="7-7-使用已经释放的内存"><a href="#7-7-使用已经释放的内存" class="headerlink" title="7.7 使用已经释放的内存"></a>7.7 使用已经释放的内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个和前面的例子有点类似</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    f(p, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i; <span class="comment">// OOPS!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、C语言有关内存的规则"><a href="#八、C语言有关内存的规则" class="headerlink" title="八、C语言有关内存的规则"></a>八、C语言有关内存的规则</h1><h2 id="8-1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针"><a href="#8-1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针" class="headerlink" title="8.1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针"></a>8.1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><h2 id="8-2-牢记数组长度，防止数组越界操作，考虑使用柔性数组"><a href="#8-2-牢记数组长度，防止数组越界操作，考虑使用柔性数组" class="headerlink" title="8.2 牢记数组长度，防止数组越界操作，考虑使用柔性数组"></a>8.2 牢记数组长度，防止数组越界操作，考虑使用柔性数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">soft_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;SoftArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">SoftArray* sa=(SoftArray*)mallo(<span class="keyword">sizeof</span>(SoftArray)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">sa-&gt;len=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sa-&gt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sa-&gt;<span class="built_in">array</span>[i]= i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放"><a href="#8-3-动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放" class="headerlink" title="8.3 动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放"></a>8.3 动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放</h2><p><strong><font color="red"> Ps：</font></strong>可以用if…else…来确定是否释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p= (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p= (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-free指针之后必须赋值为NULL"><a href="#8-4-free指针之后必须赋值为NULL" class="headerlink" title="8.4 free指针之后必须赋值为NULL"></a>8.4 free指针之后必须赋值为NULL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span>*)(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//···</span></span><br><span class="line"><span class="comment">//······</span></span><br><span class="line"><span class="comment">//·········</span></span><br><span class="line"><span class="comment">//············</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">          p[i]=i;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、嵌入式的内存分配"><a href="#九、嵌入式的内存分配" class="headerlink" title="九、嵌入式的内存分配"></a>九、嵌入式的内存分配</h1><p>&emsp;&emsp;通常应用程序可以调用ANSI C编译器的malloc()和free()函数来动态的分配和释放内存，但多次这样的操作会把原来很大的一块连续存储区域逐渐地分割成许多非常小并且彼此不相邻的存储区域，这就是存储碎片。</p><p>&emsp;&emsp;malloc( )属于标准C语言函数，当然可以在单片机上使用，如STM32可以先在启动文件中设置heap的大小，再使用动态内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Heap_Size     EQU    <span class="number">0x00000200</span>     <span class="comment">//也就是 512字节</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是在嵌入式(裸机)中最好不要这么做，一般单片机的内存都比较小，而且没有MMU(内存管理管理单元),多次的<code>malloc</code> 与<code>free</code>的使用容易造成内存碎片。当后面因为空间不足而分配失败，从而导致系统崩溃，因此应该慎用，或者自己实现内存管理。除了UCOS或FREERTOS等嵌入式操作系统有自带的MMU处理外，裸机长时间连续工作产生的内存碎片为系统工作稳定埋下隐患。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="内存" scheme="http://shatang.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="堆栈" scheme="http://shatang.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
      <category term="野指针" scheme="http://shatang.github.io/tags/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>大小端和联合体</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/"/>
    <id>http://shatang.github.io/2020/03/15/大小端和联合体/</id>
    <published>2020-03-15T06:28:41.000Z</published>
    <updated>2020-03-15T06:31:06.957Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、大小端"><a href="#一、大小端" class="headerlink" title="一、大小端"></a>一、大小端</h1><h2 id="1-1-大小端含义"><a href="#1-1-大小端含义" class="headerlink" title="1.1 大小端含义"></a>1.1 大小端含义</h2><p>&emsp;&emsp;大端小端的含义可以看这位博主的：<a href="https://www.cnblogs.com/wuyuegb2312/archive/2013/06/08/3126510.html" target="_blank" rel="noopener">轻松记住大端小端的含义(附对大端和小端的解释)</a></p><h2 id="1-2-大端小端哪里用到？"><a href="#1-2-大端小端哪里用到？" class="headerlink" title="1.2 大端小端哪里用到？"></a>1.2 大端小端哪里用到？</h2><p>&emsp;&emsp;当涉及到数据拆解(例如一个32位数据拆分成两个16位数据来用) 的时候，就需要注意大小端。因为我们一般存数据和取数据都是一个一个或着一组一组，不会涉及到拆分数据，这样就不涉及大小端。</p><p>&emsp;&emsp;举个例子，当你有一个int类型的数据，你不是把数据直接取出来，而是把int变量中的一个字节数据提取出来，想做一些类似位操作的操作。当一个数据拆解取出来的时候，就会设计到数据的存储顺序，即大小端。</p><p>&emsp;&emsp;但是，由于<strong>一般现在所用的cpu基本上是采用的小端模式</strong>。基本上，平常撸代码都不会被涉及(影响到)到，因此简单了解一下其概念就行。以下的情况才有可能是被大小端模式影响到：</p><ol><li>在(不熟悉的)平台撸代码，用到union之类的语法。发现读写数据出现异常</li><li>正常稳定的代码，迁移新的平台。发现读写数据出现异常</li></ol><h1 id="二、联合体"><a href="#二、联合体" class="headerlink" title="二、联合体"></a>二、联合体</h1><p><strong>联合体</strong>：使几个不同类型的变量共占一段内存(相互覆盖)。所占内存长度是各最长的成员占的内存长度。<br><strong>结构体</strong>：把不同类型的数据组合成一个整体。所占内存长度是各成员占的内存长度的总和。</p><p>&emsp;&emsp;由于嵌入式C基本都是用小端模式：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。小端就是我们(平常逻辑)认知的顺序，因此后面(默认小端)不再提及大小端对联合体的影响。</p><hr><blockquote><p>寄存器(联合体和结构体的妙用)</p></blockquote><p>先声明一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体中的冒号表示位域</span></span><br><span class="line"><span class="comment">//位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节//同时也是为了节省存储空间和方便处理。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> Mode1:<span class="number">1</span>;   <span class="comment">//Mode1配置占1位 </span></span><br><span class="line">    <span class="keyword">uint16_t</span> Mode2:<span class="number">3</span>;   <span class="comment">//Mode2配置占3位</span></span><br><span class="line">    <span class="keyword">uint16_t</span> Mode3:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> Mode4:<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//写满16位</span></span><br><span class="line">&#125;Ctl_Bits;</span><br></pre></td></tr></table></figure><p>再声明一个联合体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> TBCTL_REG</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> all;</span><br><span class="line">    Ctl_Bits bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再申明一个寄存器结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">union</span> TBCTL_REG TBCTL1;</span><br><span class="line">    <span class="keyword">union</span> TBCTL_REG TBCTL2;</span><br><span class="line">&#125;PWM_REGS;</span><br></pre></td></tr></table></figure><p>这样的话，我就写了一个关于PWM配置的寄存器，例如我现在想改PWM的Mode1为模式1；如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PWM_REGS PWM1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整体赋值</span></span><br><span class="line">PWM1.TBCTL1.all |= <span class="number">0x01</span>;</span><br><span class="line"><span class="comment">//位赋值</span></span><br><span class="line">PWM1.TBCTL1.bit.Mode1 = <span class="number">0x01</span>；</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;理解了这个方法后，再来看样例对寄存器的操作是不是就很轻松了？掌握这个方法以后，你也可以设计一个带全局或者位操作的结构体来完成自己的程序数据的应用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="大小端" scheme="http://shatang.github.io/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="联合体" scheme="http://shatang.github.io/tags/%E8%81%94%E5%90%88%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="http://shatang.github.io/2020/03/15/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://shatang.github.io/2020/03/15/结构体/</id>
    <published>2020-03-15T03:47:30.000Z</published>
    <updated>2020-03-15T04:11:32.904Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、关于c语言的结构体"><a href="#一、关于c语言的结构体" class="headerlink" title="一、关于c语言的结构体"></a>一、关于c语言的结构体</h1><p>&emsp;&emsp;首先我们为什么要用到结构体，我们都已经学了很多<code>int</code>、 <code>char</code>…等类型，还学到了同类型元素构成的数组；以及取上述类型的指针，在一些小应用可以灵活使用。然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是结构体的好处。</p><h1 id="二、结构体小知识"><a href="#二、结构体小知识" class="headerlink" title="二、结构体小知识"></a>二、结构体小知识</h1><ol><li>只有结构体变量才分配地址，而结构体的声明是不分配空间的；</li><li>结构体声明，包括了结构体中各成员的声明，因此也不分配空间；</li><li>c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换</li><li>相同类型的成员是可以声明在同一类型下的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">int</span> number,age；<span class="comment">//int型学号和年龄</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>],sex;<span class="comment">//char类型姓名和性别</span></span><br><span class="line"><span class="keyword">float</span> score;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//最后的分号不要忘了</span></span><br></pre></td></tr></table></figure></li></ol><p><strong><font color="red">总结：</font></strong>声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 int 分配内存一样。只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。</p><blockquote><p>结构体类型的变量的本质：<strong>结构体类型的变量，本质上是一个变形的数组</strong>。</p></blockquote><ul><li>不同点：结构体不要求元素类型一样，要用的时候，不是以数组下标，而是特定指向(<code>.</code>或<code>-></code>)该成员来 处理（例如赋值）；</li><li>相同点：<ul><li>结构体和数组在定义的时候不进行初始化赋初值，则后面就不能全部赋初值，需<strong>逐个</strong>赋值；</li><li>进行 数组、结构体变量 初始化的时候，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋初值前面几个；</li><li>进行 数组、结构体变量 初始化的时候，对于未初始化(后半段)的数据：如果是数值型，则会自动赋值为 <code>0</code> ；如果是字符型，会自动赋初值为 <code>NULL</code> ，即<code>\0</code> ；即不足的元素补以默认值；</li><li>函数的传入参数(形参)是结构体、数组，均采用指针传递的方式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;Student；</span><br><span class="line">Student stu1=&#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> str[<span class="number">10</span>]=&#123;<span class="number">1</span>&#125;;<span class="comment">//这里只是把str的第一个元素赋值为1，其他元素默认为0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>&emsp;&emsp;这里要强调的一点是， “变量赋值” 和 “变量初始化(赋初值)”不是一回事！给(全局)变量初始化，定义时后跟等号，等号后面是初始化值。<strong>赋初值只会在定义的时候进行赋初始化值，其余地方都是赋值</strong>。</p><blockquote><p>赋初值 和 赋值 的区别</p></blockquote><ol><li><strong>赋值运算，函数体外是不允许的</strong>；而赋初值没有该要求，可在函数体外定义赋初值。</li><li>赋初值，可以初始化所有成员；赋值，只能对<strong>逐个</strong>成员进行赋值，无法一次性对全体成员进行赋值。(举例：数组、结构体)</li></ol><h1 id="三、结构体变量的定义和引用"><a href="#三、结构体变量的定义和引用" class="headerlink" title="三、结构体变量的定义和引用"></a>三、结构体变量的定义和引用</h1><h2 id="3-1-结构体类型的变量"><a href="#3-1-结构体类型的变量" class="headerlink" title="3.1 结构体类型的变量"></a>3.1 结构体类型的变量</h2><p>&emsp;&emsp;在编译时，<strong>结构体的声明并不分配存储空间</strong>；声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 <code>int</code> 分配内存一样；<strong>只有当使用这个类型定义了变量时，系统才会为变量分配内存</strong>。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line"> <span class="keyword">char</span> title[<span class="number">20</span>];<span class="comment">//一个字符串表示的titile 题目</span></span><br><span class="line"><span class="keyword">char</span> author[<span class="number">20</span>];<span class="comment">//一个字符串表示的author作者</span></span><br><span class="line"> <span class="keyword">float</span> value;<span class="comment">//价格表示 </span></span><br><span class="line"> &#125;;<span class="comment">//这里只是声明 结构体类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book1</span>,<span class="title">book2</span>;</span><span class="comment">//结构体变量的定义 分配空间</span></span><br><span class="line">book1.value;<span class="comment">//引用结构体变量</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;定义结构体变量以后，系统就会为其分配内存单元，比如book1和book2在内存中占44个字节（20+20+4）具体的长度你可以在你的编译器中使用sizeof关键字分别求出来。</p><h2 id="3-2-结构体空洞"><a href="#3-2-结构体空洞" class="headerlink" title="3.2 结构体空洞"></a>3.2 结构体空洞</h2><p>&emsp;&emsp;用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍；比方说我们上面求得的为44 为 float(4个字节)的整数倍，但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48(4的整数倍)。</p><p>这就涉及到结构体的存储：</p><ol><li>结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍；</li><li>结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍(一般是int,4字节)，如果不是编译器会自动补齐；</li></ol><p>&emsp;&emsp;在结构体分配空间时，如果结构体中出现4个字节(32位)及以上的变量时，给每个变量分配空间时都是按字对齐分配的(就是按4个字节，4个字节来分配)；如果结构体中没有出现4个字节以上变量，则按半字对齐(按 2个字节，2个字节。。来分配)。<br>&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储(字对齐或双字对齐等)。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。<br>&emsp;&emsp;看来鱼与熊掌还是不能兼得啊。既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。<br>&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单地(手动计算)相加。因为他们中间存在空洞。</p><p>关于偏移量，简单介绍下：</p><blockquote><p>结构体偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小；<strong>第一个成员的偏移量为0</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>char a</code> 偏移量为 1 之后为 <code>int b</code> 因为偏移量 1 不为int(4)的整数倍，所以会自动补齐，而在 <code>double c</code> 时，偏移量为 8 是int(4)的整数倍，所以不用自动补齐，最后求得结构体得大小为 16。</p><h1 id="四、结构体变量的初始化"><a href="#四、结构体变量的初始化" class="headerlink" title="四、结构体变量的初始化"></a>四、结构体变量的初始化</h1><p>&emsp;&emsp;结构体的初始化有很多需要注意的地方，这里我们说明下，首先是几种初始化的方法。</p><p><strong><font color="red">Ps：</font></strong> 在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋值前面几个，对于后面未赋值的变量，如果是数值型，则会自动赋值为0；对于字符型，会自动赋初值为 <code>NULL</code> ，即 <code>\0</code> 。</p><h2 id="4-1-定义时直接赋值-变量初始化"><a href="#4-1-定义时直接赋值-变量初始化" class="headerlink" title="4.1 定义时直接赋值(变量初始化)"></a>4.1 定义时直接赋值(变量初始化)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;stu1=&#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>=&#123;</span><span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意：</font></strong> 字符为 <code>' '</code> ，字符串为 <code>" "</code></p><h2 id="4-2-定义结构体之后逐个赋值"><a href="#4-2-定义结构体之后逐个赋值" class="headerlink" title="4.2 定义结构体之后逐个赋值"></a>4.2 定义结构体之后逐个赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值操作均在函数内操作</span></span><br><span class="line"></span><br><span class="line">stu1.name=<span class="string">"王伟"</span>；</span><br><span class="line">stu1.sex=<span class="string">'M'</span>;</span><br><span class="line">stu1.number=<span class="number">12305</span>;</span><br><span class="line"><span class="comment">//也可用strcpy函数进行赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu1.name,<span class="string">"王伟"</span>);</span><br></pre></td></tr></table></figure><h2 id="4-3-定义之后任意赋值"><a href="#4-3-定义之后任意赋值" class="headerlink" title="4.3 定义之后任意赋值"></a>4.3 定义之后任意赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>=&#123;</span></span><br><span class="line">  .name=<span class="string">"Wang"</span>,</span><br><span class="line">  .number=<span class="number">12345</span>,</span><br><span class="line">  .sex=<span class="string">'W'</span>, </span><br><span class="line">&#125;;<span class="comment">//可以对任意变量赋值</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样写的好处时不用按照顺序来进行初始化，而且可以对你想要赋值的变量直接进行赋值，而不想赋值的变量可以不用赋值。<br>&emsp;&emsp;需要注意的是，<strong>如果在定义结构体变量的时候没有初始化，那么后面就不能全部一起初始化了。</strong>(数组性质)</p><h2 id="4-4-typedef-说明结构体类型"><a href="#4-4-typedef-说明结构体类型" class="headerlink" title="4.4 typedef 说明结构体类型"></a>4.4 typedef 说明结构体类型</h2><p>&emsp;&emsp;<code>typedef</code>  为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span>  //这里也可以不写<span class="title">tagMyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> iNum;</span><br><span class="line">    <span class="keyword">long</span> lLength;</span><br><span class="line">&#125;MyStruct;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的<code>tagMyStruct</code>是标识符，<code>MyStruct</code>是变量类型(相当于 <code>int</code> , <code>char</code> 等)。</p><p>这语句实际上完成两个操作：</p><ol><li>定义一个新的结构类型</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span>　　 </span><br><span class="line">    <span class="keyword">int</span> iNum; </span><br><span class="line">    <span class="keyword">long</span> lLength; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析：<code>tagMyStruct</code>  称为“tag”，即“标签”，实际上是一个临时名字，不论是否有 <code>typedef struct</code> 这个关键字 和 <code>tagMyStruct</code>  一起，构成了这个结构类型，这个结构都存在。我们可以用 <code>tagMyStruct varName</code>  来定义变量；但要注意，使用 <code>tagMyStruct varName</code>  来定义变量是不对的，因为 <code>struct </code> 和 <code>tagMyStruct </code>合在一起才能表示一个结构类型。</p><ol start="2"><li><code>typedef</code>为这个新的结构起了一个名字，叫<code>MyStruct</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span> <span class="title">MyStruct</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此，<code>MyStruct</code>实际上相当于 <code>struct tagMyStruct</code> ，我们可以使用 <code>MyStruct varName</code> 来定义变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> iNum;</span><br><span class="line">    <span class="keyword">long</span> lLength;</span><br><span class="line">&#125;MyStruct;</span><br></pre></td></tr></table></figure><p>在C中，这个申明后申请结构变量的方法有两种：<br>(1) <code>struct tagMyStruct 变量名</code>(typedef声明时可省略tagMyStruct，省略后则无法使用该方法定义结构变量)<br>(2) <code>MyStruct 变量名</code>(一般采用该方法)</p><h1 id="五、结构体变量的引用-结构体成员"><a href="#五、结构体变量的引用-结构体成员" class="headerlink" title="五、结构体变量的引用(结构体成员)"></a>五、结构体变量的引用(结构体成员)</h1><ol><li>结构体类型  声明定义的是  普通变量，普通变量 访问成员时就用 <code>.</code></li><li>结构体类型  声明定义的是  指针    ，指针 访问成员时就用 <code>-></code></li></ol><p><strong><font color="red">Ps：</font></strong> 若使用指针对结构体成员进行访问，格式为：指针-&gt;成员名 等价于 <code>(*指针).成员名</code> </p><p>但是有几点需要注意：<br>(1) <code>.</code>是运算符，在所有运算符优先级中最高<br>(2)如果结构体的成员本身是一个结构体，则需要继续用<code>.</code>运算符，直到最低一级的成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"> <span class="keyword">int</span> month;</span><br><span class="line"> <span class="keyword">int</span> day;</span><br><span class="line">&#125;birthday;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line">Student Stu1;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,stu1.birthday);<span class="comment">//这样子是错误的，因为birthday也是一个结构体变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;stu1.birthday.month);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h1 id="六、结构体数组及其初始化-重点"><a href="#六、结构体数组及其初始化-重点" class="headerlink" title="六、结构体数组及其初始化(重点)"></a>六、结构体数组及其初始化(重点)</h1><p>&emsp;&emsp;这里我们简单说下，<strong>具有相同类型的结构体变量组成数组就是结构体数组</strong>。反而言之，是指数组中的每个元素都是一个结构体。在实际应用中，结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;stu1[<span class="number">5</span>]=&#123;</span><br><span class="line"> &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"wangwei"</span>,<span class="string">'M'</span>,<span class="number">14679</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"yulongjiao"</span>,<span class="string">'W'</span>,<span class="number">17857</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对结构体数组中全部元素赋值时，也可不给出数组长度，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> *name;<span class="comment">//指针类型指向字符串</span></span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;stu1[]=&#123;</span><br><span class="line"> &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"wangwei"</span>,<span class="string">'M'</span>,<span class="number">14679</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"yulongjiao"</span>,<span class="string">'W'</span>,<span class="number">17857</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red">Ps：</font></strong>在上面的Tip提到，结构体是一个变形的数组；结构体数组，其实就是变形的二元数组；数组的性质同样也是存在：<strong>结构体数组要在定义时就直接初始化赋值，不然后面再全部赋值是错误的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>；</span></span><br><span class="line"><span class="class"><span class="title">stu1</span>[3]=&#123;</span></span><br><span class="line">  &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//正确的示例  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>[]=&#123;</span></span><br><span class="line">    &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><blockquote><p>数组初始化</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">str=<span class="string">"I love you"</span>; <span class="comment">//这样会修改数组的地址，原因如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化后，地址分配是固定的，数组名是(符号)地址常量；常量没有(可写的)内存空间存你要赋的值</span></span><br><span class="line"><span class="comment">//因此数组名不能作为左值</span></span><br><span class="line"><span class="comment">//所以我们可以把str[i]当左值，而无法把str当左值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确示范</span></span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line">str=<span class="string">"I love you"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第一条语句中 <code>str</code> 就已经被定义成数组，而在C99标准中不允许将字符串(实际上是一个指针变量)赋值给数组(左值)，所以如果我们直接赋值是错误的。</p><p><strong><font color="red">注意区分声明时的初始化和普通的赋值语句！！！</font></strong></p><hr><blockquote><p>赋值运算</p></blockquote><p>&emsp;&emsp;赋值运算，分为左值和右值。</p><ol><li>左值：可以出现在赋值语句的左边或右边，它不光有值，还有一个存储地址；</li><li>右值：只能出现在赋值语句的右边，认为它只有一个值的大小，<strong>没有存储地址</strong>，只关心它的值(字符串常量则是存在字符常量区，只可读不可写)。</li></ol><hr><blockquote><p>数组名不可能作为左值！数组名不是指针！</p></blockquote><p>&emsp;&emsp;那么数组名应该如何理解呢？用来存放数组的区域是一块在栈中静态分配的内存(非static)，而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且，还是一个不可修改的常量，完整地说，就是一个地址常量。</p><p>&emsp;&emsp;数组名跟枚举常量类似，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。注意了！不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址，这就是数组名属于符号常量的意义所在。</p><p>&emsp;&emsp;由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，那么，数组名永远都不会是指针！</p><p>这里提供数组赋(字符串)值的3种方法：</p><ol><li><p>定义数组时直接定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>] = <span class="string">"I love you"</span>;</span><br></pre></td></tr></table></figure></li><li><p>用<code>strcpy</code>进行复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,“I love you”);</span><br></pre></td></tr></table></figure></li><li><p>用<code>memset</code>进行复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memset&lt;/code&gt;语法介绍</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s,<span class="keyword">int</span> c,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//作用：将已开辟内存空间s的首n个字节的值设为值c。</span></span></span><br></pre></td></tr></table></figure><p> 3.1 如果是字符类型数组的话，memset可以随便用，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="string">'a'</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p> 3.2 但是对于其他类型的数组，一般只用来清0或者填-1，如果是填充其他数据就会出错，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="number">1</span>,<span class="keyword">sizeof</span>(str));<span class="comment">//这样是错误的</span></span><br></pre></td></tr></table></figure><p> 3.3 错误分析</p><pre><code>- &lt;code&gt;memset&lt;/code&gt;在进行赋值时，是按字节为单位来进行赋值的，每次填充的数据长度为一个字节；- 对于其他类型的变量，比如int，占4个字节 所以sizeof(str)=40；- 用memset赋值时，将会对指向str地址的前40个字节进行赋值0x01（00000001） 的操作；**把0x00000000赋值4次0x01操作变为&lt;code&gt;0x01010101&lt;/code&gt;**(错误主要原因)；- 相当于给 “(所有)10个int” 进行了赋值&lt;code&gt;0x01010101&lt;/code&gt;的操作 对应十进制的16843009，所以会出很大的错误。</code></pre></li><li><p>用指针（注意内存分配方式）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str；</span><br><span class="line">str = <span class="string">"I love you"</span>;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这两句话的本质是， 在内存中开辟一段内存空间(字符常量区)，把<code>"I love you"</code>放进这段内存空间，然后把这段内存空间的地址交给str，由于str是变量(栈 或 堆)，所以给它赋值(地址，指向的内容)是合法的。</p><hr><p><strong><font color="red">memset用法总结：</font></strong>如果是清零一个数组用memset还是很方便的；简单赋字符串值，用strcmp函数(或memset)就行。</p><h1 id="七、结构体与指针"><a href="#七、结构体与指针" class="headerlink" title="七、结构体与指针"></a>七、结构体与指针</h1><p>&emsp;&emsp;指针指向的是变量所占内存的首地址，在结构体中，指针指向的是结构体变量的起始地址，当然也可指向结构体变量的元素。</p><h2 id="7-1-指向结构体变量的指针"><a href="#7-1-指向结构体变量的指针" class="headerlink" title="7.1 指向结构体变量的指针"></a>7.1 指向结构体变量的指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;student1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span></span><br><span class="line">p=&amp;student1;</span><br></pre></td></tr></table></figure><p>简单来说以下三种形式是等价的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;cName        //可以进行正常的运算</span><br><span class="line">(*p).cName      //这里的括号不能少，.运算符优先级最高</span><br><span class="line">student1.cName</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要注意的是，结构体访问成员方式和数组访问成员方式有些差别。</p><p>即使<code>*p</code>访问到了结构对象的第一个成员变量a，也不能保证<code>*(p+1)</code>就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定<code>*(pstr+1)</code>就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 (用sizeof作为偏移量访问下一个成员要注意一下结构体空洞吖！)</p><h2 id="7-2-指向结构体数组的指针"><a href="#7-2-指向结构体数组的指针" class="headerlink" title="7.2 指向结构体数组的指针"></a>7.2 指向结构体数组的指针</h2><p>&emsp;&emsp;在我们想要用指针访问结构体数组的第n个数据时可以用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>[5];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>*<span class="title">p</span>;</span></span><br><span class="line">p=stu[n];</span><br><span class="line">(++p).number<span class="comment">//是指向了结构体数组下一个元素的地址</span></span><br></pre></td></tr></table></figure><h2 id="7-3-结构体成员是指针类型变量"><a href="#7-3-结构体成员是指针类型变量" class="headerlink" title="7.3 结构体成员是指针类型变量"></a>7.3 结构体成员是指针类型变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span>* Name;<span class="comment">//这样防止名字长短不一造成空间的浪费</span></span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;student1;</span><br></pre></td></tr></table></figure><p>在使用时可以很好地防止内存被浪费，但是注意在引用时一定要给指针变量分配地址，如果你不分配地址，结果可能是对的(野指针)，但是Name会被分配到任意的一地址，指针为字符串分配任何内存存储空间具有不确定性，这样就存在潜在的危险。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span>* Name;</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;stu，*stu；</span><br><span class="line"></span><br><span class="line">stu.name=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//内存初始化</span></span><br></pre></td></tr></table></figure><p>所对应的指针类型结构体成员要相应初始化分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span>* Name;</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">char</span> csex;  </span><br><span class="line">&#125;stu,*stu;</span><br><span class="line">stu = (struct student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct student));.<span class="comment">/*结构体指针初始化*/</span></span><br><span class="line">stu-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">/*结构体指针的成员指针同样需要初始化*/</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上，结构体指针、结构体成员指针就是指针，没有区别；只不过结构体成员指针容易被忽略初始化。而指针的初始化是很重要的，详情可以看 野指针一章的内容。</p><h2 id="7-4-结构体嵌套的问题"><a href="#7-4-结构体嵌套的问题" class="headerlink" title="7.4 结构体嵌套的问题"></a>7.4 结构体嵌套的问题</h2><p>结构体的<strong>自引用</strong>(self reference)，就是在结构体内部，包含指向自身类型结构体的指针。<br>结构体的<strong>相互引用</strong>（mutual reference），就是说在多个结构体中，都包含指向其他结构体的指针。</p><h3 id="7-4-1-自引用-结构体"><a href="#7-4-1-自引用-结构体" class="headerlink" title="7.4.1 自引用 结构体"></a>7.4.1 自引用 结构体</h3><blockquote><p>不使用 <code>typedef</code></p></blockquote><ol><li>错误的方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span> <span class="title">A</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这种声明是错误的，因为这种声明实际上是一个无限循环，成员A是一个结构体，A的内部还会有成员是结构体，依次下去，类似于永无出口的递归调用。在分配内存的时候，由于无限嵌套，也无法确定这个结构体的长度，所以这种方式是非法的。</p><ol start="2"><li>正确的方式：(使用<strong>指针</strong>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span> *<span class="title">A</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;由于<strong>指针的长度是确定的（在32位机器上指针长度为4），所以编译器能够确定该结构体的长度</strong>。</p><p><strong><font color="red">Ps：</font></strong>这个指针看似指向自身，其实不是，而是指向同一类型的不同结构。链表和树的数据结构就都使用到此技巧。自身的结构体指针指向下一节点或者下一子树的地址。</p><hr><blockquote><p>使用 <code>typedef</code> </p></blockquote><ol><li>错误的方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    NODE *link; </span><br><span class="line">&#125;NODE;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这里的目的是使用typedef为结构体创建一个别名NODE。但是这里是错误的，因为此时还没定义完类型名，而在结构体内部引用了结构类型名，是非法的。</p><ol start="2"><li>正确的方式：(使用<strong>不完全声明</strong>)有三种，差别不大，使用哪种都可以<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span> *<span class="title">link</span>;</span> </span><br><span class="line">&#125; NODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虽然 C 语言编译器完全支持这种做法，但不推荐使用以下的第2种</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_2</span> <span class="title">NODE</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_2</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    NODE *link;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建议使用以下的第3种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_3</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_3</span> *<span class="title">link</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_3</span> <span class="title">NODE</span>;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="7-4-2-相互引用-结构体"><a href="#7-4-2-相互引用-结构体" class="headerlink" title="7.4.2 相互引用 结构体"></a>7.4.2 相互引用 结构体</h3><ol><li>错误的方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    B *bp; </span><br><span class="line">&#125;A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    A *ap;</span><br><span class="line">&#125;B;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;错误的原因和上面一样，这里类型B在定义之前 就被使用。</p><ol start="2"><li>正确的方式：(使用<strong>不完全声明</strong>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用第一种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> *<span class="title">bp</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> *<span class="title">ap</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> *<span class="title">bp</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> *<span class="title">ap</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-5-结构体作为函数参数-形参"><a href="#7-5-结构体作为函数参数-形参" class="headerlink" title="7.5 结构体作为函数参数(形参)"></a>7.5 结构体作为函数参数(形参)</h2><p>将结构体传递给函数的方式有如下3种：</p><ol><li>用结构体的单个成员作为函数参数，向函数传递结构体的单个成员（属于<strong>传值调用</strong>，不会影响相应的实参结构体的值）</li><li>用结构体变量做函数参数，向函数传递结构体完整结构（属于<strong>传值调用</strong>，不会影响相应的实参结构体的值）</li><li><strong>用结构体指针或结构体数组作函数参数</strong>属于<strong>模拟按引用调用</strong>，会影响相应的实参结构体的值,向函数传递结构体地址，因为仅复制结构体首地址一个值给被调函数，相对于第二种方式，这种传递效率更高</li></ol><hr><blockquote><p>补充：传值调用与模拟按引用调用（参数传递）</p></blockquote><p><strong>按值调用</strong>：将程序将函数调用语句中的实参的一份副本传给函数的形参<br><strong>模拟按引用调用</strong>：指针作为函数的参数，虽然实际上也是传值给被调用函数，但是传给被调用函数的这个值不是变量的值，而是变量的地址，通过向被调用函数传递某个变量的地址值可以在被调函数中改变主调函数中这个变量的值，相当于模拟C++中的按引用调用因此称为模拟按引用调用</p><p>&emsp;&emsp;使用结构体变量作为函数参数的时候，是采取传值调用，将结构体所占内存单元的内容全部传递给形参，并且形参必须也要是同类型的结构体变量，在使用时，会自动创建一个结构体变量作为原变量的副本，并且也需要占内存，效率较低。且无法修改实际的结构体变量中成员的值。</p><p>&emsp;&emsp;如果用指针作为实参，传递给函数的形参，这时候传递的是结构体变量的地址，形参所指向的地址就是结构体变量的地址，这时候进行修改的话是可以修改的(这正是指针的精华所在)。</p><hr><h2 id="7-6-结构体的一些小技巧"><a href="#7-6-结构体的一些小技巧" class="headerlink" title="7.6 结构体的一些小技巧"></a>7.6 结构体的一些小技巧</h2><h3 id="7-6-1-互换结构体"><a href="#7-6-1-互换结构体" class="headerlink" title="7.6.1 互换结构体"></a>7.6.1 互换结构体</h3><p>在这里我们再提供几种互换两个结构体的方法：</p><ol><li>结构体指针互换地址</li><li>直接互换值(同类型结构体)</li><li>比较笨的方法：用for循环互换<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student student1=&#123;<span class="string">"Wang"</span>,<span class="number">12345</span>,<span class="string">'W'</span>&#125;;</span><br><span class="line">Student student2=&#123;<span class="string">"Zhao"</span>,<span class="number">54321</span>,<span class="string">'M'</span>&#125;; </span><br><span class="line">Student *stu1=&amp;student1;</span><br><span class="line">Student *stu2=&amp;student2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line">Student *stu3;</span><br><span class="line">stu3=stu1;</span><br><span class="line">stu1=stu2;</span><br><span class="line">stu2=stu3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">student3</span>;</span></span><br><span class="line">student3=student1;</span><br><span class="line">student1=student2;</span><br><span class="line">student2=student3;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-6-2-meset的妙用"><a href="#7-6-2-meset的妙用" class="headerlink" title="7.6.2 meset的妙用"></a>7.6.2 meset的妙用</h3><p>&emsp;&emsp;最后提下memset清空结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure><p>一般情况下，清空str的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　str.cName[<span class="number">0</span>]=<span class="string">'\0'</span>;</span><br><span class="line">　　str.csex=<span class="string">'0'</span>;</span><br><span class="line">　　str.number=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>但是我们用memset就非常方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;str,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct Student));</span><br></pre></td></tr></table></figure><p>如果是数组，就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[10];</span></span><br><span class="line"><span class="built_in">memset</span>(stu,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct Student)*<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="八、拓展-待写"><a href="#八、拓展-待写" class="headerlink" title="八、拓展(待写)"></a>八、拓展(待写)</h1><p>二叉树遍历算法<br>二叉树的二叉链表类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="九、友情链接"><a href="#九、友情链接" class="headerlink" title="九、友情链接"></a>九、友情链接</h1><p>多亏主要如下几位网友的资料<br><a href="https://www.cnblogs.com/tongongV/p/11008473.html" target="_blank" rel="noopener">结构体嵌套中的问题</a><br><a href="https://blog.csdn.net/as480133937/article/details/83473208" target="_blank" rel="noopener">c语言结构体学习整理(结构体初始化，结构体指针)</a><br><a href="https://www.cnblogs.com/lvjunjie/p/8961731.html" target="_blank" rel="noopener">结构体中定义函数指针</a><br><a href="https://www.cnblogs.com/lanhaicode/p/10312032.html" target="_blank" rel="noopener">结构体（结构体嵌套、结构体指针、结构体参数传递）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="结构体" scheme="http://shatang.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>结构体的洞和 #pragma pack</title>
    <link href="http://shatang.github.io/2020/03/15/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B4%9E%E5%92%8C-pragma-pack/"/>
    <id>http://shatang.github.io/2020/03/15/结构体的洞和-pragma-pack/</id>
    <published>2020-03-15T03:41:45.000Z</published>
    <updated>2020-03-15T03:46:44.933Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、结构体中的“洞”"><a href="#一、结构体中的“洞”" class="headerlink" title="一、结构体中的“洞”"></a>一、结构体中的“洞”</h1><p>&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。看来鱼与熊掌还是不能兼得啊。</p><p>&emsp;&emsp;既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。<br>&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单的相加。因为他们中间存在空洞。</p><h1 id="二、-pragma-pack"><a href="#二、-pragma-pack" class="headerlink" title="二、#pragma pack"></a>二、#pragma pack</h1><p>&emsp;&emsp;这是给编译器用的参数设置，有关结构体字节对齐方式设置， #pragma pack是指定数据在内存中的对齐方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack (n)             <span class="comment">//作用：C编译器将按照n个字节对齐。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack ()              <span class="comment">//作用：取消自定义字节对齐方式。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack (push,1)</span></span><br><span class="line"><span class="comment">//作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="comment">//作用：恢复对齐状态</span></span><br></pre></td></tr></table></figure><blockquote><p>#pragma pack(push,1)与#pragma pack(1)的区别</p></blockquote><p>&emsp;&emsp;因此可见，加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优。但是很多时候两者差别不大，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">//保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">//设定为4字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于 #pragma  pack (push,4)</span></span><br></pre></td></tr></table></figure><p>具体的使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack (1)           </span></span><br><span class="line"><span class="comment">//结构体内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack ()</span></span><br><span class="line"><span class="comment">//作用：调整结构体的边界对齐，让其以一个字节对齐；&lt;使结构体按1字节方式对齐&gt;</span></span><br></pre></td></tr></table></figure><p>具体例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注：若不用#pragma pack(1)和#pragma pack()括起来，则sample按编译器默认方式对齐（成员中size最大的那个）。即按8字节（double）对齐，则sizeof(sample)==16.成员char a占了8个字节（其中7个是空字节）；若用#pragma pack(1)，则sample按1字节方式对齐sizeof(sample)＝＝9.（无空字节），比较节省空间啦。在有些场合还可使结构体更易于控制。</p><h1 id="三、应用实例"><a href="#三、应用实例" class="headerlink" title="三、应用实例"></a>三、应用实例</h1><p>&emsp;&emsp;在网络协议编程中，经常会处理不同协议的数据报文。一种方法是通过指针偏移的方法来得到各种信息，但这样做不仅编程复杂，而且一旦协议有变化，程序修改起来也比较麻烦。</p><p>&emsp;&emsp;在了解了编译器对结构空间的分配原则之后，我们完全可以利用这一特性定义自己的协议结构，通过访问结构的成员来获取各种信息。这样做，不仅简化了编程，而且即使协议发生变化，我们也只需修改协议结构的定义即可，其它程序无需修改，省时省力。下面以TCP协议首部为例，说明如何定义协议结构。其协议结构定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">// 按照1字节方式进行对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPHEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">short</span> SrcPort;     <span class="comment">// 16位源端口号</span></span><br><span class="line">     <span class="keyword">short</span> DstPort;     <span class="comment">// 16位目的端口号</span></span><br><span class="line">     <span class="keyword">int</span> SerialNo;      <span class="comment">// 32位序列号</span></span><br><span class="line">     <span class="keyword">int</span> AckNo;         <span class="comment">// 32位确认号</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> HaderLen : <span class="number">4</span>; <span class="comment">// 4位首部长度</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> Reserved1 : <span class="number">4</span>; <span class="comment">// 保留6位中的4位</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> Reserved2 : <span class="number">2</span>; <span class="comment">// 保留6位中的2位</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> URG : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> ACK : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> PSH : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> RST : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> SYN : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> FIN : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">short</span> WindowSize; <span class="comment">// 16位窗口大小</span></span><br><span class="line">     <span class="keyword">short</span> TcpChkSum; <span class="comment">// 16位TCP检验和</span></span><br><span class="line">     <span class="keyword">short</span> UrgentPointer; <span class="comment">// 16位紧急指针</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样的代码编译出来的是以1个字节的方式对齐的。这样能节约内存资源，但是会在效率上有所影响。</p><p>&emsp;&emsp;虽说在效率上有一定的影响，不过，如果编写的是基于协议，如网口、串口通讯的程序，最好严格按照一定的规则进行接收数据包。使用 <code>#pragma pack(1)</code>，让数据在内存中是连续的，实现结构体通过指针偏移(没有空洞)比较好处理。</p><p>&emsp;&emsp;用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，有时候为了内存对齐需要补齐空字节。<strong>通常写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略</strong>。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。</p><p>&emsp;&emsp;也就是如果用编译器的(自动)对齐策略，采用指针偏移方式的方法可能会出现一些(不同编译器，对齐不同，错位)问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="结构体" scheme="http://shatang.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="字节对齐" scheme="http://shatang.github.io/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>关于函数指针的 强制转换 &amp; void指针</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-void%E6%8C%87%E9%92%88/"/>
    <id>http://shatang.github.io/2020/03/15/关于函数指针的-强制转换-void指针/</id>
    <published>2020-03-15T03:33:44.000Z</published>
    <updated>2020-03-15T03:40:06.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、大佬链接-和-结论"><a href="#一、大佬链接-和-结论" class="headerlink" title="一、大佬链接 和 结论"></a>一、大佬链接 和 结论</h1><p>&emsp;&emsp;下面链接是这篇博文的主力大佬，我只是润润色。<br><a href="https://blog.csdn.net/mickey35/article/details/80756348" target="_blank" rel="noopener">函数指针的强制类型转换与void指针</a><br><a href="https://blog.csdn.net/whshiyun/article/details/41379579?utm_source=blogxgwz2" target="_blank" rel="noopener">关于函数指针类型强制转换的一些摸索</a></p><p>先说结论：</p><ul><li>函数指针的指针参数只是一个标记，总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。<ul><li>换一种说法，函数指针中的形参最后使用的效果只由函数指针指向的实际函数的形参类型决定，中间处理过程只是作为一个没有类型的32位或者16位二进制数来处理。效果跟函数指针申明的形参没有多大关系。</li></ul></li><li>我们在<strong>使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参保持一致</strong>。</li></ul><h1 id="二、-常见的情况"><a href="#二、-常见的情况" class="headerlink" title="二、 常见的情况"></a>二、 常见的情况</h1><h2 id="2-1-函数指针常见用法"><a href="#2-1-函数指针常见用法" class="headerlink" title="2.1 函数指针常见用法"></a>2.1 函数指针常见用法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_int */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_int</span><span class="params">(<span class="keyword">int</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"整数:%d\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">200</span>;                <span class="comment">/* 真实整数变量 */</span></span><br><span class="line">    <span class="keyword">int</span>* p_i = &amp;i;              <span class="comment">/* 整数指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*f_ptr)(<span class="keyword">int</span> *p_fun);  <span class="comment">/* 函数指针 */</span></span><br><span class="line">    f_ptr = fun_int;            <span class="comment">/* 函数指针赋值 */</span></span><br><span class="line">    f_ptr(p_i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure><p>运行结果如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">整数:200</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总之就是，定义一个包含返回值类型和参数的函数指针，然后把一个返回值类型，参数类型及个数都相同的函数名（即地址）赋值给这个函数指针，这个函数指针就可以当成普通函数用了。</p><h2 id="2-2-函数指针强制类型转换"><a href="#2-2-函数指针强制类型转换" class="headerlink" title="2.2 函数指针强制类型转换"></a>2.2 函数指针强制类型转换</h2><p>&emsp;&emsp;此处只展示一种情况：函数指针和真实函数的返回值及参数个数都相同，只有参数类型不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_float */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_float</span><span class="params">(<span class="keyword">float</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"小数:%f\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20000</span>;      <span class="comment">/* 真实整数变量 */</span></span><br><span class="line">    <span class="keyword">int</span>* p_i = &amp;i;      <span class="comment">/* 整数指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">9.999f</span>;   <span class="comment">/* 真实浮点变量 */</span></span><br><span class="line">    <span class="keyword">float</span>* p_f = &amp;f;    <span class="comment">/* 浮点指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*f_ptr)(<span class="keyword">int</span> *p_fun);          <span class="comment">/* 函数指针 */</span></span><br><span class="line">    f_ptr = (<span class="keyword">void</span> (*)(<span class="keyword">int</span> *))fun_float; <span class="comment">/* 函数指针强制类型转换 */</span></span><br><span class="line">    f_ptr(p_i);         <span class="comment">/* 传入int指针 */</span></span><br><span class="line">    f_ptr((<span class="keyword">int</span> *)p_f);  <span class="comment">/* 传入float指针 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小数:<span class="number">0.000000</span></span><br><span class="line">小数:<span class="number">9.999000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时我们可以发现一件有趣的事情：尽管函数指针f_ptr的参数是int，但传入的int指针打印数据不正常（正常为20000），而类型不匹配的float指针却是对的（9.999）。</p><p>对此我总结了两点：</p><ul><li>函数指针的指针参数只是一个标记（或者说只是一个保存指针的地址？），总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。</li><li>我们在使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参个数保持一致。</li></ul><h2 id="2-3-以void指针作为参数的函数指针"><a href="#2-3-以void指针作为参数的函数指针" class="headerlink" title="2.3 以void指针作为参数的函数指针"></a>2.3 以void指针作为参数的函数指针</h2><p>&emsp;&emsp;结合之前的结论，在函数指针中包含指针参数时，都可以用void指针进行替代（如果类型很明确就另当别论，直接写）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_int */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_int</span><span class="params">(<span class="keyword">int</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"整数:%d\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_float */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_float</span><span class="params">(<span class="keyword">float</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"小数:%f\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20000</span>;  <span class="comment">/* 真实整数变量 */</span></span><br><span class="line">    <span class="keyword">int</span>* p_i = &amp;i;  <span class="comment">/* 整数指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">9.999f</span>;   <span class="comment">/* 真实浮点变量 */</span></span><br><span class="line">    <span class="keyword">float</span>* p_f = &amp;f;    <span class="comment">/* 浮点指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*f_ptr)(<span class="keyword">void</span> *p_fun); <span class="comment">/* 函数指针 */</span></span><br><span class="line">    f_ptr = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))fun_int;  <span class="comment">/* 强制为void* */</span></span><br><span class="line">    f_ptr(p_i);</span><br><span class="line">    f_ptr = (<span class="keyword">void</span>(*)(<span class="keyword">void</span> *))fun_float; <span class="comment">/* 强制为void* */</span></span><br><span class="line">    f_ptr(p_f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数:<span class="number">20000</span></span><br><span class="line">小数:<span class="number">9.999000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如此一来，只需要在函数指针赋值时进行强制类型转换就可以适应不同的真实函数。在调用时只要保证以void指针作为参数的函数指针结论中的第2点(形参个数保持一致)即可。</p><h1 id="三、参数个数不同的函数指针"><a href="#三、参数个数不同的函数指针" class="headerlink" title="三、参数个数不同的函数指针"></a>三、参数个数不同的函数指针</h1><p>&emsp;&emsp;这一块的知识简单了解一下就行。太内核了，从外面看就是玄学。</p><h2 id="3-1-“运气”例子"><a href="#3-1-“运气”例子" class="headerlink" title="3.1 “运气”例子"></a>3.1 “运气”例子</h2><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*F1)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*F2)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ff1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ff2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F1 f1 = (F1)ff2;</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">F2 f2 = (F2)ff1;</span><br><span class="line">f2(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>= =本人运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">2147483646</span></span><br></pre></td></tr></table></figure><p>原本例子的运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从运行结果中可以看到，当函数ff2被强制转换成一个F1类型的函数后，ff2的形参a的取值为F1类型函数的第一个形参的值，这里说明程序在执行的时候，如果该函数为一个只有n个形参的函数，如果你传递给他m个形参（n&lt;=m）,则该函数只会使用前n个形参。至于这里为什么可以允许这样的操作，后面将试探的分析一下。</p><p>&emsp;&emsp;接着，我们试图把一个ff1类型的函数，强制转换为一个F2类型的函数，并执行，执行结果还是在上面的图中，可以看到函数ff1的运行结果为3，2。</p><p>&emsp;&emsp;问题来了，我明明只传递给ff1这个函数1个参数，但为什么编译器没报错？虽然类型经过了强制转换，也许可以骗过编译器，但是在执行的时候，明明少了一个参数，程序执行的时候为什么也不报错？而且第二个参数的值还比较诡异，从打印的情况看，第二个参数为2，该值正是调用ff2的时候传递的第二个参数，该参数没被ff2处理，这里却被ff1处理，神马情况？</p><h2 id="3-2-测试”运气”"><a href="#3-2-测试”运气”" class="headerlink" title="3.2 测试”运气”"></a>3.2 测试”运气”</h2><p>&emsp;&emsp;首先，有一点，当每个函数被调用时，都被赋予了相对独立的栈空间，当该函数的生命周期结束后，该栈空间同时也被回收。</p><p>&emsp;&emsp;这样，当我们的main函数执行后，main函数有一个栈空间，假设为mem_A。那么根据上述实验结果，我这里有一个猜想，关于函数的参数是如何实现传递的。我的猜想是这样的，main函数在mem_A的栈空间中单独保留了一块类存给参数传递使用，假设该类存空间为mem_B。当一个函数运行时，程序把需要传递的参数按照顺序，放置在mem_B中，且每次都是从头开始放置。</p><p>&emsp;&emsp;回到刚刚的实验中，当ff2被执行后，mem_B中应该存放着0x00000001和0x00000002，这时再执行ff1，由于这里把ff1强制转换成了只含有一个形参的函数，所以当我们只传递给ff1一个参数3时，mem_B中应该存放着0x00000003和0x00000002，这样，ff1调用的结果可以符合以上输出结果，这里为了确定这样的结果不是巧合，又进行了数次实验，均与以上猜想相符。按照以上猜想，如果ff1先执行，ff2后执行，则ff1的第二个参数应该为一个随机数，为了验证该想法，又进行了如下实验。</p><p>其他代码都一样，就是把两个函数的执行顺序掉了一下顺序，输出结果下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F2 f2 = (F2)ff1;</span><br><span class="line">f2(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">F1 f1 = (F1)ff2;</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本人和原例运行类似，结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">-417232744</span></span><br><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，现在的编译器则是另外开辟栈空间。由于是另外开辟的情况，无法验证第二位博主的： 参数的存储是以4字节为一个存储单元的，也就是说当一个char类型的变量作为参数传递，在mem_B中占的内存大写依旧为4字节。</p><h2 id="3-3-无卵用-总结"><a href="#3-3-无卵用-总结" class="headerlink" title="3.3 (无卵用)总结"></a>3.3 (无卵用)总结</h2><p>&emsp;&emsp;由于不能复现之前博主的情况，也无法确定他的结论。但是也有发现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F1 f1 = (F1)ff2;</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">F2 f2 = (F2)ff1;</span><br><span class="line">f2(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本人运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">2147483646</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;无论如何改动f1中的第二个参数，最后打印的随机值都不会发生变化。但是如果更换成ff2先执行，ff1后执行，该值就会随着f1中的第二个参数变化而变化。</p><p>简单分析，按照程序执行顺序：</p><ul><li>如果先执行：多形参的函数；会多开辟多的栈空间，但是由于被强转为单形参，另外一个形参值则为一个随机值。后面执行单形参函数，开辟的栈小，多出来的形参会影响到之前双形参的栈空间存放值。</li><li>如果先执行：单形参函数；实际的栈开辟小，打印出来的随机值则不受第二个形参输入的影响(不是明确关系，值波动很大)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="强制转换" scheme="http://shatang.github.io/tags/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="函数指针" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>指针类型_的_函数（函数指针）</title>
    <link href="http://shatang.github.io/2020/03/15/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89/"/>
    <id>http://shatang.github.io/2020/03/15/指针类型-的-函数（函数指针）/</id>
    <published>2020-03-15T03:26:30.000Z</published>
    <updated>2020-03-15T03:31:30.297Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、函数指针的概念"><a href="#一、函数指针的概念" class="headerlink" title="一、函数指针的概念"></a>一、函数指针的概念</h1><h2 id="1-1-什么是函数指针"><a href="#1-1-什么是函数指针" class="headerlink" title="1.1 什么是函数指针"></a>1.1 什么是函数指针</h2><p>&emsp;&emsp;如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><ul><li><strong>函数指针 和 函数名 本质上是一样的，都是指向函数调用地址的指针；</strong></li><li><strong>只是 函数名 是常量指针，函数指针 是变量指针。</strong></li></ul><h2 id="1-2-如何定义函数指针"><a href="#1-2-如何定义函数指针" class="headerlink" title="1.2 如何定义函数指针"></a>1.2 如何定义函数指针</h2><p>&emsp;&emsp;那么这个指针变量怎么定义呢？</p><p>虽然同样是指向一个地址，但指向函数的指针变量和指向变量的指针变量的定义方式是不同的。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个语句就定义了一个指向函数的指针变量p。首先它是一个指针变量，所以要有一个“*”，即（*p）；其次前面的 int 表示这个指针变量可以指向返回值类型为<code>int</code>型的函数；后面括号中的两个<code>int</code>表示这个指针变量可以指向有两个参数且都是<code>int</code>型的函数。所以合起来这个语句的意思就是：定义了一个指针变量<code>p</code>，该指针变量可以指向返回值类型为<code>int</code>型，且有两个整型参数的函数。<code>p</code>的类型为<code>int(*)(int，int)</code>。</p><p>所以函数指针的定义方式为：</p><p><code>函数返回值类型 (* 指针变量名) (函数参数列表);</code></p><ol><li>“函数返回值类型”表示该指针变量可以指向具有什么返回值类型的函数；</li><li>“函数参数列表”表示该指针变量可以指向具有什么参数列表的函数。这个参数列表中只需要写函数的参数类型即可。</li></ol><h2 id="1-3-注意要点"><a href="#1-3-注意要点" class="headerlink" title="1.3 注意要点"></a>1.3 注意要点</h2><blockquote><p>函数指针定义时，(*指针变量名)”两端的括号不能省略</p></blockquote><p>&emsp;&emsp;我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“（*指针变量名）”。但是这里需要注意的是：“(*指针变量名)”两端的括号不能省略，括号改变了运算符的优先级。<strong>如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数(指针函数)</strong>。</p><blockquote><p>如何判断 指针变量 是 指向 变量 还是 函数 ？</p></blockquote><ol><li>首先看变量名前面有没有“*”，如果有“*”说明是指针变量；</li><li>其次看变量名的后面有没有带有形参类型的圆括号，如果有就是指向函数的指针变量，即函数指针，如果没有就是指向变量的指针变量；</li><li>最后需要注意的是，指向函数的指针变量没有 ++ 和 – 运算。</li></ol><h1 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h1><p>&emsp;&emsp;函数指针怎么用？</p><h2 id="2-1-调用例子"><a href="#2-1-调用例子" class="headerlink" title="2.1 调用例子"></a>2.1 调用例子</h2><p>要点分为两个:</p><ol><li>指针 赋值 为函数地址：</li></ol><p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure><p>取地址运算符<code>&</code>不是必需的，因为<strong>一个函数标识符就表示了它的地址</strong>，如果是函数调用，还必须包含一个圆括号括起来的参数表。</p><ol start="2"><li>调用 函数指针：</li></ol><p>调用函数指针的方式也有两种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用函数的写法(*func)()、func()均可；而我们大多数情况下都会写成前者(看上去和普通的函数调用没啥区别)，应该是（C/C++标准制定者）为了方便大家对函数的调用。如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。</p><blockquote><p>简单例子</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;   <span class="comment">/*声明一个函数*/</span></span><br><span class="line"><span class="keyword">int</span> (*p) (<span class="keyword">int</span> x);  <span class="comment">/*定义一个函数指针*/</span></span><br><span class="line">p = Func;          <span class="comment">/*将Func函数的首地址赋给指针变量p*/</span></span><br></pre></td></tr></table></figure><ol><li>赋值时函数 Func 不带括号，也不带参数。</li><li>由于函数名Func代表函数的首地址，因此经过赋值以后，指针变量 p 就指向函数 Func() 代码的首地址了。</li></ol><h2 id="2-2-实际例子"><a href="#2-2-实际例子" class="headerlink" title="2.2 实际例子"></a>2.2 实际例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;      <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>(*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);  <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    p = Max;            <span class="comment">//把函数Max赋给指针变量p, 使p指向Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please enter a and b:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    c = (*p)(a, b);     <span class="comment">//通过函数指针调用Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\nb = %d\nmax = %d\n"</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  <span class="comment">//定义Max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">please enter a and b:<span class="number">3</span> <span class="number">4</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">max = <span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="三、函数指针的优点"><a href="#三、函数指针的优点" class="headerlink" title="三、函数指针的优点"></a>三、函数指针的优点</h1><p>&emsp;&emsp;有的通用函数中要涉用到另一个函数，但函数名称未定，是让用户编的，当然要做成函数指针，即API（application programming interface，应用编程接口）。函数指针的优点，其实就是函数指针的应用：回调函数</p><p><strong>回调函数，本质上都是“你想让别人的代码执行你的代码，而别人的代码你又不能动”这种需求下产生的。</strong></p><blockquote><p>举例1</p></blockquote><p>&emsp;&emsp;别人给你的不是源代码，是一个已经编译好的模块，并且不会给你源代码，那是商业机密，留给你一个接口，你把你要执行的代码以回调函数的形式交给这个接口，由别人编写的模块在需要的时候调用。</p><blockquote><p>举例2</p></blockquote><p>&emsp;&emsp;进行通用定积分计算，被计算函数是待定的，是由调用者确定的函数，这也得是函数指针。</p><h1 id="四、回调函数"><a href="#四、回调函数" class="headerlink" title="四、回调函数"></a>四、回调函数</h1><p>&emsp;&emsp;对指针的应用是C语言编程的精髓所在，而回调函数就是C语言里面对函数指针的高级应用。简而言之，回调函数是一个通过函数指针调用的函数。</p><ul><li><strong>函数指针和函数名本质上是一样的，都是指向函数调用地址的指针；</strong></li><li><strong>只是函数名是常量指针，函数指针是变量指针。</strong></li></ul><h2 id="4-1-回调函数的定义"><a href="#4-1-回调函数的定义" class="headerlink" title="4.1 回调函数的定义"></a>4.1 回调函数的定义</h2><p>&emsp;&emsp;把函数指针（函数的入口地址）传递给另一个函数(的形参)，当这个函数指针被用来调用它所指向的函数时，我们就说这个函数是回调函数。</p><h2 id="4-2-回调函数的意义-简易"><a href="#4-2-回调函数的意义-简易" class="headerlink" title="4.2 回调函数的意义(简易)"></a>4.2 回调函数的意义(简易)</h2><ol><li>其他情况：当一个函数要调用另外一个函数，直接在函数体调用对应的函数；</li><li>回调情况：当一个函数要调用另外一个函数，将另外函数的指针作为形参，当需要调用对应函数时，调用指针进而可调用对应函数。</li></ol><p>&emsp;&emsp;很多朋友可能会想，为什么不像普通函数调用那样，在回调的地方直接写函数的名字呢？这样不也可以吗？为什么非得用回调函数呢？在网上看到解析回调函数的很多例子，其实完全可以用普通函数调用来实现的。</p><p>&emsp;&emsp;要回答这个问题，我们先来了解一下回到函数的好处和作用：那就是解耦。<br>对，就是这么简单的答案，就是因为这个特点，普通函数代替不了回调函数。</p><p>&emsp;&emsp;当你在库函数传入其他函数指针，只要函数指针的函数类型相同，就能做到改动函数指针指向的函数功能，而且还不影响传入(函数)指针形参的库函数(不需要改动)。甚至你可以调用同类型的函数指针 传入 库函数。(例如多驱动，Uart4和Uart5两个串口驱动，只要传入函数指针变动传入指针就行)。</p><h2 id="4-3-回调函数的意义-深入"><a href="#4-3-回调函数的意义-深入" class="headerlink" title="4.3 回调函数的意义(深入)"></a>4.3 回调函数的意义(深入)</h2><p>&emsp;&emsp;<strong><font color="red">函数指针的语法理解上并不难，难就难在对函数指针实现设计模式和设计方法上的运用。</font></strong> </p><p>原因在于，难的不是函数指针的概念和语法本身，而是在什么时候，什么地方该使用它。函数指针不仅是语法上的问题，更重要的是它是一个设计范畴。真正的高手当然不单应该懂得语法层面上的技巧，更应该懂得设计上的方法。不懂设计，能算高手吗？怀疑我在夸大其辞吗？那我们先看看函数指针与哪些设计方法有关：</p><p><strong><em>与分层设计有关</em></strong>。分层设计早就不是什么新的概念，分层的好处是众所周知的，比较明显好处就是简化复杂度、隔离变化。采用分层设计，每层都只需关心自己的东西，这减小了系统的复杂度，层与层之间的交互仅限于一个很窄的接口，只要接口不变，某一层的变化不会影响其它层，这隔离了变化。</p><p>分层的一般原则是，上层可以直接调用下层的函数，下层则不能直接调用上层的函数。这句话说来简单，在现实中，下层常常要反过来调用上层的函数。比如你在拷贝文件时，在界面层调用一个拷贝文件函数。界面层是上层，拷贝文件函数是下层，上层调用下层，理所当然。但是如果你想在拷贝文件时还要更新进度条，问题就来了。一方面，只有拷贝文件函数才知道拷贝的进度，但它不能去更新界面的进度条。另外一方面，界面知道如何去更新进度条，但它又不知道拷贝的进度。怎么办？常见的做法，就是界面设置一个回调函数给拷贝文件函数，拷贝文件函数在适当的时候调用这个回调函数来通知界面更新状态。</p><p><strong><em>与抽象有关</em></strong>。抽象是面向对象中最重要的概念之一，也是面向对象威力强大之处。面向对象只是一种思想，大家都知道，用C语言一样可以实现面向对象的编程。这可不是为了赶时髦，而是一种实用的方法。如果你对此表示怀疑，可以去看看GTK+、linux kernel等开源代码。</p><p>接口是最高级的抽象。在linux kernel里面，接口的概念无处不在，像虚拟文件系统(VFS)，它定义一个文件系统的接口，只要按照这种接口的规范，你可以自己开发一个文件系统挂上去。设备驱动程序更是如此，不同的设备驱动程序有自己一套不同的接口规范。在自己开发设备开发驱动程序时，只要遵循相应的接口规范就行了。接口在C语言中如何表示？很简单，就是一组函数指针。</p><p><strong><em>与接口与实现分开有关</em></strong>。针对接口编程，而不是针对实现编程，此为《设计模式》的第一条设计准则。分开接口与实现的目标是要隔离变化。软件是变化的，如果不能把变化的东西隔离开来，导致牵一发而动全身，代价是巨大的。这是大家所不愿看到的。</p><p>C语言既然可以实现面向对象的编程，自然可以利用设计模式来分离接口与实现。像桥接模式、策略模式、状态模式、代理模式等等，在C语言中，无一不需要利用函数指针来实现。</p><p><strong><em>与松耦合原则有关</em></strong>。面向过程与面向对象相比，之所以显得苍白无力，原因之一就是它不像面向对象一样，可以直观的把现实模型映射到计算机中。面向过程讲的是层层控制，而面向对象更强调的对象间的分工合作。现实世界中的对象处于层次关系的较少，处于对等关系的居多。也就是说，对象间的交互往往是双向的。这会加强对象间的耦合性。</p><p>耦合本身没有错，实际上耦合是必不可少的，没有耦合就没有协作，对象之间无法形成一个整体，什么事也做不了。关键在于耦合要恰当，在实现预定功能的前提下，耦合要尽可能的松散。这样，系统的一部分变化对其它部分的影响会很少。</p><p>函数指针是解耦对象关系的最佳利器。Signal(如boost的signal和glib中的signal)机制是一个典型的例子，一个对象自身的状态可能是在变化的（或者会触发一些事件），而其它对象关心它的变化。一旦该对象有变化发生，其它对象要执行相应的操作。</p><p>如果该对象直接去调用其它对象的函数，功能是完成了，但对象之间的耦合太紧了。如何把这种耦合降到最低呢，signal机制是很好的办法。它的原理大致如下：其它关注该对象变化的对象主动注册一个回调函数到该对象中。一旦该对象有变化发生，就调用这些回调函数通知其它对象。功能同样实现了，但它们之间的耦合度降低了</p><p>在C语言中，要解决以上这些问题，不采用函数指针，将是非常困难的。在编程中，如果你从没有想到用函数指针，很难想像你是一个C语言高手。</p><h2 id="4-4-回调函数的意义-总结"><a href="#4-4-回调函数的意义-总结" class="headerlink" title="4.4 回调函数的意义(总结)"></a>4.4 回调函数的意义(总结)</h2><p>&emsp;&emsp;我们对回调函数的使用无非是对函数指针的应用，函数指针的概念本身很简单，但是把函数指针应用于回调函数就体现了一种解决问题的策略，一种设计系统的思想。</p><p>&emsp;&emsp;在解释这种思想前我想先说明一下，回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。</p><p>&emsp;&emsp;那么什么是回调函数呢，那是不得以而为之的设计策略，想象一种系统实现：在一个下载系统中有一个文件下载模块和一个下载文件当前进度显示模块，系统要求实时的显示文件的下载进度，想想很简单在面向对象的世界里无非是实现两个类而已。但是问题恰恰出在这里，显示模块如何驱动下载进度条？显示模块不知道也不应该知道下载模块所知道的文件下载进度（面向对象设计的封装性，模块间要解耦，模块内要内聚），文件下载进度是只有下载模块才知道的事情，解决方案很简单给下载模块传递一个函数指针作为回调函数驱动显示模块的显示进度。</p><p>&emsp;&emsp;在面向对象的世界中这样的例子还真不少，造成这样的问题的根源，相信大家已经从上面的叙述中体会到了，就是面向对象的程序设计思想，就是设计模式中要求的模块独立性，高内聚低耦合等特性。</p><p>&emsp;&emsp;封装变化的编程策略给编程人员第一位的指导思想就是面向接口编程，即设计模式中提到的面向虚拟编程而不是面向实现。这样的编程思想极大地革新了编程世界，可以说没有这一原则就没有面向对象的程序设计，这一原则给程序设计一种指导思想即如何更高的将现实模型映射成程序模型。这样的设计思想在极大地催生高度独立性模块的同时削弱了模块间的协作性，也就是耦合性，它使得模块间更多的从事着单向的调用工作，一个模块需要某种服务就去找另一个模块，这使得程序呈现出层次性，高层通过接口调用底层，底层提供服务。但是现实世界中严格遵循现层次特性的系统是很少见的，绝对的MVC是不存在的，因为更多的模块要求通并协作，可见没有耦合就没有协作没有好的调用关系，耦合真的不是错。</p><p>&emsp;&emsp;既然我们需要模块间的协作，同时我们又厌恶的摒弃模块间你中有我我中有你的暧昧关系那如何生成系统呢，答案是函数指针（不一定一定是函数指针）也就是使用回调的方式。如果一个对象关心另一个对象的状态变化那么给状态的变化注册回调函数让它通知你这类状态的改变，这样在封装了模块变化的同时实现了模块间的协作关系另辟独径的给对象解耦。</p><h1 id="五、回调函数应用"><a href="#五、回调函数应用" class="headerlink" title="五、回调函数应用"></a>五、回调函数应用</h1><h2 id="5-1-typedef-void-pFunc"><a href="#5-1-typedef-void-pFunc" class="headerlink" title="5.1 typedef void (*pFunc)();"></a>5.1 <code>typedef void (*pFunc)();</code></h2><p>&emsp;&emsp;事实上,为了代码的移植考虑,一般使用typedef定义函数指针类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef int (*funcptr)();</span></span><br><span class="line"><span class="comment">//定义一个返回值为int，不带参数的函数指针</span></span><br><span class="line"><span class="comment">//就是说funcptr 是 int (*)()型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//funcptr table[10]; </span></span><br><span class="line"><span class="comment">//定义一个数组，这个数组是funcptr类型的</span></span><br><span class="line"><span class="comment">//就是说这个数组内的元素都是一个(函数)指针</span></span><br><span class="line"><span class="comment">//这个指针指向一个返回值为int，不带参数的函数</span></span><br></pre></td></tr></table></figure><p>有了函数指针类型，以后我们就可以象变量一样声明函数指针，如下例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pFunc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFunc func;</span><br><span class="line">    unc = &amp;myFunc;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-怎么使用带参数的回调函数？"><a href="#5-2-怎么使用带参数的回调函数？" class="headerlink" title="5.2 怎么使用带参数的回调函数？"></a>5.2 怎么使用带参数的回调函数？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_1</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_1: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_2: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_3</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_3: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Handle</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> (*Callback)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Handle Function. "</span>);</span><br><span class="line">    Callback(y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Handle Function. "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Main Function. "</span>);</span><br><span class="line">    Handle(a, Callback_1);</span><br><span class="line">    Handle(b, Callback_2);</span><br><span class="line">    Handle(c, Callback_3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Main Function. "</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Entering Main Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_1: x = 2</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_2: x = 4</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_3: x = 6</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Leaving Main Function.</span><br><span class="line">``` </span><br><span class="line">&amp;emsp;&amp;emsp;可以看到，并不是直接把&lt;code&gt;int Handle(int (\*Callback)())&lt;/code&gt; 改成 &lt;code&gt;int Handle(int (\*Callback)(int))&lt;/code&gt;  就可以的。而是通过另外增加一个参数来保存回调函数的参数值，像这里 &lt;code&gt;int Handle(int y, int (*Callback)(int))&lt;/code&gt; 的参数 y。同理，可以使用多个参数的回调函数。</span><br><span class="line"></span><br><span class="line">## 5.3 结构体中的函数指针</span><br><span class="line">&amp;emsp;&amp;emsp;C语言中的struct是最接近类的概念，但是在C语言的struct中只有成员，不能有函数，但是可以有指向函数的指针，这也就方便了我们使用函数了。举个例子，如下：</span><br><span class="line">```C</span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">      </span><br><span class="line">typedef struct student  </span><br><span class="line">&#123;  </span><br><span class="line">    int id;  </span><br><span class="line">    char name[50];   </span><br><span class="line">    void (*initial)();  </span><br><span class="line">    void (*process)(int id, char *name);  </span><br><span class="line">    void (*destroy)();  </span><br><span class="line">&#125;stu;  </span><br><span class="line">      </span><br><span class="line">void initial()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;initialization...\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line">void process(int id, char *name)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;process...\n%d\t%s\n&quot;,id, name);  </span><br><span class="line">&#125;  </span><br><span class="line">     </span><br><span class="line">void destroy()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;destroy...\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    stu *stu1;  </span><br><span class="line">    //在VC和TC下没有malloc也可以正常运行，但是linux gcc下就会出错，为段错误，必须使用malloc  </span><br><span class="line">    stu1=(stu *)malloc(sizeof(stu));  </span><br><span class="line">    //使用的时候必须要先初始化  </span><br><span class="line">    stu1-&gt;id=1000;  </span><br><span class="line">    strcpy(stu1-&gt;name,&quot;C++&quot;);  </span><br><span class="line">    stu1-&gt;initial=initial;  </span><br><span class="line">    stu1-&gt;process=process;  </span><br><span class="line">    stu1-&gt;destroy=destroy;  </span><br><span class="line">    printf(&quot;%d\t%s\n&quot;,stu1-&gt;id,stu1-&gt;name);  </span><br><span class="line">    stu1-&gt;initial();  </span><br><span class="line">    stu1-&gt;process(stu1-&gt;id, stu1-&gt;name);  </span><br><span class="line">    stu1-&gt;destroy();  </span><br><span class="line">    free(stu1);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端显示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span>    C++</span><br><span class="line">initialization...</span><br><span class="line">process...</span><br><span class="line"><span class="number">1000</span>    C++</span><br><span class="line">destroy..</span><br></pre></td></tr></table></figure><p><strong><font color="red">Ps：</font></strong>无论是什么类型(结构体也是)的指针，都要主要初始化(或赋内存)。</p><h2 id="5-3-结构体拓展——协议类"><a href="#5-3-结构体拓展——协议类" class="headerlink" title="5.3 结构体拓展——协议类"></a>5.3 结构体拓展——协议类</h2><p>&emsp;&emsp;c语言中，如何在结构体中实现函数的功能？把结构体做成和类相似，让他的内部有属性，也有方法，<br>这样的结构体一般称为协议类，提供参考： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">　　<span class="keyword">int</span> funcid; </span><br><span class="line">　　<span class="keyword">char</span> *funcname; </span><br><span class="line">　　<span class="keyword">int</span> (*funcint)();   <span class="comment">/* 函数指针 int 类型*/</span> </span><br><span class="line">　　<span class="keyword">void</span> (*funcvoid)();  <span class="comment">/* 函数指针 void类型*/</span> </span><br><span class="line">&#125;XXX;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每次都要注意：需要初始化。</p><p>该回调函数的用法为： </p><ol><li>甲方进行结构体的定义（成员中包括回调函数的指针）</li><li>乙方定义结构体变量，并向甲方注册， </li><li>甲方收集N个乙方的注册形成结构体链表，在某个特定时刻遍历链表，进行回调。 </li><li>当函数指针做为函数的参数，传递给一个被调用函数，被调用函数就可以通过这个指针调用外部的函数，这就形成了回调</li><li>一般的程序中回调函数作用不是非常明显，可以不使用这种形式</li><li>最主要的用途就是当函数不处在同一个文件当中，比如动态库，要调用其他程序中的函数就只有采用回调的形式</li><li>通过函数指针参数将外部函数地址传入来实现调用函数的代码作了修改，也不必改动库的代码(只是函数指针指向的函数修改变动，库的处理没有变动)，就可以正常实现调用便于程序的维护和升级 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="函数指针" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
      <category term="函数" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>指针类型_的_函数返回值(指针函数)</title>
    <link href="http://shatang.github.io/2020/03/15/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/"/>
    <id>http://shatang.github.io/2020/03/15/指针类型-的-函数返回值-指针函数/</id>
    <published>2020-03-15T03:13:04.000Z</published>
    <updated>2020-03-15T03:25:37.433Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、函数返回值的要点"><a href="#一、函数返回值的要点" class="headerlink" title="一、函数返回值的要点"></a>一、函数返回值的要点</h1><p><strong><font color="red">注意（原则）</font></strong>：可以返回局部变量本身，<strong>但永远不要返回一个局部变量的指针或引用(其实是隐式的指针)</strong>；</p><p>原因：<strong>局部变量只是临时的存储空间，因为函数执行完之后，将释放分配给局部变量的存储空间</strong>，此时，对局部变量的引用和地址就会返回不确定的内存(野指针)。</p><blockquote><p>系统堆栈的知识点</p></blockquote><p>&emsp;&emsp;函数调用过程中，一个函数在调用另外一个函数的时候，会先将调用前的现场信息保存在系统堆栈中，然后按照从又向左的顺序(c语言)将实参的结果入栈，而被调用的函数的形参，用的就是实参的空间，当被调用的函数运行结束后，局部变量的空间被“释放”的本质，其实是栈顶的指针，移动到了调用前函数的现场信息的地方，所以刚才被调用的函数的局部变量，实际上它的值还是存放在内存中，并且在当前栈顶指针的上面的连续空间中。</p><blockquote><p>简单理解</p></blockquote><p>&emsp;&emsp;函数执行完，局部变量会被释放，此时指向 已释放的局部变量 的指针 是很危险(不确定)的；如果不调用还好(但不调用，那要返回值干嘛?)；</p><p>&emsp;&emsp;一旦其他函数调用该函数返回值指针，该指针指向的内存不确定就会造成不可知的错误。</p><h1 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h1><ol><li><p>返回变量本身</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个返回变量本身内存可以，正确</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回局部变量指针，用法错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> &amp;sum;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>会出现以下警告： </p><p><code>warning: function returns address of local variable [-Wreturn-local-addr] return &amp;sum;</code></p><p>警告：函数返回地址是局部变量地址—&gt;这是不安全的</p><h1 id="三、解决方案和利弊"><a href="#三、解决方案和利弊" class="headerlink" title="三、解决方案和利弊"></a>三、解决方案和利弊</h1><h2 id="3-1-解决方案"><a href="#3-1-解决方案" class="headerlink" title="3.1 解决方案"></a>3.1 解决方案</h2><p>该如何解决这种错误呢？有以下3种常用方案：</p><ol><li>使用静态变量</li><li>使用全局变量</li><li>申请堆区变量</li></ol><p>其实，使用这三种方法都是为了延长变量的声明周期，从而达到返回的地址是确定的而不是不确定的。</p><p>法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> &amp;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* sum = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> *result;</span><br><span class="line">    result = add(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但法3需要注意，由于用new申请的动态内存，调用者（这里是main）需要释放这个申请的指针free, delete</p><h2 id="3-2-利弊"><a href="#3-2-利弊" class="headerlink" title="3.2 利弊"></a>3.2 利弊</h2><ol><li>法3的 申请堆区变量 比较麻烦，一般不常用；</li><li>法2的 使用全局变量 比较鸡肋；如果是全局变量的(函数返回值)指针，为啥不直接调用该指针，函数就不需要返回(全局)指针，该返回值充其量像是 提示 ，或者是函数格式要求</li><li>法1的 使用局部变量 比较推荐</li></ol><blockquote><p>总结：指针类型的函数返回值 还是不推荐用。</p></blockquote><p>&emsp;&emsp;采用<code>return</code>语句返回的指针，原本想法是让函数返回多个数值(数组、结构体)；但<strong>指针往往是作为函数形参来直接改变实参(数值)，从而让函数变相返回多个数值</strong>；因此，指针类型的函数返回值，功能少且鸡肋(容易出事)，不推荐使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="函数" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数返回值" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>指针类型_的_函数形参</title>
    <link href="http://shatang.github.io/2020/03/15/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82/"/>
    <id>http://shatang.github.io/2020/03/15/指针类型-的-函数形参/</id>
    <published>2020-03-15T03:03:12.000Z</published>
    <updated>2020-03-15T03:10:58.442Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、指针作为函数参数"><a href="#一、指针作为函数参数" class="headerlink" title="一、指针作为函数参数"></a>一、指针作为函数参数</h1><h2 id="1-1-函数参数的传递方式"><a href="#1-1-函数参数的传递方式" class="headerlink" title="1.1 函数参数的传递方式"></a>1.1 函数参数的传递方式</h2><p>C语言的函数参数的传递方式有以下两种：</p><ol><li><strong>值传递</strong>：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</li><li><strong>指针传递</strong>：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作</li></ol><h2 id="1-2-函数相关的知识"><a href="#1-2-函数相关的知识" class="headerlink" title="1.2 函数相关的知识"></a>1.2 函数相关的知识</h2><ol><li>函数(return)返回值：实际一般是返回(处理过的)局部变量；且只能返回单个值；</li><li>指针作为函数参数，<strong>指针能使被调函数(变相)返回一个以上的结果</strong>。（直接对内存操作3改变多个实参）</li><li>函数内部修改外部变量的值，需要一级指针；</li><li>函数内部修改外部指针变量的值，需要二级指针；</li></ol><p>所以要想直接对内存单元进行操控，用指针最直接，指针的功能很强大。</p><h2 id="1-3-举例"><a href="#1-3-举例" class="headerlink" title="1.3 举例"></a>1.3 举例</h2><hr><p>经典例子1 ：交换CET1 和 CET2 的值（一级指针交换值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wrong</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_val</span><span class="params">(<span class="keyword">int</span> a,intb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误原因：因为交换的是副本(形参)，真品(实参)没改变的。</p><hr><p>经典例子2：是在学习STM32的库函数的使用。当初刚接触库函数，对于函数初始化接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><p>分析：为什么要取初始化结构体变量的地址传递进库函数（&amp;GPIO_InitStructure），而不是直接将结构体变量本身（GPIO_InitStructure）传递进去？</p><hr><h1 id="二、实际例子"><a href="#二、实际例子" class="headerlink" title="二、实际例子"></a>二、实际例子</h1><h2 id="2-1-两数值交换"><a href="#2-1-两数值交换" class="headerlink" title="2.1 两数值交换"></a>2.1 两数值交换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    Swap(&amp;i, &amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d, j = %d\n"</span>, i, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf;</span><br><span class="line">    buf = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = buf;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：i = 5, j = 3</p><p>&emsp;&emsp;此时实参向形参传递的不是变量 i 和 j 的数据，而是变量 i 和 j 的地址。其实传递指针也是拷贝传递，只不过它拷贝的不是内存单元中的内容，而是内存单元的地址，这就是天壤之别了。拷贝地址就可以直接对地址所指向的内存单元进行操作，即此时被调函数就可以直接对变量 i 和 j 进行操作了。有人会说：“被调函数用完就释放了，不就把 i 和 j 都释放了吗？”不是的，当函数调用完之后，释放的是 p 和 q，不是 i 和 j。p 和 q 中存放的是 i 和 j 的地址。所以 p 和 q 被释放之后并不会影响 i 和 j 中的值。前面讲过，修改指针变量的值不会影响所指向变量中的数据。只不过它们之间的指向关系没有了而已。 </p><p>此外需要注意的是，形参中变量名分别为 p 和 q，变量类型都是 int* 型。所以实参 i 和 j 的地址，即 &amp;i 和 &amp;j 是分别传递给 p 和 q，而不是传递给 *p 和 *q。</p><blockquote><p><strong>函数参数传指针和传数据的区别</strong></p></blockquote><p>&emsp;&emsp;综上所述，如果希望在另外一个函数中修改本函数中变量的值，那么在调用函数时只能传递该变量的地址。如果这个变量是普通变量，那么传递它的地址就可以直接操作该变量的内存空间。</p><p>&emsp;&emsp;那么，是不是要定义一个指针变量指向它然后传递这个指针变量呢？不用多此一举。比如有一个“int i；”，如果想传递i的地址那就直接传递 &amp;i 就行了，不用专门定义一个指针变量指向它，然后再传递这个指针变量。</p><p>如果要传递的变量本身就是一个指针变量怎么办？如果要操作该指针变量所指向的内存空间是不是要传递该指针变量的地址呢？</p><p>&emsp;&emsp;指针变量本身就是地址，本身就是指向那个内存空间的，所以直接把它传过去就行了。除非你要改变那个指针变量里面存放的地址，即你要改变指针变量的指向，那么你就必须要传递指针变量的地址。<br>指针可以使得函数返回一个或者一个以上的值</p><h2 id="2-2-数组中的n个元素的值分别减去20"><a href="#2-2-数组中的n个元素的值分别减去20" class="headerlink" title="2.2 数组中的n个元素的值分别减去20"></a>2.2 数组中的n个元素的值分别减去20</h2><blockquote><p>需求分析:编写函数,要求将数组中的n个元素的值分别减去20</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">traverseArray</span><span class="params">(<span class="keyword">int</span> *pArr,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">subArray</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subArray1</span><span class="params">(<span class="keyword">int</span> * pArr,<span class="keyword">int</span> length )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">traverseArray</span><span class="params">(<span class="keyword">int</span> *pArr,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,*(pArr+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组中所有元素都减去20</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">subArray</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = a[i] - <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组中所有元素都减去20</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subArray1</span><span class="params">(<span class="keyword">int</span> * pArr,<span class="keyword">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(pArr + i) = *( pArr + i) - <span class="number">20</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N]=&#123;<span class="number">51</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">58</span>,<span class="number">59</span>,<span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原来数组中的元素为:\n"</span>);</span><br><span class="line">    traverseArray(a,N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组中元素第一次减去20后为:\n"</span>);</span><br><span class="line">    subArray(a,N);</span><br><span class="line">    traverseArray(a,N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组中元素第二次减去20后为:\n"</span>);</span><br><span class="line">    subArray1(a,N);</span><br><span class="line">    traverseArray(a,N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：</p><ol><li>不允许拷贝数组；</li><li>使用数组时通常会将其转换成指针。</li></ol><p>&emsp;&emsp;因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。<br>因此数组会被转换成指针(数组退化现象)，所以当我们为<strong>函数传递一个数组时，实际上传递的是指向数组首元素的指针</strong>。</p><p>尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽管形式不同，但这三个printf函数是等价的</span></span><br><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span><span class="comment">//这里的维度表示我们期望数组含有多少元素，实际不一定</span></span></span><br></pre></td></tr></table></figure><p>当编译器处理对printf函数的调用时，只检查传入的参数是否是const int*类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">print(&amp;i);  <span class="comment">//正确，&amp;i的类型是int*</span></span><br><span class="line">print(j);   <span class="comment">//正确，j被转换成int*并指向j[0]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果我们传给printf函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。</p><h1 id="三、指针作为函数参数的好处"><a href="#三、指针作为函数参数的好处" class="headerlink" title="三、指针作为函数参数的好处"></a>三、指针作为函数参数的好处</h1><p>&emsp;&emsp;此外，传指针和传数据相比还有一个好处就是节约内存。我们知道，传数据拷贝的是内存单元的数据，如果数据很多的话拷贝过来都要为它们分配内存。而传指针的话只需要传递 4 字节的地址就行了。而且传数据非常消耗效率，为形参分配内存需要时间，拷贝需要时间，最后结束了返回还是需要时间。前面说过，return时系统会先自动创建一个临时变量来存放返回的值。所以传数据时很消耗效率，而传指针就是为了提高效率。</p><p>&emsp;&emsp;事实上，在实际编程中我们都是传递指针！</p><p>往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可：</p><ol><li>数据很小，比如就一个 int 型变量。</li><li>不需要改变它的值，只是使用它的值。</li></ol><p>此时不是不能用指针，当然也可以用指针，只是没有必要。</p><p>&emsp;&emsp;以后在使用函数的时候，只要函数的参数不满足上面这两个条件，那么就用指针。此外需要注意的是，数组名本身就是地址，所以如果传递数组的话直接传递数组名就行了。接收的形参可以定义成数组(形式方面上而已)也可以定义为同类型的指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="函数" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数形参" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82/"/>
    
  </entry>
  
</feed>
