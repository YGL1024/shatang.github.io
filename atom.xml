<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大道至简，悟在天成</title>
  
  <subtitle>It&#39;s not hard to give up, but it must be cool to stick to it.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shatang.github.io/"/>
  <updated>2020-05-30T02:53:42.569Z</updated>
  <id>http://shatang.github.io/</id>
  
  <author>
    <name>Shatang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Modbus协议_具体实现</title>
    <link href="http://shatang.github.io/2020/05/30/Modbus%E5%8D%8F%E8%AE%AE-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://shatang.github.io/2020/05/30/Modbus协议-具体实现/</id>
    <published>2020-05-30T02:52:04.000Z</published>
    <updated>2020-05-30T02:53:42.569Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式</p><a id="more"></a><h1 id="一、搭建环境-amp-简介"><a href="#一、搭建环境-amp-简介" class="headerlink" title="一、搭建环境&amp;简介"></a>一、搭建环境&amp;简介</h1><ol><li>采用的是stm32f103RBT6为例</li><li>从机实现采用 FreeModbus库</li><li>Modbus TCP通讯是基于 W5500 实现的</li></ol><p>&emsp;&emsp;这里主要讲解的是Modbus从机(Server)的实现。因为实际产品常用于采集数据或做动作处理，一般是作为从设备，接入Plc(Modbus主机)。</p><h1 id="二、Modbus主机-Master"><a href="#二、Modbus主机-Master" class="headerlink" title="二、Modbus主机(Master)"></a>二、Modbus主机(Master)</h1><p>&emsp;&emsp;Modbus主机一般很少用到。主要用途，一般用于：实际产品分为前后台，后台做所有的数据处理，作为Modbus从机；而前台主要用于做界面显示，即作为Modbus主机，界面数据修改通过串口Modbus通讯。</p><p>&emsp;&emsp;由于是前后台的内置通讯，常用的Modbus主机 当然是采用<strong>方便、可靠</strong>的 Modbus RTU通讯。</p><p>&emsp;&emsp;当然由于前后台通讯占用一个硬件串口Modbus通讯。因此，常见的Modbus从机，往往是具有多串口Modbus通讯，共享一套地址处理数据(当然，可能前后台内置通讯在实际产品说明书中被隐藏)。</p><hr><p>&emsp;&emsp;Modbus主机，在网上是没有开源，只有收费版本的。其实只要根据Modbus协议，很容易就能写一个Modbus主机。</p><p>唯一需要注意的点：每个数据帧发送之间的间隔为 3.5T；防止从机接收到的数据黏合。</p><p>&emsp;&emsp;但是由于Modbus主机一般要处理其他事宜，往往本身每个数据帧发送之间的间隔都 &gt; 3.5T。因此实际上，写得不标准也能用；当然严谨一点的话，写一个定时器，发送就开启定时器，定时器溢出置标志位才能再次发送也是可以的。</p><h1 id="三、Modbus从机-Slave"><a href="#三、Modbus从机-Slave" class="headerlink" title="三、Modbus从机(Slave)"></a>三、Modbus从机(Slave)</h1><p>&emsp;&emsp;这里的Modbus从机是基于 FreeModbus库 实现的。  </p><p>&emsp;&emsp;Freemodbus库的代码是写得很好的，如果C语言学得好，且对Modbus协议了解的话，建议直接看源码，多看多观察可以提高自己的代码水平。</p><h2 id="3-1-FreeModbus移植-RTU模式"><a href="#3-1-FreeModbus移植-RTU模式" class="headerlink" title="3.1 FreeModbus移植(RTU模式)"></a>3.1 FreeModbus移植(RTU模式)</h2><p>&emsp;&emsp;FreeModbus详细移植方法可以参照以下博主：</p><p><a href="http://www.openedv.com/forum.php?mod=viewthread&tid=69081&extra=page%3D2" target="_blank" rel="noopener">FreeModbus在STM32上移植</a></p><p><a href="https://blog.csdn.net/qq_33611327/article/details/77883787" target="_blank" rel="noopener">STM32上移植FreeModbus详细过程</a></p><h2 id="3-2-如何计算RTU模式的-3-5T-超时时间？"><a href="#3-2-如何计算RTU模式的-3-5T-超时时间？" class="headerlink" title="3.2 如何计算RTU模式的 3.5T 超时时间？"></a>3.2 如何计算RTU模式的 3.5T 超时时间？</h2><p><strong>波特率</strong>：每秒钟通过信道传输的信息量称为位传输速率，也就是每秒钟传送的二进制位数,简称比特率。</p><p><strong>比特率</strong>：表示有效数据的传输速率，用b/s 、bit/s、比特/秒，读作：比特每秒。</p><hr><p>通常的串口桢格式为10位：<code>开始位1bit + 数据位8bit + 停止位1bit</code></p><p>&emsp;&emsp;如9600b/s：指总线上每秒可以传输9600个bit；也就是说：在9600的波特率下，每秒可以传输出的桢数为：9600 / (1 + 8 + 1) = 960桢/秒，即960字节/秒(实际数据速率)；</p><p>反推：一帧或一字节数据需要的时间是多少呢？</p><p>1s / 960 = 1.4ms</p><p>而ModBus协议中超时时间定为：3.5个帧长度为超时时间；</p><ul><li>超时时间 <ul><li>= 3.5 * 1 / BaudRate / 10 秒</li><li>= 3.5 * 10 / BaudRate 秒</li><li>= 3.5 * 10  * 2 / BaudRate  * 2 秒</li><li>=  70 / BaudRate  * 2 秒</li></ul></li></ul><hr><p>FreeModBus是这样实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If baudrate &gt; 19200 then we should use the fixed timer values</span></span><br><span class="line"><span class="comment">* t35 = 1750us. Otherwise t35 must be 3.5 times the character time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>( ulBaudRate &gt; <span class="number">19200</span> )</span><br><span class="line">&#123;</span><br><span class="line">    usTimerT35_50us = <span class="number">35</span>;       <span class="comment">/* 1800us. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The timer reload value for a character is given by:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 )</span></span><br><span class="line"><span class="comment">    *             = 11 * Ticks_per_1s / Baudrate</span></span><br><span class="line"><span class="comment">    *             = 220000 / Baudrate</span></span><br><span class="line"><span class="comment">    * The reload for t3.5 is 1.5 times this value and similary</span></span><br><span class="line"><span class="comment">    * for t3.5.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    usTimerT35_50us = ( <span class="number">7U</span>L * <span class="number">220000U</span>L ) / ( <span class="number">2U</span>L * ulBaudRate );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>波特率大于19200使用定值：1800us</li></ul><p>&emsp;&emsp;由于将<code>usTimerT35_50us = 35;</code>直接带入，在定时器驱动初始化实际代入的计算值为 (35 = 36-1)，因此实际的定时时间为：36 * 50(基值) = 1800 us。</p><ul><li>波特率小于19200使用定值：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usTimerT35_50us = ( <span class="number">7U</span>L * <span class="number">220000U</span>L ) / ( <span class="number">2U</span>L * ulBaudRate );</span><br></pre></td></tr></table></figure></li></ul><hr><p>解析：由于Modbus的RTU模式是串口帧格式为11位，故</p><ul><li>超时时间 (50us为单位)<ul><li>= 3.5 * 1 / BaudRate / 11 秒</li><li>= 3.5 * 11 / BaudRate 秒</li><li>= 3.5 * 11  * 2 / BaudRate  * 2 秒</li><li>= 7 * 11 / BaudRate  * 2 秒</li><li>= 7 * 11 * 1000000 / 50 / BaudRate  * 2 (50us为单位)</li><li>= 7 * 220000 / BaudRate * 2 (50us为单位)</li></ul></li></ul><p>&emsp;&emsp;这usTimerT35_50us一个单位为50uS，将这个超时时间计算结果用于定时器驱动初始化。每中断一次为50us * usTimerT35_50us 微秒；<strong>且每次更改Modbus通信的波特率，Modbus的定时器驱动初始化都要更新一次，更新定时器计数溢出值</strong>。</p><h1 id="四、-FreeModbus库源码"><a href="#四、-FreeModbus库源码" class="headerlink" title="四、 FreeModbus库源码"></a>四、 FreeModbus库源码</h1><p>&emsp;&emsp;3.1所提到的移植，是把RTU模式通讯的底层给移植好，报文中的具体<strong>数据单元处理功能函数</strong>还是得自己继续写。</p><p>&emsp;&emsp;但暂先不讲具体的<strong>数据单元处理功能函数</strong>写法，先讲解整个FreeModbus源码的实现过程，使其后面更清晰如何写数据单元处理功能函数，甚至可以自己移植、扩展改动(ASCII、TCP模式)。</p><h2 id="4-1-实现的核心原理"><a href="#4-1-实现的核心原理" class="headerlink" title="4.1 实现的核心原理"></a>4.1 实现的核心原理</h2><p>&emsp;&emsp;每一帧的数据区分是采用3.5T的方法。那么MCU具体的实现方法思路如下：</p><p>&emsp;&emsp;使能串口接收中断，一但接收到数据(触发串口接收中断)，就开启定时器，每一次重新触发串口接收中断，就会重启定时器&amp;重新计数；直到不触发串口接收中断，导致定时器溢出，此时视为接收一帧完整数据，开始解析数据。再根据自己喜好响应主机的信息。</p><p>&emsp;&emsp;以上就是整体思路，你甚至可以根据这个思路自己实现Modbus通讯的从机部分。接下来就是FreeModbus同样思路实现方式的讲解</p><h2 id="4-2-FreeModbus库通讯实现讲解-RTU模式为例"><a href="#4-2-FreeModbus库通讯实现讲解-RTU模式为例" class="headerlink" title="4.2 FreeModbus库通讯实现讲解(RTU模式为例)"></a>4.2 FreeModbus库通讯实现讲解(RTU模式为例)</h2><ol><li>Modbus通讯驱动初始化后，(使能函数)将 串口接收中断 置为 初始化状态</li><li>串口接收中断 在初始化状态下，打开定时器</li><li>等待定时器溢出后，触发定时器中断，关闭定时器，定时器中断处理 串口接收中断状态机，发现是 初始化状态 。此时再将 串口接收中断 置为 空闲状态，同时将 将<code>eMBPoll</code>的 事件状态机 置为 初始化。</li><li><strong>以上就是初始化完成，接下来就是数据收发的流程了</strong></li><li>串口接收中断触发，空闲状态下打开定时器，且获取一个接收字节。此时 Modbus串口接收中断状态机 置为 接收状态。</li><li>每次串口接收中断触发，刷新定时器时间，防止定时器溢出。接收状态下，接收字节如果不溢出，则继续接收(溢出报错)。</li><li>当串口接收中断延迟一段时间(或者不再接收到数据)，该时间让定时器溢出。此时定时器中断，并将 Modbus串口接收中断 置为 空闲状态</li><li>由于定时器溢出，视为接收一帧完整的数据帧。将 Poll的 事件状态机 置为 接收完成。</li><li>eMBPoll的 事件状态机 为<code>Frame received</code>接收完成，开始核对数据。数据长度&gt;4(ID+功能码+校验) &amp;&amp; CRC校验成功</li><li>核对成功后，(用指针方式获取数据PDU，数据长度= 总长度-地址域(ID 1字节)-CRC(检验 2字节)。核对失败，则报 <code>MB_EIO</code>的错误。</li><li>经过核对，校验成功后，如果ID正确 或 为0。则将eMBPoll的 事件状态机 置为<code>Execute function</code> 执行数据函数(事件)。开始对数据进行处理。</li><li>这里对功能码的选择处理，是采用一个结构体数组，每个结构体成员内含 1个功能码+功能码对应要执行的(回调)函数。然后for循环，匹配出对应的功能码，并进行处理；如果功能码为0则直接跳出。</li><li>如果ID号不是广播地址0，则从机会进行响应。之前进行对应功能码处理函数 得出结果，如果报错，则后续的响应 <code>功能码|0x80 + 错误代码</code>。</li><li>举例，返回 01 83 02 C0 F1。即 读错误(0x03&amp;0x80)，非法数据地址(0x02)，后面两个为CRC校验。</li><li>在处理完后会返回一个enum状态值。如果状态 不为<code>MB_ENOERR</code>，即内部使用的错误代码，根据内部使用的<code>enum</code>错误代码，<code>switch</code>生成 对外的错误代码</li><li>返回的CRC会在发送前先把CRC校验完成。</li><li>发送前，检查能不能数据接收，能接收则报硬件错误<code>MB_EIO</code>，因为协议规定只能单向收发</li><li>发送一个字节数据，然后开启发送中断，一直发送，直到完成</li><li>发送完成后，将 eMBPoll的 事件状态机 置为 发送完成</li><li>事件状态机 为 发送完成状态，该状态触发 将 发送中断状态机 置为 发送空闲</li></ol><p>&emsp;&emsp;以上就是FreeModbus库实现<code>Modbus RTU</code>通讯的方式。其他模式就大同小异，里面很多具体的实现，采用了指针的方式，尤其是函数指针，在初始化函数内可见一斑。这个库源码写的很好，如果是嵌入式新手，这份源码还是很推荐看的。</p><p>&emsp;&emsp;如果顺着程序缕是能看得懂的，这里再留一份函数==笔记==，方便小白初次看时疑惑，可查阅一下。</p><h2 id="4-3-数据单元处理功能函数"><a href="#4-3-数据单元处理功能函数" class="headerlink" title="4.3 数据单元处理功能函数"></a>4.3 数据单元处理功能函数</h2><p>这里的写法思路分为3个部分：</p><ul><li>第一部分函数用于对应FreeModbus库编写的处理函数<ul><li>例如，库里面处理到最后，总是地址+1,；可以在这里去掉</li><li>这里用来区分 读、写 </li></ul></li><li>第二部分函数用于自己应用层的地址约束<ul><li>并可以对不同地址块进行不同处理</li></ul></li><li>第三部分函数用于具体地址的详细操作</li></ul><h2 id="4-3-1-数据单元初步处理"><a href="#4-3-1-数据单元初步处理" class="headerlink" title="4.3.1 数据单元初步处理"></a>4.3.1 数据单元初步处理</h2><p>&emsp;&emsp;编写具体如下四个函数对应FreeModbus库的处理：</p><ul><li>eMBRegCoilsCB</li><li>eMBRegHoldingCB</li><li>eMBRegDiscreteCB</li><li>eMBRegInputCB<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  eMBRegCoilsCB</span></span><br><span class="line"><span class="comment">* 功  能 :  线圈回复函数</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  *pucRegBuffer : 要添加到协议中的数据</span></span><br><span class="line"><span class="comment">*           usAddress     : 线圈地址(PLC地址)</span></span><br><span class="line"><span class="comment">*           usNRegs       : 要访问线圈的个数</span></span><br><span class="line"><span class="comment">*           eMode         : 访问类型（MB_REG_READ为读线圈状态，MB_REG_WRITE为写线圈）</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus       : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">eMBRegCoilsCB</span><span class="params">( UCHAR * pucRegBuffer, </span></span></span><br><span class="line"><span class="function"><span class="params">                            USHORT usAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">                            USHORT usNCoils, </span></span></span><br><span class="line"><span class="function"><span class="params">                            eMBRegisterMode eMode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eMBErrorCode    eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    usAddress--;<span class="comment">// 由PLC地址转为协议地址  </span></span><br><span class="line">    <span class="keyword">switch</span> ( eMode )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MB_REG_READ:</span><br><span class="line">            eStatus = AppFMD_RdCoils(usNCoils,usAddress,pucRegBuffer);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MB_REG_WRITE:</span><br><span class="line">            eStatus = AppFMD_WrCoils(usNCoils,usAddress,pucRegBuffer);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eStatus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  eMBRegHoldingCB</span></span><br><span class="line"><span class="comment">* 功  能 :  保持寄存器回复函数</span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  *pucRegBuffer : 要添加到协议中的数据</span></span><br><span class="line"><span class="comment">*           usAddress     : 寄存器地址</span></span><br><span class="line"><span class="comment">*           usNRegs       : 访问寄存器的个数</span></span><br><span class="line"><span class="comment">*           eMode         : 访问类型（MB_REG_READ为读保持寄存器，MB_REG_WRITE为写保持寄存器）</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus       : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">eMBRegHoldingCB</span><span class="params">(   UCHAR * pucRegBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                USHORT usAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                                USHORT usNRegs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                eMBRegisterMode eMode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eMBErrorCode    eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    usAddress--;<span class="comment">// 由PLC地址转为协议地址</span></span><br><span class="line">    <span class="keyword">if</span> (eMode == MB_REG_READ)</span><br><span class="line">        eStatus = AppFMD_RdRegs(usNRegs,usAddress,pucRegBuffer);</span><br><span class="line">    <span class="keyword">if</span>(eMode == MB_REG_WRITE)</span><br><span class="line">        eStatus = AppFMD_WrRegs(usNRegs,usAddress,pucRegBuffer);</span><br><span class="line">    <span class="keyword">return</span> eStatus; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-2-线圈和寄存器处理"><a href="#4-3-2-线圈和寄存器处理" class="headerlink" title="4.3.2 线圈和寄存器处理"></a>4.3.2 线圈和寄存器处理</h3><p>&emsp;&emsp;根据 <strong>4.3.1</strong>，只编写可读写线圈和寄存器的函数，具体对应函数如下：</p><ul><li>eMBErrorCode AppFMD_RdCoils(uint32_t si_num, uint32_t uiAddr, uint8_t *puc_txpointer)</li><li>eMBErrorCode AppFMD_WrCoils(uint32_t si_num, uint32_t uiAddr,uint8_t *puc_txpointer)</li><li>最好在这块函数进行总的地址划分<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* 函数名 :  </span></span><br><span class="line"><span class="comment">* 功  能 :  </span></span><br><span class="line"><span class="comment">* 说  明 :  none</span></span><br><span class="line"><span class="comment">* 入  参 :  si_num          : 待读的 线圈|寄存器 个数</span></span><br><span class="line"><span class="comment">*           uiAddr          : 地址索引  从0起始</span></span><br><span class="line"><span class="comment">*           *puc_txpointer  : 输出缓存</span></span><br><span class="line"><span class="comment">* 返  回 :  eStatus         : 处理结果</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="function">eMBErrorCode <span class="title">AppFMD_RdRegs</span><span class="params">(<span class="keyword">uint32_t</span> lNum, <span class="keyword">uint32_t</span> ulAddr,<span class="keyword">uint8_t</span> *puc_txpointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    eMBErrorCode eStatus = MB_ENOERR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部参数</span></span><br><span class="line">    <span class="keyword">if</span>(ulAddr&lt;<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(lNum)</span><br><span class="line">        &#123;</span><br><span class="line">            puc_txpointer = BuiltReadWord(ulAddr, puc_txpointer);</span><br><span class="line">            lNum -= <span class="number">1</span>; </span><br><span class="line">            ulAddr += <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户自定义参数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ulAddr&gt;=<span class="number">1000</span> &amp;&amp; ulAddr&lt;<span class="number">1400</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(lNum)</span><br><span class="line">        &#123;</span><br><span class="line">            puc_txpointer = BuiltReadWord_Double(ulAddr, puc_txpointer);</span><br><span class="line">            lNum -= <span class="number">2</span>; </span><br><span class="line">            ulAddr += <span class="number">2</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        eStatus = MB_ENOREG;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> eStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-3-用户自定义的-线圈-amp-寄存器-处理"><a href="#4-3-3-用户自定义的-线圈-amp-寄存器-处理" class="headerlink" title="4.3.3 用户自定义的 线圈 &amp; 寄存器 处理"></a>4.3.3 用户自定义的 线圈 &amp; 寄存器 处理</h3><p>&emsp;&emsp;根据 <strong>4.3.2</strong>，在对应的函数写具体到某个地址位的操作就行了。</p><h1 id="五、通讯报文讲解"><a href="#五、通讯报文讲解" class="headerlink" title="五、通讯报文讲解"></a>五、通讯报文讲解</h1><p>&emsp;&emsp;这里是方便没接触过Modbus的人，或者是长时间没用急用，直接来查阅Modbus报文的；好清楚是哪里出的问题(主机 or 从机？)。</p><h2 id="5-1-报文格式总结"><a href="#5-1-报文格式总结" class="headerlink" title="5.1 报文格式总结"></a>5.1 报文格式总结</h2><p>&emsp;&emsp;首先，如果从机是返回很短的(报错)报文，直接看功能码位，例如 0x83 ；去掉 &amp; 0x80 的操作，那就是 功能码 0x03 出现错误。</p><ul><li>主机的读取数据命令(长度)是固定的：ID + 功能码 + 地址 + 数据长度 + CRC16</li><li>从机返回的数据格式不是固定的：<ul><li>读取长度为1：ID + 功能码 + 数据长度 + 数据1 + CRC16</li><li>读取长度为2：ID + 功能码 + 数据长度 + 数据1 + 数据2 + CRC16</li></ul></li></ul><hr><ul><li>主机的写入数据格式不是固定的</li><li>从机返回数据格式(长度)是固定的(与上面的相反)</li></ul><h2 id="5-2-报文举例"><a href="#5-2-报文举例" class="headerlink" title="5.2 报文举例"></a>5.2 报文举例</h2><p>功能码0x03，读可读写模拟量寄存器：</p><ul><li>(主机)发送命令格式：</li><li>[设备地址] [功能码03] [起始寄存器地址高8位] [低8位] [读取的寄存器数高8位] [低8位] [CRC校验低8位] [CRC校验高8位]</li><li>例：[11][03][00][6B][00][03][CRC低][CRC高]</li><li>意义如下：<ul><li>11：设备地址，例子中的地址是11；</li><li>03：读模拟量的命令号固定为03，这是Modbus协议规定的。</li><li>00、6B：起始地址高8位（00）、低8位（6B）：表示想读取的模拟量的起始地址，比如例子中的起始地址为107。这个006B表示一个完整的地址，注意这里的地址是高8位在前，低8位在后。</li><li>00、03：寄存器数高8位（00）、低8位（03）：表示从起始地址开始读多少个模拟量（返回的每一个模拟量是用两个字节表示的）。例子中为3个模拟量。注意，在返回的信息中一个模拟量需要返回两个字节同时这里的地址也是高8位在前，低8位在后。</li><li>[CRC低][CRC高]：帧尾的CRC-16校验，尤其需要注意的一点是校验结果的低8位在前，高8位在后，这个顺序不同于起始地址以及读取深度的地址顺序。</li></ul></li></ul><hr><ul><li>(从机)设备响应：</li><li>[设备地址] [命令号03] [返回的字节个数][数据1][数据2]…[数据n][CRC校验的低8位] [CRC校验的高8位]</li><li>例：[11][03][06][02][2B][00][00][00][64][CRC低][CRC高]</li><li>意义如下：<ul><li>11：设备地址（从机地址）；</li><li>03：功能码；</li><li>06：返回的字节个数（不高扩两字节的校验码）：表示数据的字节个数，也就是数据1，2…n中的n的值。例子中返回了3个模拟量的数据，因为一个模拟量需要2个字节所以共6个字节。<br>数据1…n：其中[数据1][数据2]分别是第1个模拟量的高8位和低8位，[数据3][数据4]是第2个模拟量的高8位和低8位，以此类推。例子中返回的值分别是555，0，100。</li><li>[CRC低][CRC高]：CRC校验同上。</li></ul></li></ul><h1 id="六、基于W5500的Modbus-TCP"><a href="#六、基于W5500的Modbus-TCP" class="headerlink" title="六、基于W5500的Modbus TCP"></a>六、基于W5500的Modbus TCP</h1><p>&emsp;&emsp;如果是理解了上面源码的讲解，那么这里将会异常简单。由于W5500芯片，集成了硬件TCP/IP协议，数据接收完成与否的判断，也在W5500内完成；因此，FreeModbus库内的TCP函数大部分都不需要用到(例如，初始化函数)，只需要FreeModbus库的 TCP_Poll事件状态机(初始化要置位事件状态)。</p><p>&emsp;&emsp;先根据W5500的数据手册、或者例程，先编写好W5500的通讯驱动；程序中，读取W5500中断，如果有产生接收完成中断，就把TCP_Poll事件状态机置为接收完成，然后接下来就是TCP_Poll自己处理了，沿用同一套的数据单元处理功能函数。这样就完成了！</p><h1 id="七、FreeModbus库-拓展"><a href="#七、FreeModbus库-拓展" class="headerlink" title="七、FreeModbus库_拓展"></a>七、FreeModbus库_拓展</h1><p>&emsp;&emsp;Freemodbus库虽然写得很好，但是它的思路框架是以1个通讯接口实现的。如果是在 <code>Modbus主机</code> 一节提到的：有多串口Modbus通讯，共享一套地址处理数据。当你多串口RTU通讯，且波特率不相同，定时器的配置也就要变动一下。甚至还有，一个实际产品，它不仅有Modbus 多串口通讯，它还可能要有Modbus TCP通讯，而且也还是共享一套地址处理数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯。它具体的实现方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Modbus" scheme="http://shatang.github.io/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>Modbus协议_概念讲解</title>
    <link href="http://shatang.github.io/2020/05/30/Modbus%E5%8D%8F%E8%AE%AE-%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3/"/>
    <id>http://shatang.github.io/2020/05/30/Modbus协议-概念讲解/</id>
    <published>2020-05-30T02:50:13.000Z</published>
    <updated>2020-05-30T02:50:53.186Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯</p><a id="more"></a><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>&emsp;&emsp;Modbus协议 是一个请求/应答协议，发起请求的为Master（client），响应请求的为Slave（server）;Modbus协议包括ASCII、RTU、TCP三种报文类型，并没有规定物理层。</p><p>&emsp;&emsp;标准的Modbus协议物理层接口有RS232、RS422、RS485和以太网接口，采用master/slave方式通信。</p><hr><ul><li><strong>Master端发出读数据请求消息，Slave端接收到正确消息后，就发送对应数据到Master端以响应请求；</strong></li><li><strong>Master端发出写数据请求消息，Slave端接收到正确消息后，就修改Slave端的数据；</strong></li></ul><p>先发请求，再接收响应，从而实现 主机 对 从机 读/写操作。</p><h1 id="二、报文格式-通用部分"><a href="#二、报文格式-通用部分" class="headerlink" title="二、报文格式_通用部分"></a>二、报文格式_通用部分</h1><ul><li>(<strong>ADU</strong>)报文，指的是一串完整的指令数据；一个报文就是一帧数据，一个数据帧就一个报文</li><li>(<strong>MBAP</strong>)报文头，即报文的一部分，用于识别。当然也有些是部分数据在报文尾部，例如CRC数据校验。</li><li>(<strong>PDU</strong>)协议数据单元，这部分就是通信中的数据部分了。</li></ul><p>举例如下：</p><img src="/2020/05/30/Modbus协议-概念讲解/0.jpg" title="Modbus RTU报文模型"><p>&emsp;&emsp;由于报文类型的不同，报文之间也存在一些差异。先讲解通用的 功能码 &amp; 错误代码 部分。</p><h2 id="2-1-Modbus部分功能码"><a href="#2-1-Modbus部分功能码" class="headerlink" title="2.1 Modbus部分功能码"></a>2.1 Modbus部分功能码</h2><table><thead><tr><th>功能码（十六进制）</th><th>中文名称</th><th>位操作/字节操作</th><th>操作数量</th><th>错误功能码(&amp;0x80)</th></tr></thead><tbody><tr><td>01</td><td>读线圈状态</td><td>位操作</td><td>单个或多个</td><td>0x81</td></tr><tr><td>02</td><td>读离散状态</td><td>位操作</td><td>单个或多个</td><td>0x82</td></tr><tr><td>03</td><td>读保持寄存器</td><td>字节操作</td><td>单个或多个</td><td>0x83</td></tr><tr><td>04</td><td>读输入寄存器</td><td>字节操作</td><td>单个或多个</td><td>0x84</td></tr><tr><td>05</td><td>写单个线圈</td><td>位操作</td><td>单个</td><td>0x85</td></tr><tr><td>06</td><td>写单个保持寄存器</td><td>字节操作</td><td>单个</td><td>0x86</td></tr><tr><td>0F</td><td>写多个线圈</td><td>位操作</td><td>多个</td><td>0x8F</td></tr><tr><td>10</td><td>写多个保持寄存器</td><td>字节操作</td><td>多个</td><td>0x90</td></tr></tbody></table><p>&emsp;&emsp;Modbus协议规定，从机当执行对应功能码处理时发生错误，响应主机时需要将 <code>功能码 & 0x80</code> 将其返回。</p><h2 id="2-2-错误代码表"><a href="#2-2-错误代码表" class="headerlink" title="2.2 错误代码表"></a>2.2 错误代码表</h2><table><thead><tr><th>代码</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>01</td><td>非法功能</td><td>对于服务器（或从站）来说，询问中接收到的功能码是不可允许的操作，可能是因为功能码仅适用于新设备而被选单元中不可实现同时，还指出服务器（或从站）在错误状态中处理这种请求，例如：它是未配置的，且要求返回寄存器值。</td></tr><tr><td>02</td><td>非法数据地址</td><td>对于服务器（或从站）来说，询问中接收的数据地址是不可允许的地址，特别是参考号和传输长度的组合是无效的。对于带有100个寄存器的控制器来说，偏移量96和长度4的请求会成功，而偏移量96和长度5的请求将产生异常码02。</td></tr><tr><td>03</td><td>非法数据值</td><td>对于服务器（或从站）来说，询问中包括的值是不可允许的值。该值指示了组合请求剩余结构中的故障。例如：隐含长度是不正确的。modbus协议不知道任何特殊寄存器的任何特殊值的重要意义，寄存器中被提交存储的数据项有一个应用程序期望之外的值。</td></tr><tr><td>04</td><td>从站设备故障</td><td>当服务器（或从站）正在设法执行请求的操作时，产生不可重新获得的差错。</td></tr><tr><td>05</td><td>确认</td><td>与编程命令一起使用，服务器（或从站）已经接受请求，并且正在处理这个请求，但是需要长持续时间进行这些操作，返回这个响应防止在客户机（或主站）中发生超时错误，客户机（或主机）可以继续发送轮询程序完成报文来确认是否完成处理。</td></tr><tr><td>07</td><td>从属设备忙</td><td>与编程命令一起使用，服务器（或从站）正在处理长持续时间的程序命令，当服务器（或从站）空闲时，客户机（或主站）应该稍后重新传输报文。</td></tr><tr><td>08</td><td>存储奇偶性差错</td><td>与功能码20和21以及参考类型6一起使用，指示扩展文件区不能通过一致性校验。服务器（或从站）设备读取记录文件，但在存储器中发现一个奇偶校验错误。客户机（或主机）可重新发送请求，但可以在服务器（或从站）设备上要求服务。</td></tr><tr><td>0A</td><td>不可用网关路径</td><td>与网关一起使用，指示网关不能为处理请求分配输入端口值输出端口的内部通信路径，通常意味着网关是错误配置的或过载的。</td></tr><tr><td>0B</td><td>网关目标设备响应失败</td><td>与网关一起使用，指示没有从目标设备中获得响应，通常意味着设备未在网络中。</td></tr><tr><td>## 2.3 Modbus 寄存器地址分配</td><td></td><td></td></tr><tr><td>寄存器信息地址(PLC 地址)</td><td>适用功能码（十六进制）</td><td>寄存器种类</td></tr><tr><td>—-</td><td>—</td><td>—-</td></tr><tr><td>00001-09999</td><td>01 05 15</td><td>线圈状态</td></tr><tr><td>10001-19999</td><td>02</td><td>(开关)输入状态</td></tr><tr><td>30001-39999</td><td>04</td><td>输入寄存器</td></tr><tr><td>40001-49999</td><td>03 06 16</td><td>保持寄存器</td></tr><tr><td>## 2.4 小总结(心得)</td><td></td><td></td></tr><tr><td>&emsp;&emsp;一般情况下，只需要看一下返回的功能码就行了，错误代码可以不用看。Modbus通讯发生错误，往往出现的情况如下:</td><td></td><td></td></tr><tr><td>1. Modbus主机(PLC)读取有问题，例如读的地址写错，读的数据长度写错</td><td></td><td></td></tr><tr><td>2. Modbus从机压根就没写该 功能码 0r 地址 对应的处理，当主机对其操作自然报错。</td><td></td><td></td></tr><tr><td>3. 并不是符合Modbus协议规范的报文就一定通信正确，只能说是通讯成功，因为它返回给你一条报错指令。通讯无响应，说明是主机本身发的数据就有问题；通信有响应(可能返回错误报文)，说明该地址不可用，主机读歪了或者从机压根没写该功能处理。</td><td></td><td></td></tr></tbody></table><h1 id="三、各报文格式-详细解析"><a href="#三、各报文格式-详细解析" class="headerlink" title="三、各报文格式_详细解析"></a>三、各报文格式_详细解析</h1><p>&emsp;&emsp;每个报文都与其他报文格式有一定区分。<strong>在Modbus从机的角度看</strong>，讲解一下他们之间的类似之处。</p><ul><li>三者功能码是通用的</li><li>RTU 和 TCP的报文十分类似。TCP由于是可靠的协议，且通过IP连接，相比RTU就少了 设备ID &amp; CRC数据校验。<strong>数据单元部分</strong>是完全一样的。</li><li>RTU &amp; ASCII 都是通过串口通讯的，因此都是需要 定时器。但是定时器具体用法不相同。</li></ul><p><strong>Ps：</strong><br>ASCII模式，国内基本没用到。常用的是 RTU &amp; TCP 模式。</p><h2 id="3-1-RTU模式"><a href="#3-1-RTU模式" class="headerlink" title="3.1 RTU模式"></a>3.1 RTU模式</h2><p>&emsp;&emsp;Modbus RTU协议中没有明显的开始符和结束符，而是通过帧与帧之间的间隔时间来判断的。如果在指定的时间内，没有接收到新的字符数据，那么就认为新的帧接收完毕。接下来就是处理数据。Modbus通过时间来判断帧接收完成，自然需要 MCU 的定时器配合(3.5T)。<br>| 设备地址 | 功能代码 | 数据 | CRC校验 | 结束符(实际报文可没有这个！)<br>| — | —- | — | —- | —<br>| 1个字节 | 1个字节 | n个字节 | 2个字节 | T1-T2-T3-T4</p><ul><li><strong>地址码</strong>：每个从机都必须有唯一的地址码ID（从1到247，0是广播地址），并且只有符合地址码的从机才能响应回送。当从机回送信息时，相应的地址码表明该信息来自于何处。</li><li><strong>功能码</strong>：主机发送的功能码告诉从机执行什么任务。ModBus通讯规约定义功能号为1到127。表2-1列出部分常用功能码，以备查询。</li><li><strong>数据区</strong>：数据区包含需要从机执行什么动作或由从机采集的返送信息。应答包中，数据包括了数据字节长度+数据值，请求包中数据只包含数据值。</li><li><strong>校验码</strong>：主机或从机可用校验码进行判别接收信息是否出错。</li></ul><hr><ul><li>从Modbus主机角度上看<ul><li>使用RTU模式，<strong>消息发送至少要以3.5个字符时间的停顿间隔开始</strong>（如上图的T1-T2-T3-T4所示）。传输的第一个域是设备地址。可以使用的传输字符是十六进制的0…9,A…F。网络设备不断侦测网络总线，包括停顿间隔时间内。当第一个域（地址域）接收到，每个设备都进行解码以判断是否发往自己的。在最后一个传输字符之后，一个至少3.5个字符时间的停顿标定了消息的结束。一个新的消息可在此停顿后开始。</li><li>一旦连续发送间隔 小于3.5T，就会对从机数据接收造成 <strong>数据黏合</strong>。</li></ul></li><li>从Modbus从机角度上看<ul><li><strong>整个消息帧必须作为一连续的流传输，如果在帧完成之前有超过1.5个字符时间的停顿时间则为非法帧；</strong>如果一个新消息在小于3.5个字符时间内接着前个消息开始，接收的设备将认为它是前一消息的延续，这将导致一个错误，因为在最后的CRC域的值不可能是正确的。即<strong>帧之间的间隔必须大于3.5T，帧内字符的间隔必须小于1.5T</strong>。实际应用中1.5T一般不处理，只采用3.5T进行处理（FreeModBus开源代码就是这样)。</li><li>FreeModbus库，采用的是3.5T作为判断。只要是超过3.5T，就视为两个数据帧处理。当然，如果主机发送数据异常，让 某条报文中间字符发送相隔时间超过3.5T，那么就会造成 1条正确报文被分割成2条报文，造成 数据裂开。</li><li>数据裂开一般不会出现。采用FreeModbus库时，正常情况下，高波特率会对3.5T的值进行限制。如果解开该限制，导致3.5T实际值太小(高波特率转换计算出来)，这时候主机的字符发送间隔慢一点，从机将无法识别到正确的报文(数据被分裂)。</li></ul></li></ul><h2 id="3-2-ASCII模式"><a href="#3-2-ASCII模式" class="headerlink" title="3.2 ASCII模式"></a>3.2 ASCII模式</h2><p>&emsp;&emsp;除了数据域为ASCII码，其它域可以使用的传输字符是十六进制的0…9,A…F。网络上的设备不断侦测“:”字符，当有一个冒号接收到时，每个设备都解码下个域（地址域）来判断是否发给自己的。消息中字符间发送的时间间隔(MCU 的定时器)最长不能超过1秒，否则接收的设备将认为传输错误。</p><table><thead><tr><th>起始位</th><th>设备地址</th><th>功能代码</th><th>数据</th><th>LRC校验</th><th>结束符</th></tr></thead><tbody><tr><td>：</td><td>2个字符</td><td>2个字符</td><td>n个字符</td><td>2个字符</td><td>2个字符</td></tr></tbody></table><p>&emsp;&emsp;<strong>使用ASCII模式，消息以冒号（:）字符（ASCII码 3AH）开始，以回车换行符结束（ASCII码 0DH,0AH）</strong></p><h2 id="3-3-TCP-IP模式"><a href="#3-3-TCP-IP模式" class="headerlink" title="3.3 TCP/IP模式"></a>3.3 TCP/IP模式</h2><p>&emsp;&emsp;与MODBUS RTU相比，少了校验域和地址码，其中地址码被放到MBAP报文头里面了(即 00 00)，没有校验域是因为TCP本身就有校验所以省略了。</p><img src="/2020/05/30/Modbus协议-概念讲解/1.png" title="Modbus TCP报文"><p>报文头MBAP，长度为7字节，组成如下：</p><ul><li>事务处理标识    ：可以理解为报文的序列号，一般每次通信之后就要加1以区别不同的通信数据报文(主机要注意的点，从机不对该数据进行识别处理)。</li><li>协议标识符    ：00 00表示ModbusTCP协议。</li><li>长度    ：表示接下来的数据长度，单位为字节。</li><li>单元标识符    ：可以理解为设备地址。</li></ul><table><thead><tr><th>事务处理标识</th><th>协议标识</th><th>长度</th><th>单元标识符</th><th>功能代码</th><th>数据</th></tr></thead><tbody><tr><td>2字节</td><td>2字节</td><td>2字节</td><td>1字节</td><td>1字节</td><td>n字节</td></tr></tbody></table><h1 id="四、调试工具"><a href="#四、调试工具" class="headerlink" title="四、调试工具"></a>四、调试工具</h1><ul><li>如果你做的是Modbus Master，可以使用modbus slave工具模拟从设备来调试，该工具下载地址：<a href="http://www.cr173.com/soft/21410.html" target="_blank" rel="noopener">Modbus Slave</a></li><li>如果你做的是Modbus Slave，可以使用modbus poll工具模拟主设备来调试，该工具下载地址：<a href="http://www.cr173.com/soft/21405.html" target="_blank" rel="noopener">Modbus Poll</a></li></ul><p>以上两个工具的使用方法，可以参考此博客：<a href="https://blog.csdn.net/byxdaz/article/details/77979114" target="_blank" rel="noopener">Modbus测试工具ModbusPoll与Modbus Slave使用方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这里分享一下在嵌入式设备与PLC通讯中的一种很常见的通讯协议：Modbus通讯&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="Modbus" scheme="http://shatang.github.io/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>这段时间的总结</title>
    <link href="http://shatang.github.io/2020/05/30/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://shatang.github.io/2020/05/30/这段时间的总结/</id>
    <published>2020-05-30T02:34:34.000Z</published>
    <updated>2020-05-30T02:40:33.066Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;好久没更新博客了= =？</p><p>&emsp;&emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。</p><p>&emsp;&emsp;然后偶然，又和高中老同学聊了聊；这回会持续更新，而且要加很多新内容！！！</p><p>&emsp;&emsp;继续加油，奥力给！</p><img src="/2020/05/30/这段时间的总结/1.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;好久没更新博客了= =？&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前段时间梯子断了，博客自己看都卡；又有一个有道云笔记的markdown，感觉比博客预览快很多。所以这段时间的笔记大部分都记在有道云，很久就没更新博客了(主要也是自己懒)。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="生活" scheme="http://shatang.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>野指针</title>
    <link href="http://shatang.github.io/2020/03/15/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    <id>http://shatang.github.io/2020/03/15/野指针/</id>
    <published>2020-03-15T07:20:24.000Z</published>
    <updated>2020-03-15T08:11:21.146Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、野指针由来"><a href="#一、野指针由来" class="headerlink" title="一、野指针由来"></a>一、野指针由来</h1><h2 id="1-1-野指针概念-简述"><a href="#1-1-野指针概念-简述" class="headerlink" title="1.1 野指针概念(简述)"></a>1.1 野指针概念(简述)</h2><p>概述：<strong>“野指针”不是NULL指针，是指向“垃圾”内存的指针。</strong>(内存能不能用另外一回事)</p><ol><li>(局部)指针变量没有初始化</li><li>使用已经释放后的指针</li><li>指针所指向的变量在指针之前被销毁</li></ol><h2 id="1-2-野指针概念-专业描述"><a href="#1-2-野指针概念-专业描述" class="headerlink" title="1.2 野指针概念(专业描述)"></a>1.2 野指针概念(专业描述)</h2><ul><li><p><strong>指针未初始化</strong><br>&emsp;&emsp;指针变量在定义时不会自动初始化成空指针，而是随机的一个值，可能指向任意空间，这就使得该指针成为野指针。因此指针在初始化时要么指向一个合理的地址，要么初始化为<code>NULL</code>。<strong>即使不初始化，调用指针前，一定要赋值！</strong></p></li><li><p><strong>指针指向的变量被<code>free</code>或<code>delete</code>后没有置为<code>NULL</code></strong><br>&emsp;&emsp;在调用free或delete释放空间后，指针指向的内容被销毁，空间被释放，但是指针的值并未改变，仍然指向这块内存，这就使得该指针成为野指针。因此在调用<code>free</code>或<code>delete</code>之后，应将该指针置为<code>NULL</code>。</p></li><li><p><strong>指针操作超过所指向变量的生存期</strong><br>&emsp;&emsp;当指针指向的变量的声明周期已经结束时，如果指针仍然指向这块空间，就会使得该指针成为野指针。这种错误很难防范，只有养成良好的编程习惯，才能避免这类情况发生。</p></li></ul><h2 id="1-3-野指针的要点-简单描述"><a href="#1-3-野指针的要点-简单描述" class="headerlink" title="1.3 野指针的要点(简单描述)"></a>1.3 野指针的要点(简单描述)</h2><ol><li>野指针通常是因为指针变量中保存的值不是一个合法的内存地址而造成的</li><li>野指针不是NULL，是一个指向不可用内存的指针</li><li>C语言中没有方法可以判断是否为野指针(可替换成NULL指针，NULL指针不容易弄错，可以通过if来判断是否为NULL指针)</li></ol><h2 id="1-4-野指针的要点-深度描述"><a href="#1-4-野指针的要点-深度描述" class="headerlink" title="1.4 野指针的要点(深度描述)"></a>1.4 野指针的要点(深度描述)</h2><blockquote><p><strong>野指针只能避免而无法判断</strong></p></blockquote><p>&emsp;&emsp;无法判断一个指针是否为野指针，因为野指针本身有值，指向某个内存空间，只是这个值是随机的或错误的。</p><p><strong><font color="red">Ps：</font>空指针并非野指针</strong>，它具有特殊性和确定性，可以进行判断；因此要避免在程序中出现野指针，可以做完操作及时将指针指向<code>NULL</code>。</p><blockquote><p><strong>野指针并非立马让系统出事</strong></p></blockquote><p>&emsp;&emsp;指针也是数据，首先如果是局部的，不置空也没关系反正用不到了；如果是全局的，得用的时候释放了可能也会立马再次新赋值，如果不是那肯定需要重置为null，这也是方便你后面的判断是否需要赋值，<strong>如果你再次用不到，那么(不重置)就完全不影响程序的健壮性</strong>。但是，如果 <strong>再调该(野)指针就会可能出现问题！</strong> 有的可能比较复杂不一定开始就初始化，那你在某个地方用的时候会判断是否为空，然后给它赋值。就像很多做逻辑判断的bool，初始也会有值，如果没值，那你就看系统给的初始值，区别就是指针如果没初始化，然后对指针进行操作(调用)，可能会导致崩溃。也就是说，野指针并不是直接让系统出事，而是自己无意识产生野指针但还调用的操作才是让系统出事的真正原因！</p><blockquote><p><strong>野指针的错误是严重的</strong></p></blockquote><ol><li>指向不可访问的地址<br>&emsp;&emsp;危害：触发段错误。</li></ol><hr><ol start="2"><li>指向一个可用的，但是没有明确意义的空间<br>&emsp;&emsp;危害：程序可以正确运行，但通常这种情况下，我们就会认为我们的程序是正确的没有问题的，然而事实上就是有问题存在，所以这样就掩盖了我们程序上的错误。</li></ol><hr><ol start="3"><li>指向一个可用的，而且正在被使用的空间<br>&emsp;&emsp;危害：如果我们对这样一个指针进行解引用，对其所指向的空间内容进行了修改，但是实际上这块空间正在被使用，那么这个时候变量的内容突然被改变，当然就会对程序的运行产生影响，因为我们所使用的变量已经不是我们所想要使用的那个值了。通常这样的程序都会崩溃，或者数据被损坏。</li></ol><h1 id="二、未初始化指针的神奇操作"><a href="#二、未初始化指针的神奇操作" class="headerlink" title="二、未初始化指针的神奇操作"></a>二、未初始化指针的神奇操作</h1><p>&emsp;&emsp;指针未初始化，<strong>系统一般会自动分配内存给未初始化的指针，但也有时候指向<code>NULL</code>。</strong>由于太过玄学，建议直接初始化置<null>或一个有用的内存。</null></p><h2 id="2-1-非字符串指针未初始化"><a href="#2-1-非字符串指针未初始化" class="headerlink" title="2.1 非字符串指针未初始化"></a>2.1 非字符串指针未初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">20</span>,*p;    <span class="comment">//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    p=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    *p=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p：%d\n"</span>, a, p, *p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x7ffe4b25dc04</span>：<span class="number">20</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0xfaa010</span>：<span class="number">0</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0xfaa010</span>：<span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="2-2-字符串指针未初始化"><a href="#2-2-字符串指针未初始化" class="headerlink" title="2.2 字符串指针未初始化"></a>2.2 字符串指针未初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a=<span class="string">"ShaTang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p;    <span class="comment">//这里定义了一个字符串指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p\n"</span>, a, p);</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line">    p=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s-&gt;%p：%s\n"</span>, a, p, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShaTang-&gt;(nil)</span><br><span class="line">ShaTang-&gt;(nil)</span><br><span class="line">ShaTang-&gt;<span class="number">0x4006d4</span>：ShaTang</span><br><span class="line">ShaTang-&gt;<span class="number">0x134a010</span>：</span><br><span class="line">ShaTang-&gt;<span class="number">0x4006f1</span>：Zhu</span><br></pre></td></tr></table></figure><p><strong><font color="red">Ps：</font></strong>观察2.1和2.2，就会发现字符(数组)类型，引用数据和查看地址都是用指针。<br>&emsp;&emsp;编译器此时帮我们把 未初始化指针 指向 <code>NULL</code>。我们对野指针的定义：<strong>指针指向垃圾(未知)的内存</strong>；在这里，我们就不能称它为野指针。</p><h2 id="2-3-例1变形的玄学"><a href="#2-3-例1变形的玄学" class="headerlink" title="2.3 例1变形的玄学"></a>2.3 例1变形的玄学</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //分配内存时用到的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>  *d1,*p;<span class="comment">//这里定义了一个整型指针，但没赋初值，这时我们叫这个指针为野指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, d1);   <span class="comment">//观察%p是输出一个地址数据</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, a,d1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>-&gt;<span class="number">0x7ffde8b16b80</span></span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x4004f0</span></span><br><span class="line"><span class="number">20</span>-&gt;(nil)</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">0x4004f0</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt;<span class="number">0x7fff890b4780</span></span><br><span class="line">-&gt;(nil)</span><br><span class="line">-&gt;(nil)</span><br><span class="line">-&gt;(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器此时分配内存给 未初始化指针，还是玄学分配,有时候置<code>NULL</code>(虚_野指针)，有时候又分配一块内存(真_野指针)。因此需要注意 <strong>要指针的初始化，或者调用时一定要(检查)赋值</strong>，带来不可估量的Bug。<br>&emsp;&emsp;编译器1和编译器2对 例2.1 编译的结果都是一样的，但是对 例2.3 的编译结果却各不相同。但是反过来，只是简单变动，编译器就能玄学分配，这是很恐怖的事情。</p><h1 id="三、野指针概念案例"><a href="#三、野指针概念案例" class="headerlink" title="三、野指针概念案例"></a>三、野指针概念案例</h1><p>&emsp;&emsp;按照野指针的概念，举如下例子</p><h2 id="例1：指针变量没有初始化"><a href="#例1：指针变量没有初始化" class="headerlink" title="例1：指针变量没有初始化"></a>例1：指针变量没有初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                           <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"><span class="comment">//    strcpy(s1 , s2);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0x7fffea4889f0</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里不采用<code>strcpy</code>举例说明 指针变量没有初始化 的问题，后面单独一节再讲解原因。<br>&emsp;&emsp;这里很明显，在编译器2上，<code>printf</code>打印 未初始化的指针，出现段错误(实际指针 指向<code>NULL</code>)。而编译器1，则是通过了，并得知编译器1给 未初始化的指针 赋了一块随机内存。你的代码在不同的编译器上，有的报错，有的通过，这也是野指针带来的危害。</p><h2 id="例2：使用已经释放后的指针-释放后没改指向NULL"><a href="#例2：使用已经释放后的指针-释放后没改指向NULL" class="headerlink" title="例2：使用已经释放后的指针(释放后没改指向NULL)"></a>例2：使用已经释放后的指针(释放后没改指向NULL)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s);</span><br><span class="line">    <span class="built_in">strcpy</span>(s, <span class="string">"Delphi Tang"</span>);</span><br><span class="line">    func(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);      <span class="comment">//OOPS!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1f0e010</span></span><br><span class="line">Delphi Tang</span><br><span class="line"></span><br><span class="line"><span class="number">0x1f0e010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序是可以正常执行的。但是在执行结果第三行：打印野指针指向的内存为空白。首先我们先重新明确上面的概念：<strong>“野指针”不是NULL指针，是指向“垃圾”内存的指针。</strong>内存的申请释放和指针没有太大关系，内存释放后，<code>printf</code>能正常打印出指针指向的地址，但是地址所在的内存内容就有问题了(为下次调用埋雷)。</p><h2 id="例3：指针所指向的变量在指针之前被销毁"><a href="#例3：指针所指向的变量在指针之前被销毁" class="headerlink" title="例3：指针所指向的变量在指针之前被销毁"></a>例3：指针所指向的变量在指针之前被销毁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p[] = <span class="string">"Delphi Tang"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);  <span class="comment">//OOPS!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在我测试用的多个编译器，结果都不相同；局部变量在函数执行完，内存是已经释放的，还调用指向该内存的指针，即野指针调用；造成的结果在每个编译器都不太相同。</p><h1 id="四、strcpy引发的段错误"><a href="#四、strcpy引发的段错误" class="headerlink" title="四、strcpy引发的段错误"></a>四、<code>strcpy</code>引发的段错误</h1><p>&emsp;&emsp;很多人讲解 未初始化的指针 导致的 野指针的时候，很多实例代码都是用到<code>strcpy</code>来讲解 指针未初始化 的问题。这是很不严谨的，从上面的案例分析，稍微改下代码，系统就能分配一块内存 或者 置<code>NULL</code>。</p><h2 id="4-1-错误的例子1"><a href="#4-1-错误的例子1" class="headerlink" title="4.1 错误的例子1"></a>4.1 错误的例子1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                             <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Shatang"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shatang</span><br><span class="line"><span class="number">0x7ffc79832540</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>在编译器2环境下，注释<code>strcpy(s1 , s2);</code>和<code>printf("%s\n", s1);</code>，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就说，用<code>strcpy</code>来举例 未初始化指针 的问题是有问题的。当编译器给 未初始化指针 置<code>NULL</code>时，这时候已经不算是野指针了，反而会出现段错误；当随机分配内存，编译却通过了，说明这个问题跟野指针无关，这是由<code>strcpy</code>引发的段错误。</p><h2 id="4-2-strcpy语法"><a href="#4-2-strcpy语法" class="headerlink" title="4.2 strcpy语法"></a>4.2 <code>strcpy</code>语法</h2><p><code>strcpy</code>的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(char* dest, const char *src);</span><br></pre></td></tr></table></figure><p>被覆盖的 <code>dest</code>首先是个变量，变量就必须有内存存放；而一个指向<code>NULL</code>的指针没有指向任何内存。没有内存，怎么存储覆盖过来的值？</p><p>&emsp;&emsp;或者来个更直接的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1=<span class="literal">NULL</span>;                        <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Shatang"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    s1=(char *) malloc(sizeof(char));   //重新分配一块内存给指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所有的</strong>编译器程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> Segmentation fault</span><br></pre></td></tr></table></figure><h2 id="4-3-错误的例子2"><a href="#4-3-错误的例子2" class="headerlink" title="4.3 错误的例子2"></a>4.3 错误的例子2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1=<span class="string">"Shatang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2); <span class="comment">// OOPS!</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：这里我们将字符串指针初始化，指向一块明确内存(不是野指针了)；但程序执行还会报 理所应当的 <code>Segmentation fault</code>的错误。<code>strcpy</code>函数的<code>dest</code>是一个变量，不能指向字符串常量；字符串常量存放在内存位置的字符常量区(详情看内存知识)， 字符串指针指向这个区域，而且这个区域是一个const 属性的不可修改的；因此 再进行拷贝覆盖的时候会出现段错误。</p><h2 id="4-4-正确的例子1"><a href="#4-4-正确的例子1" class="headerlink" title="4.4 正确的例子1"></a>4.4 正确的例子1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">10</span>]=<span class="string">"Shatang"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zhu</span><br><span class="line"><span class="number">0x7ffff41e089e</span></span><br></pre></td></tr></table></figure><h2 id="4-5-正确的例子2"><a href="#4-5-正确的例子2" class="headerlink" title="4.5 正确的例子2"></a>4.5 正确的例子2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s1;                           <span class="comment">//不初始化，此时指向NULL</span></span><br><span class="line">    <span class="keyword">char</span> *s2=<span class="string">"Zhu"</span>;</span><br><span class="line">    </span><br><span class="line">    s1=(<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));   <span class="comment">//重新分配一块内存给指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(s1 , s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zhu</span><br><span class="line"><span class="number">0x144e010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此可见<code>strcpy</code>引发的段错误，并非是野指针引起的；而是编程人对<code>strcpy</code>的用法不了解导致的。</p><h2 id="4-6-得出来的结论"><a href="#4-6-得出来的结论" class="headerlink" title="4.6 得出来的结论"></a>4.6 得出来的结论</h2><p>&emsp;&emsp;只要调用该指针前，先把指针赋值指向对应的内存，就不会影响到系统的健壮性。如果严谨一点，还是把对指针进行 初始化赋值 或 置为<code>NULL</code>吧！ (抽风编译器牛逼!)</p><h1 id="五、经典野指针错误"><a href="#五、经典野指针错误" class="headerlink" title="五、经典野指针错误"></a>五、经典野指针错误</h1><p>&emsp;&emsp;<strong>野指针犯错方式是花式的、神奇的</strong>。随着编译器的不同，野指针造成的结果也不相同；甚至在同一个编译器下，你定义变量的数量不同，多一个或少一个，系统就可能让 未初始化的指针 置<code>NULL</code>或者是分配随机内存。<strong>野指针，强就强在，随机神秘翻车！不仅如此，还是编译通过的后续翻车(关键点)！！！</strong></p><p>&emsp;&emsp;因此，大家也不要对野指针编译的结果不同太诧异。具体的错误例子可以看 <a href="https://shatang.github.io/2020/03/15/32-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/#more">内存分配方式</a> 一节内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="内存" scheme="http://shatang.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="野指针" scheme="http://shatang.github.io/tags/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>内存分配方式</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://shatang.github.io/2020/03/15/内存分配方式/</id>
    <published>2020-03-15T06:32:56.000Z</published>
    <updated>2020-03-18T15:41:19.841Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、内存分配方式"><a href="#一、内存分配方式" class="headerlink" title="一、内存分配方式"></a>一、内存分配方式</h1><p>&emsp;&emsp;一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ol><li><strong>栈区（stack）</strong>：<em>由编译器自动分配释放</em> ；存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li><strong>堆区（heap）</strong> ： <em>一般由程序员分配释放</em>； 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</li><li><strong>全局区(静态区)(static)</strong>：<em>程序结束后有系统释放</em>；全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</li><li><strong>文字(字符)常量区</strong> ：<em>程序结束后由系统释放</em>；常量字符串就是放在这里的。 </li><li><strong>程序代码区</strong> ：存放函数体的二进制代码。</li></ol><h1 id="二、例子程序"><a href="#二、例子程序" class="headerlink" title="二、例子程序"></a>二、例子程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//全局初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1;   <span class="comment">//全局未初始化区</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> b;              <span class="comment">//栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abc"</span>;   <span class="comment">//栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p2;           <span class="comment">//栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;<span class="comment">//123456在常量区，p3在栈上</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>；   <span class="comment">//全局（静态）初始化区</span></span><br><span class="line"></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//申请分配得来的10和20字节的区域就在堆区   </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>);</span><br><span class="line">    <span class="comment">//123456放在常量区</span></span><br><span class="line">    <span class="comment">//编译器可能会将它与p3所指向的"123456"优化成一个地方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、堆和栈的理论知识"><a href="#三、堆和栈的理论知识" class="headerlink" title="三、堆和栈的理论知识"></a>三、堆和栈的理论知识</h1><h2 id="3-1-申请方式"><a href="#3-1-申请方式" class="headerlink" title="3.1 申请方式"></a>3.1 申请方式</h2><blockquote><p><strong>stack</strong>：由系统自动分配。 </p></blockquote><p>例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间</p><blockquote><p><strong>heap</strong>：需要程序员自己申请，并指明大小(在c中为，malloc函数)</p></blockquote><p>例如，<code>p1 = (char *)malloc(10);</code></p><p><strong><font color="red">Ps：</font></strong> 但是要注意<code>p1</code>本身是在栈中的。</p><h2 id="3-2-申请后系统的响应"><a href="#3-2-申请后系统的响应" class="headerlink" title="3.2 申请后系统的响应"></a>3.2 申请后系统的响应</h2><p><strong>栈</strong>：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><p><strong>堆</strong>：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p><h2 id="3-3-申请大小的限制"><a href="#3-3-申请大小的限制" class="headerlink" title="3.3 申请大小的限制"></a>3.3 申请大小的限制</h2><p><strong>栈</strong>：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><p><strong>堆</strong>：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><h2 id="3-4-申请效率的比较"><a href="#3-4-申请效率的比较" class="headerlink" title="3.4 申请效率的比较"></a>3.4 申请效率的比较</h2><p><strong>栈</strong>：由系统自动分配，速度较快。但程序员是无法控制的。</p><p><strong>堆</strong>：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p><p>&emsp;&emsp;另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p><h2 id="3-5-堆和栈的存储内容"><a href="#3-5-堆和栈的存储内容" class="headerlink" title="3.5 堆和栈的存储内容"></a>3.5 堆和栈的存储内容</h2><p><strong>栈</strong>： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p><p>&emsp;&emsp;当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><p><strong>堆</strong>：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p><h2 id="3-6-存取效率的比较"><a href="#3-6-存取效率的比较" class="headerlink" title="3.6 存取效率的比较"></a>3.6 存取效率的比较</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] = <span class="string">"aaaaaaaaaaaaaaa"</span>;</span><br><span class="line"><span class="keyword">char</span> *s2 = <span class="string">"bbbbbbbbbbbbbbbbb"</span>;</span><br></pre></td></tr></table></figure><p>aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"1234567890"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p =<span class="string">"1234567890"</span>;</span><br><span class="line">    </span><br><span class="line">    a = c[<span class="number">1</span>];</span><br><span class="line">    a = p[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10: a = c[1];</span><br><span class="line"></span><br><span class="line">00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]</span><br><span class="line"></span><br><span class="line">0040106A 88 4D FC mov byte ptr [ebp-4],cl</span><br><span class="line"></span><br><span class="line">11: a = p[1];</span><br><span class="line"></span><br><span class="line">0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]</span><br><span class="line"></span><br><span class="line">00401070 8A 42 01 mov al,byte ptr [edx+1]</span><br><span class="line"></span><br><span class="line">00401073 88 45 FC mov byte ptr [ebp-4],al</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。</p><h2 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h2><p>堆和栈的区别可以用如下的比喻来看出：<br>&emsp;&emsp;使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>&emsp;&emsp;使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><ol><li>内存分配方面：</li></ol><p><strong>堆</strong>：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。<br><strong>栈</strong>：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><ol start="2"><li>申请方式方面：</li></ol><p><strong>堆</strong>：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。<br><strong>栈</strong>：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。</p><ol start="3"><li>系统响应方面：</li></ol><p><strong>堆</strong>：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。<br><strong>栈</strong>：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><ol start="4"><li>大小限制方面：</li></ol><p><strong>堆</strong>：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br><strong>栈</strong>：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><ol start="5"><li>效率方面：</li></ol><p><strong>堆</strong>：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。<br><strong>栈</strong>：由系统自动分配，速度较快。但程序员是无法控制的。</p><ol start="6"><li>存放内容方面：</li></ol><p><strong>堆</strong>：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。<br><strong>栈</strong>：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><ol start="7"><li>存取效率方面：</li></ol><p><strong>堆</strong>：是在编译时就确定的；<br><strong>栈</strong>：是在运行时赋值的；</p><hr><p><code>char *s1 = "Hello Word";</code><br><code>char s1[] = "Hello Word";</code><br>&emsp;&emsp;用数组比用指针速度要快一些，因为指针在底层汇编中需要用<code>edx</code>寄存器中转一下，而数组在栈上直接读取。</p><hr><h1 id="四、C-的内存分配方式"><a href="#四、C-的内存分配方式" class="headerlink" title="四、C++的内存分配方式"></a>四、C++的内存分配方式</h1><p>&emsp;&emsp;在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 </p><p><strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。<br><strong>堆</strong>，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br><strong>自由存储区</strong>，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。<br><strong>全局/静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。<br><strong>常量存储区</strong>，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）</p><h1 id="五、内存分配方式引发的概念区别-C"><a href="#五、内存分配方式引发的概念区别-C" class="headerlink" title="五、内存分配方式引发的概念区别(C)"></a>五、内存分配方式引发的概念区别(C)</h1><h2 id="5-1-只读变量和常量"><a href="#5-1-只读变量和常量" class="headerlink" title="5.1 只读变量和常量"></a>5.1 只读变量和常量</h2><p>下面的例子用一个const变量来初始化数组，ANSI C的编译器会报告一个错误呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br></pre></td></tr></table></figure><p>答案与分析:<br>1）这个问题讨论的是“常量”与“只读变量”的区别。常量肯定是只读的，例如 5， “abc”，等，肯定是只读的，因为程序中根本没有地方存放它的值(存放在字符常量区，不可修改，只读)，当然也就不能够去修改它。而“只读变量”则是在内存中开辟一个地方来存放它的值，只不过这个值由编译器限定不允许被修改。C语言关键字const就是用来限定一个变量不允许被改变的修饰符（Qualifier）。上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是常量。而ANSI C规定数组定义时维度必须是“常量”，“只读变量”也是不可以的。<br>2）注意：在ANSI C中，这种写法是错误的，因为数组的大小应该是个常量，而const int n,n只是一个变量（常量 != 不可变的变量，但在标准C++中，这样定义的是一个常量，这种写法是对的），实际上，根据编译过程及内存分配来看，这种用法本来就应该是合理的，只是 ANSI C对数组的规定限制了它。<br>3）那么，在 ANSI C 语言中用什么来定义常量呢？答案是enum类型和#define宏，这两个都可以用来定义常量。</p><h2 id="5-2-指针-和-字符串常量"><a href="#5-2-指针-和-字符串常量" class="headerlink" title="5.2 指针 和 字符串常量"></a>5.2 指针 和 字符串常量</h2><p>请问下面的代码有什么问题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"i'm hungry!"</span>;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>]= <span class="string">'I'</span>;</span><br></pre></td></tr></table></figure><p>答案与分析：<br>&emsp;&emsp;上面的代码会造成内存的非法写操作。分析如下， “i’m hungry”实质上是字符串常量，而字符串常量被编译器放在只读的字符常量区内，不可写。指针p初始化，指向这个只读的内存区，是不能修改其中元素值(即存放值)；而<code>p[0] = 'I';</code>则企图修改内存存放值，编译器当然不会答应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="string">"i'm hungry!"</span>;</span><br><span class="line">p = <span class="string">"I'm hungry!"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽说字符串常量(字符常量区)内容不可修改，但指针是变量，可以修改指针p指向的内存位置；即实际上又找了一个新的字符串常量(新申请在字符常量区)。</p><h2 id="5-3-字符串数组-和-字符串常量"><a href="#5-3-字符串数组-和-字符串常量" class="headerlink" title="5.3 字符串数组 和 字符串常量"></a>5.3 字符串数组 和 字符串常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">15</span>] = <span class="string">"i'm hungry!"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>]= <span class="string">'I'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br></pre></td></tr></table></figure><p>答案与分析：</p><p>&emsp;&emsp;相比较与5.2，由于字符串数组是存放在 栈 或 堆 ，该区是可以修改的，因此对字符串(数组,这里不是常量)的元素可以修改。</p><h2 id="5-4-指针-amp-内存"><a href="#5-4-指针-amp-内存" class="headerlink" title="5.4 指针 &amp; 内存"></a>5.4 指针 &amp; 内存</h2><p>&emsp;&emsp;往往别人在教指针知识的时候，往往强调指针存放着地址，并举出类似下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="number">0x12ff7c</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>,p);</span><br></pre></td></tr></table></figure><p>程序结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12f</span>f7c</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;的确是能够打印出来，<code>0x12ff7c</code>是在前面随便打印一个<code>int</code>类型变量的地址获取的。但是如果给这个内存进行赋值操作的话，就会出现 <strong>段错误</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="number">0x12ff7c</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>,p);</span><br><span class="line"></span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;地址和内存是两回事！！！每段内存都有自己的地址，地址映射可以通过指针操作；但是，你无权更改内存存放的值，除非这段内存是 栈 或 堆 分配给你的。需要注意：<strong>有地址，没空间</strong>(字符常量区也是这样)。</p><p><strong><font color="red">Ps：</font></strong> 如果有地址就能合法操作对应内存空间，那还要什么(手动)内存分配。</p><h1 id="六、内存知识的重新总结"><a href="#六、内存知识的重新总结" class="headerlink" title="六、内存知识的重新总结"></a>六、内存知识的重新总结</h1><p>一个程序分为：</p><ul><li>栈区（stack） –编译器自动分配释放，主要存放函数的参数值，局部变量值等；</li><li>堆区（heap）  –由程序员分配释放；</li><li>全局(静态)区 –存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区(.data)和全局未初始化区(.bss)；</li><li>字符常量区(.rodata)   –常量字符串放与此，程序结束时由系统释放；</li><li>程序代码区(.text)</li></ul><p><strong>栈</strong> ：(<strong>后进先出</strong>)栈在程序中用于维护函数的调用上下文；栈保存了一个函数调用所需要的维护信息。</p><pre><code>1)函数参数，函数返回地址2)局部变量3)函数调用上下文</code></pre><p><strong>堆</strong>：(<strong>堆内存需要主动申请</strong>)为什么有了栈还需要堆？</p><pre><code>1)栈上的数据在函数返回后就会被释放掉，无法传递到函数外部，如局部变量(关键原因)2)堆是程序中一块巨大的内存空间，可由程序自由支配3)堆中被程序申请使用的内存在程序主动释放前将一直有效</code></pre><p><strong>(全局)静态存储区</strong>：</p><pre><code>1)程序的静态存储区随着程序的运行而分配空间，直到程序运行结束2)在程序编译期间静态存储区的大小就已经确定3)程序的静态存储区主要用于保存程序中的全局变量和静态变量4)与栈和堆不同，静态存储区的信息最终会保存在可执行程序中</code></pre><h1 id="七、-非法内存操作分析"><a href="#七、-非法内存操作分析" class="headerlink" title="七、 非法内存操作分析"></a>七、 非法内存操作分析</h1><h2 id="7-1-指针没有初始化进行内存操作"><a href="#7-1-指针没有初始化进行内存操作" class="headerlink" title="7.1 指针没有初始化进行内存操作"></a>7.1 指针没有初始化进行内存操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* d1;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//问题1：不能直接赋值，因为并没有分配内存，也没有初始化。</span></span><br><span class="line">    &#123;</span><br><span class="line">        d1[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, *(d1+<span class="number">6</span>), d1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>-&gt;<span class="number">0x7ffeaaf62970</span></span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> Segmentation fault</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里理所应当地出现两种情况：</p><ol><li>出现段错误，则是编译器自动将指针置<code>NULL</code></li><li>编译通过的，则是 野指针</li></ol><h2 id="7-2-没有给指针分配足够的内存"><a href="#7-2-没有给指针分配足够的内存" class="headerlink" title="7.2 没有给指针分配足够的内存"></a>7.2 没有给指针分配足够的内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *d2;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    d2=(<span class="keyword">int</span> *)<span class="built_in">calloc</span>(<span class="number">5</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//问题2：只分配了5个空间，却用了10个。</span></span><br><span class="line">    &#123;</span><br><span class="line">        d2[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, *(d2+<span class="number">6</span>), d2);</span><br><span class="line">    <span class="built_in">free</span>(d2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-&gt;%p\n"</span>, *(d2+<span class="number">6</span>), d2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器1，程序执行的结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>-&gt;<span class="number">0x1b3d010</span></span><br><span class="line">*** Error in `./a.out': free(): invalid next size (fast): 0x0000000001b3d010 ***</span><br></pre></td></tr></table></figure><p>编译器2，程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>-&gt;<span class="number">0x1602010</span></span><br><span class="line"><span class="number">4113</span>-&gt;<span class="number">0x1602010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里会出现<code>free()</code>操作 非法(没有分配)的内存；还有个编译器神奇通过(野指针的恐怖之处)。</p><h2 id="7-3-内存分配成功但是没有初始化"><a href="#7-3-内存分配成功但是没有初始化" class="headerlink" title="7.3 内存分配成功但是没有初始化"></a>7.3 内存分配成功但是没有初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">'A'</span>;</span><br><span class="line">    <span class="comment">//s[1]='\0';</span></span><br><span class="line"> s[<span class="number">2</span>]=<span class="string">'B'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,s);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器程序执行的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="number">0x14e5010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，上面虽然编译通过但是是有问题的。犯这个错误往往是由于没有初始化的概念或者是以为内存分配好之后其缺省初值自然为0。未初始化指针变量也许看起来不那么严重，但是它确确实实是个非常严重的问题，而且往往出现这种错误很难找到原因。(<strong>尤其在字库驱动</strong>)</p><p>&emsp;&emsp;内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，但这点在不同的编译器上会有不同的实现。所以好的做法，是手动给数组赋上初值。</p><p>&emsp;&emsp;当你只分配内存给字符(串)型指针，并没有缺省初值，严格意义上来讲是不算初始化；有些编译器自然里面都是<code>'\0'</code>，<code>printf</code>打印时，打印出来的数据自然会被其中字符的<code>'\0'</code>截胡。不然可以把上述例子的注释去掉再测试一遍。</p><p>也许这种严重的问题并不多见，但是也绝不能掉以轻心。所以在定义一个变量时，第一件事就是初始化。你可以把它初始化为一个有效的值。</p><h2 id="7-4-内存-数组-越界"><a href="#7-4-内存-数组-越界" class="headerlink" title="7.4 内存(数组)越界"></a>7.4 内存(数组)越界</h2><p>数组有两个特性，影响作用在数组上的函数：</p><ol><li>不能复制数组；</li><li>使用数组名时， 数组名会自动指向其第一个元素的指针。</li><li>因为不能复制，所以无法编写使用数组类型的形参，数组会自动转化为指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span><span class="comment">//这里面的[10]仅表示我们希望数组是多大；实际没有用处，传入是指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    f(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>编译器程序执行的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong><font color="red">数组作为形参时的一个陷阱：</font></strong>在数组当形参的函数中，使用sizeof来计算传入的实参数组的大小。但是当数组作为形参的时候，其退化为一个指针，如果sizeof其数组名将计算的是一个指针的大小！</p><h2 id="7-5-内存泄漏"><a href="#7-5-内存泄漏" class="headerlink" title="7.5 内存泄漏"></a>7.5 内存泄漏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( size % <span class="number">2</span> != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//奇数个size的情况直接跳转，但申请的内存没有free掉；内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="number">9</span>);</span><br><span class="line">    f(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：当函数申请了内存：采用单入口，单出口程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( size % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-多次释放指针"><a href="#7-6-多次释放指针" class="headerlink" title="7.6 多次释放指针"></a>7.6 多次释放指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);    <span class="comment">//第1次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    f(p, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);    <span class="comment">//第2次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多次释放内存的后果，就是强退出</strong></p><p><strong><font color="red"> Ps：</font></strong>分配多次完全可以，既然是变量那就是可变的！但是多次释放就是自杀！</p><h2 id="7-7-使用已经释放的内存"><a href="#7-7-使用已经释放的内存" class="headerlink" title="7.7 使用已经释放的内存"></a>7.7 使用已经释放的内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个和前面的例子有点类似</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    f(p, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i; <span class="comment">// OOPS!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、C语言有关内存的规则"><a href="#八、C语言有关内存的规则" class="headerlink" title="八、C语言有关内存的规则"></a>八、C语言有关内存的规则</h1><h2 id="8-1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针"><a href="#8-1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针" class="headerlink" title="8.1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针"></a>8.1用malloc申请了内存之后，应该立即检查指针值是否为NULL，防止使用值为NULL的指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><h2 id="8-2-牢记数组长度，防止数组越界操作，考虑使用柔性数组"><a href="#8-2-牢记数组长度，防止数组越界操作，考虑使用柔性数组" class="headerlink" title="8.2 牢记数组长度，防止数组越界操作，考虑使用柔性数组"></a>8.2 牢记数组长度，防止数组越界操作，考虑使用柔性数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">soft_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;SoftArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">SoftArray* sa=(SoftArray*)mallo(<span class="keyword">sizeof</span>(SoftArray)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">sa-&gt;len=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sa-&gt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sa-&gt;<span class="built_in">array</span>[i]= i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放"><a href="#8-3-动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放" class="headerlink" title="8.3 动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放"></a>8.3 动态申请操作必须和释放操作匹配，防止内存泄漏和多次释放</h2><p><strong><font color="red"> Ps：</font></strong>可以用if…else…来确定是否释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p= (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p= (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-free指针之后必须赋值为NULL"><a href="#8-4-free指针之后必须赋值为NULL" class="headerlink" title="8.4 free指针之后必须赋值为NULL"></a>8.4 free指针之后必须赋值为NULL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span>*)(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//···</span></span><br><span class="line"><span class="comment">//······</span></span><br><span class="line"><span class="comment">//·········</span></span><br><span class="line"><span class="comment">//············</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">          p[i]=i;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、嵌入式的内存分配"><a href="#九、嵌入式的内存分配" class="headerlink" title="九、嵌入式的内存分配"></a>九、嵌入式的内存分配</h1><p>&emsp;&emsp;通常应用程序可以调用ANSI C编译器的malloc()和free()函数来动态的分配和释放内存，但多次这样的操作会把原来很大的一块连续存储区域逐渐地分割成许多非常小并且彼此不相邻的存储区域，这就是存储碎片。</p><p>&emsp;&emsp;malloc( )属于标准C语言函数，当然可以在单片机上使用，如STM32可以先在启动文件中设置heap的大小，再使用动态内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Heap_Size     EQU    <span class="number">0x00000200</span>     <span class="comment">//也就是 512字节</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是在嵌入式(裸机)中最好不要这么做，一般单片机的内存都比较小，而且没有MMU(内存管理管理单元),多次的<code>malloc</code> 与<code>free</code>的使用容易造成内存碎片。当后面因为空间不足而分配失败，从而导致系统崩溃，因此应该慎用，或者自己实现内存管理。除了UCOS或FREERTOS等嵌入式操作系统有自带的MMU处理外，裸机长时间连续工作产生的内存碎片为系统工作稳定埋下隐患。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="内存" scheme="http://shatang.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="堆栈" scheme="http://shatang.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
      <category term="野指针" scheme="http://shatang.github.io/tags/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>大小端和联合体</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/"/>
    <id>http://shatang.github.io/2020/03/15/大小端和联合体/</id>
    <published>2020-03-15T06:28:41.000Z</published>
    <updated>2020-03-15T06:31:06.957Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、大小端"><a href="#一、大小端" class="headerlink" title="一、大小端"></a>一、大小端</h1><h2 id="1-1-大小端含义"><a href="#1-1-大小端含义" class="headerlink" title="1.1 大小端含义"></a>1.1 大小端含义</h2><p>&emsp;&emsp;大端小端的含义可以看这位博主的：<a href="https://www.cnblogs.com/wuyuegb2312/archive/2013/06/08/3126510.html" target="_blank" rel="noopener">轻松记住大端小端的含义(附对大端和小端的解释)</a></p><h2 id="1-2-大端小端哪里用到？"><a href="#1-2-大端小端哪里用到？" class="headerlink" title="1.2 大端小端哪里用到？"></a>1.2 大端小端哪里用到？</h2><p>&emsp;&emsp;当涉及到数据拆解(例如一个32位数据拆分成两个16位数据来用) 的时候，就需要注意大小端。因为我们一般存数据和取数据都是一个一个或着一组一组，不会涉及到拆分数据，这样就不涉及大小端。</p><p>&emsp;&emsp;举个例子，当你有一个int类型的数据，你不是把数据直接取出来，而是把int变量中的一个字节数据提取出来，想做一些类似位操作的操作。当一个数据拆解取出来的时候，就会设计到数据的存储顺序，即大小端。</p><p>&emsp;&emsp;但是，由于<strong>一般现在所用的cpu基本上是采用的小端模式</strong>。基本上，平常撸代码都不会被涉及(影响到)到，因此简单了解一下其概念就行。以下的情况才有可能是被大小端模式影响到：</p><ol><li>在(不熟悉的)平台撸代码，用到union之类的语法。发现读写数据出现异常</li><li>正常稳定的代码，迁移新的平台。发现读写数据出现异常</li></ol><h1 id="二、联合体"><a href="#二、联合体" class="headerlink" title="二、联合体"></a>二、联合体</h1><p><strong>联合体</strong>：使几个不同类型的变量共占一段内存(相互覆盖)。所占内存长度是各最长的成员占的内存长度。<br><strong>结构体</strong>：把不同类型的数据组合成一个整体。所占内存长度是各成员占的内存长度的总和。</p><p>&emsp;&emsp;由于嵌入式C基本都是用小端模式：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。小端就是我们(平常逻辑)认知的顺序，因此后面(默认小端)不再提及大小端对联合体的影响。</p><hr><blockquote><p>寄存器(联合体和结构体的妙用)</p></blockquote><p>先声明一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体中的冒号表示位域</span></span><br><span class="line"><span class="comment">//位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节//同时也是为了节省存储空间和方便处理。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> Mode1:<span class="number">1</span>;   <span class="comment">//Mode1配置占1位 </span></span><br><span class="line">    <span class="keyword">uint16_t</span> Mode2:<span class="number">3</span>;   <span class="comment">//Mode2配置占3位</span></span><br><span class="line">    <span class="keyword">uint16_t</span> Mode3:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> Mode4:<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//写满16位</span></span><br><span class="line">&#125;Ctl_Bits;</span><br></pre></td></tr></table></figure><p>再声明一个联合体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> TBCTL_REG</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> all;</span><br><span class="line">    Ctl_Bits bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再申明一个寄存器结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">union</span> TBCTL_REG TBCTL1;</span><br><span class="line">    <span class="keyword">union</span> TBCTL_REG TBCTL2;</span><br><span class="line">&#125;PWM_REGS;</span><br></pre></td></tr></table></figure><p>这样的话，我就写了一个关于PWM配置的寄存器，例如我现在想改PWM的Mode1为模式1；如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PWM_REGS PWM1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整体赋值</span></span><br><span class="line">PWM1.TBCTL1.all |= <span class="number">0x01</span>;</span><br><span class="line"><span class="comment">//位赋值</span></span><br><span class="line">PWM1.TBCTL1.bit.Mode1 = <span class="number">0x01</span>；</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;理解了这个方法后，再来看样例对寄存器的操作是不是就很轻松了？掌握这个方法以后，你也可以设计一个带全局或者位操作的结构体来完成自己的程序数据的应用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="大小端" scheme="http://shatang.github.io/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="联合体" scheme="http://shatang.github.io/tags/%E8%81%94%E5%90%88%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>结构体</title>
    <link href="http://shatang.github.io/2020/03/15/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://shatang.github.io/2020/03/15/结构体/</id>
    <published>2020-03-15T03:47:30.000Z</published>
    <updated>2020-03-15T04:11:32.904Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、关于c语言的结构体"><a href="#一、关于c语言的结构体" class="headerlink" title="一、关于c语言的结构体"></a>一、关于c语言的结构体</h1><p>&emsp;&emsp;首先我们为什么要用到结构体，我们都已经学了很多<code>int</code>、 <code>char</code>…等类型，还学到了同类型元素构成的数组；以及取上述类型的指针，在一些小应用可以灵活使用。然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是结构体的好处。</p><h1 id="二、结构体小知识"><a href="#二、结构体小知识" class="headerlink" title="二、结构体小知识"></a>二、结构体小知识</h1><ol><li>只有结构体变量才分配地址，而结构体的声明是不分配空间的；</li><li>结构体声明，包括了结构体中各成员的声明，因此也不分配空间；</li><li>c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换</li><li>相同类型的成员是可以声明在同一类型下的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">int</span> number,age；<span class="comment">//int型学号和年龄</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>],sex;<span class="comment">//char类型姓名和性别</span></span><br><span class="line"><span class="keyword">float</span> score;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//最后的分号不要忘了</span></span><br></pre></td></tr></table></figure></li></ol><p><strong><font color="red">总结：</font></strong>声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 int 分配内存一样。只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。</p><blockquote><p>结构体类型的变量的本质：<strong>结构体类型的变量，本质上是一个变形的数组</strong>。</p></blockquote><ul><li>不同点：结构体不要求元素类型一样，要用的时候，不是以数组下标，而是特定指向(<code>.</code>或<code>-></code>)该成员来 处理（例如赋值）；</li><li>相同点：<ul><li>结构体和数组在定义的时候不进行初始化赋初值，则后面就不能全部赋初值，需<strong>逐个</strong>赋值；</li><li>进行 数组、结构体变量 初始化的时候，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋初值前面几个；</li><li>进行 数组、结构体变量 初始化的时候，对于未初始化(后半段)的数据：如果是数值型，则会自动赋值为 <code>0</code> ；如果是字符型，会自动赋初值为 <code>NULL</code> ，即<code>\0</code> ；即不足的元素补以默认值；</li><li>函数的传入参数(形参)是结构体、数组，均采用指针传递的方式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;Student；</span><br><span class="line">Student stu1=&#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> str[<span class="number">10</span>]=&#123;<span class="number">1</span>&#125;;<span class="comment">//这里只是把str的第一个元素赋值为1，其他元素默认为0</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>&emsp;&emsp;这里要强调的一点是， “变量赋值” 和 “变量初始化(赋初值)”不是一回事！给(全局)变量初始化，定义时后跟等号，等号后面是初始化值。<strong>赋初值只会在定义的时候进行赋初始化值，其余地方都是赋值</strong>。</p><blockquote><p>赋初值 和 赋值 的区别</p></blockquote><ol><li><strong>赋值运算，函数体外是不允许的</strong>；而赋初值没有该要求，可在函数体外定义赋初值。</li><li>赋初值，可以初始化所有成员；赋值，只能对<strong>逐个</strong>成员进行赋值，无法一次性对全体成员进行赋值。(举例：数组、结构体)</li></ol><h1 id="三、结构体变量的定义和引用"><a href="#三、结构体变量的定义和引用" class="headerlink" title="三、结构体变量的定义和引用"></a>三、结构体变量的定义和引用</h1><h2 id="3-1-结构体类型的变量"><a href="#3-1-结构体类型的变量" class="headerlink" title="3.1 结构体类型的变量"></a>3.1 结构体类型的变量</h2><p>&emsp;&emsp;在编译时，<strong>结构体的声明并不分配存储空间</strong>；声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 <code>int</code> 分配内存一样；<strong>只有当使用这个类型定义了变量时，系统才会为变量分配内存</strong>。所以在声明结构体类型的时候，不可以对里面的变量进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line"> <span class="keyword">char</span> title[<span class="number">20</span>];<span class="comment">//一个字符串表示的titile 题目</span></span><br><span class="line"><span class="keyword">char</span> author[<span class="number">20</span>];<span class="comment">//一个字符串表示的author作者</span></span><br><span class="line"> <span class="keyword">float</span> value;<span class="comment">//价格表示 </span></span><br><span class="line"> &#125;;<span class="comment">//这里只是声明 结构体类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book1</span>,<span class="title">book2</span>;</span><span class="comment">//结构体变量的定义 分配空间</span></span><br><span class="line">book1.value;<span class="comment">//引用结构体变量</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;定义结构体变量以后，系统就会为其分配内存单元，比如book1和book2在内存中占44个字节（20+20+4）具体的长度你可以在你的编译器中使用sizeof关键字分别求出来。</p><h2 id="3-2-结构体空洞"><a href="#3-2-结构体空洞" class="headerlink" title="3.2 结构体空洞"></a>3.2 结构体空洞</h2><p>&emsp;&emsp;用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍；比方说我们上面求得的为44 为 float(4个字节)的整数倍，但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48(4的整数倍)。</p><p>这就涉及到结构体的存储：</p><ol><li>结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍；</li><li>结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍(一般是int,4字节)，如果不是编译器会自动补齐；</li></ol><p>&emsp;&emsp;在结构体分配空间时，如果结构体中出现4个字节(32位)及以上的变量时，给每个变量分配空间时都是按字对齐分配的(就是按4个字节，4个字节来分配)；如果结构体中没有出现4个字节以上变量，则按半字对齐(按 2个字节，2个字节。。来分配)。<br>&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储(字对齐或双字对齐等)。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。<br>&emsp;&emsp;看来鱼与熊掌还是不能兼得啊。既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。<br>&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单地(手动计算)相加。因为他们中间存在空洞。</p><p>关于偏移量，简单介绍下：</p><blockquote><p>结构体偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小；<strong>第一个成员的偏移量为0</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>char a</code> 偏移量为 1 之后为 <code>int b</code> 因为偏移量 1 不为int(4)的整数倍，所以会自动补齐，而在 <code>double c</code> 时，偏移量为 8 是int(4)的整数倍，所以不用自动补齐，最后求得结构体得大小为 16。</p><h1 id="四、结构体变量的初始化"><a href="#四、结构体变量的初始化" class="headerlink" title="四、结构体变量的初始化"></a>四、结构体变量的初始化</h1><p>&emsp;&emsp;结构体的初始化有很多需要注意的地方，这里我们说明下，首先是几种初始化的方法。</p><p><strong><font color="red">Ps：</font></strong> 在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋值前面几个，对于后面未赋值的变量，如果是数值型，则会自动赋值为0；对于字符型，会自动赋初值为 <code>NULL</code> ，即 <code>\0</code> 。</p><h2 id="4-1-定义时直接赋值-变量初始化"><a href="#4-1-定义时直接赋值-变量初始化" class="headerlink" title="4.1 定义时直接赋值(变量初始化)"></a>4.1 定义时直接赋值(变量初始化)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;stu1=&#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>=&#123;</span><span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red">注意：</font></strong> 字符为 <code>' '</code> ，字符串为 <code>" "</code></p><h2 id="4-2-定义结构体之后逐个赋值"><a href="#4-2-定义结构体之后逐个赋值" class="headerlink" title="4.2 定义结构体之后逐个赋值"></a>4.2 定义结构体之后逐个赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值操作均在函数内操作</span></span><br><span class="line"></span><br><span class="line">stu1.name=<span class="string">"王伟"</span>；</span><br><span class="line">stu1.sex=<span class="string">'M'</span>;</span><br><span class="line">stu1.number=<span class="number">12305</span>;</span><br><span class="line"><span class="comment">//也可用strcpy函数进行赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu1.name,<span class="string">"王伟"</span>);</span><br></pre></td></tr></table></figure><h2 id="4-3-定义之后任意赋值"><a href="#4-3-定义之后任意赋值" class="headerlink" title="4.3 定义之后任意赋值"></a>4.3 定义之后任意赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>=&#123;</span></span><br><span class="line">  .name=<span class="string">"Wang"</span>,</span><br><span class="line">  .number=<span class="number">12345</span>,</span><br><span class="line">  .sex=<span class="string">'W'</span>, </span><br><span class="line">&#125;;<span class="comment">//可以对任意变量赋值</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样写的好处时不用按照顺序来进行初始化，而且可以对你想要赋值的变量直接进行赋值，而不想赋值的变量可以不用赋值。<br>&emsp;&emsp;需要注意的是，<strong>如果在定义结构体变量的时候没有初始化，那么后面就不能全部一起初始化了。</strong>(数组性质)</p><h2 id="4-4-typedef-说明结构体类型"><a href="#4-4-typedef-说明结构体类型" class="headerlink" title="4.4 typedef 说明结构体类型"></a>4.4 typedef 说明结构体类型</h2><p>&emsp;&emsp;<code>typedef</code>  为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span>  //这里也可以不写<span class="title">tagMyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> iNum;</span><br><span class="line">    <span class="keyword">long</span> lLength;</span><br><span class="line">&#125;MyStruct;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的<code>tagMyStruct</code>是标识符，<code>MyStruct</code>是变量类型(相当于 <code>int</code> , <code>char</code> 等)。</p><p>这语句实际上完成两个操作：</p><ol><li>定义一个新的结构类型</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span>　　 </span><br><span class="line">    <span class="keyword">int</span> iNum; </span><br><span class="line">    <span class="keyword">long</span> lLength; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析：<code>tagMyStruct</code>  称为“tag”，即“标签”，实际上是一个临时名字，不论是否有 <code>typedef struct</code> 这个关键字 和 <code>tagMyStruct</code>  一起，构成了这个结构类型，这个结构都存在。我们可以用 <code>tagMyStruct varName</code>  来定义变量；但要注意，使用 <code>tagMyStruct varName</code>  来定义变量是不对的，因为 <code>struct </code> 和 <code>tagMyStruct </code>合在一起才能表示一个结构类型。</p><ol start="2"><li><code>typedef</code>为这个新的结构起了一个名字，叫<code>MyStruct</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span> <span class="title">MyStruct</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此，<code>MyStruct</code>实际上相当于 <code>struct tagMyStruct</code> ，我们可以使用 <code>MyStruct varName</code> 来定义变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> iNum;</span><br><span class="line">    <span class="keyword">long</span> lLength;</span><br><span class="line">&#125;MyStruct;</span><br></pre></td></tr></table></figure><p>在C中，这个申明后申请结构变量的方法有两种：<br>(1) <code>struct tagMyStruct 变量名</code>(typedef声明时可省略tagMyStruct，省略后则无法使用该方法定义结构变量)<br>(2) <code>MyStruct 变量名</code>(一般采用该方法)</p><h1 id="五、结构体变量的引用-结构体成员"><a href="#五、结构体变量的引用-结构体成员" class="headerlink" title="五、结构体变量的引用(结构体成员)"></a>五、结构体变量的引用(结构体成员)</h1><ol><li>结构体类型  声明定义的是  普通变量，普通变量 访问成员时就用 <code>.</code></li><li>结构体类型  声明定义的是  指针    ，指针 访问成员时就用 <code>-></code></li></ol><p><strong><font color="red">Ps：</font></strong> 若使用指针对结构体成员进行访问，格式为：指针-&gt;成员名 等价于 <code>(*指针).成员名</code> </p><p>但是有几点需要注意：<br>(1) <code>.</code>是运算符，在所有运算符优先级中最高<br>(2)如果结构体的成员本身是一个结构体，则需要继续用<code>.</code>运算符，直到最低一级的成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"> <span class="keyword">int</span> month;</span><br><span class="line"> <span class="keyword">int</span> day;</span><br><span class="line">&#125;birthday;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line">Student Stu1;<span class="comment">//定义结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,stu1.birthday);<span class="comment">//这样子是错误的，因为birthday也是一个结构体变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;stu1.birthday.month);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h1 id="六、结构体数组及其初始化-重点"><a href="#六、结构体数组及其初始化-重点" class="headerlink" title="六、结构体数组及其初始化(重点)"></a>六、结构体数组及其初始化(重点)</h1><p>&emsp;&emsp;这里我们简单说下，<strong>具有相同类型的结构体变量组成数组就是结构体数组</strong>。反而言之，是指数组中的每个元素都是一个结构体。在实际应用中，结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个车间的职工等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;stu1[<span class="number">5</span>]=&#123;</span><br><span class="line"> &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"wangwei"</span>,<span class="string">'M'</span>,<span class="number">14679</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"yulongjiao"</span>,<span class="string">'W'</span>,<span class="number">17857</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对结构体数组中全部元素赋值时，也可不给出数组长度，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> *name;<span class="comment">//指针类型指向字符串</span></span><br><span class="line"><span class="keyword">char</span> sex;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">&#125;stu1[]=&#123;</span><br><span class="line"> &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"wangwei"</span>,<span class="string">'M'</span>,<span class="number">14679</span>&#125;,</span><br><span class="line"> &#123;<span class="string">"yulongjiao"</span>,<span class="string">'W'</span>,<span class="number">17857</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red">Ps：</font></strong>在上面的Tip提到，结构体是一个变形的数组；结构体数组，其实就是变形的二元数组；数组的性质同样也是存在：<strong>结构体数组要在定义时就直接初始化赋值，不然后面再全部赋值是错误的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>；</span></span><br><span class="line"><span class="class"><span class="title">stu1</span>[3]=&#123;</span></span><br><span class="line">  &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//正确的示例  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>[]=&#123;</span></span><br><span class="line">    &#123;<span class="string">"zhaozixuan"</span>,<span class="string">'M'</span>,<span class="number">12345</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"houxiaohong"</span>,<span class="string">'M'</span>,<span class="number">12306</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"qxiaoxin"</span>,<span class="string">'W'</span>,<span class="number">12546</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><blockquote><p>数组初始化</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">str=<span class="string">"I love you"</span>; <span class="comment">//这样会修改数组的地址，原因如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化后，地址分配是固定的，数组名是(符号)地址常量；常量没有(可写的)内存空间存你要赋的值</span></span><br><span class="line"><span class="comment">//因此数组名不能作为左值</span></span><br><span class="line"><span class="comment">//所以我们可以把str[i]当左值，而无法把str当左值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确示范</span></span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line">str=<span class="string">"I love you"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在第一条语句中 <code>str</code> 就已经被定义成数组，而在C99标准中不允许将字符串(实际上是一个指针变量)赋值给数组(左值)，所以如果我们直接赋值是错误的。</p><p><strong><font color="red">注意区分声明时的初始化和普通的赋值语句！！！</font></strong></p><hr><blockquote><p>赋值运算</p></blockquote><p>&emsp;&emsp;赋值运算，分为左值和右值。</p><ol><li>左值：可以出现在赋值语句的左边或右边，它不光有值，还有一个存储地址；</li><li>右值：只能出现在赋值语句的右边，认为它只有一个值的大小，<strong>没有存储地址</strong>，只关心它的值(字符串常量则是存在字符常量区，只可读不可写)。</li></ol><hr><blockquote><p>数组名不可能作为左值！数组名不是指针！</p></blockquote><p>&emsp;&emsp;那么数组名应该如何理解呢？用来存放数组的区域是一块在栈中静态分配的内存(非static)，而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且，还是一个不可修改的常量，完整地说，就是一个地址常量。</p><p>&emsp;&emsp;数组名跟枚举常量类似，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。注意了！不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址，这就是数组名属于符号常量的意义所在。</p><p>&emsp;&emsp;由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，那么，数组名永远都不会是指针！</p><p>这里提供数组赋(字符串)值的3种方法：</p><ol><li><p>定义数组时直接定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>] = <span class="string">"I love you"</span>;</span><br></pre></td></tr></table></figure></li><li><p>用<code>strcpy</code>进行复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str,“I love you”);</span><br></pre></td></tr></table></figure></li><li><p>用<code>memset</code>进行复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memset&lt;/code&gt;语法介绍</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s,<span class="keyword">int</span> c,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//作用：将已开辟内存空间s的首n个字节的值设为值c。</span></span></span><br></pre></td></tr></table></figure><p> 3.1 如果是字符类型数组的话，memset可以随便用，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="string">'a'</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p> 3.2 但是对于其他类型的数组，一般只用来清0或者填-1，如果是填充其他数据就会出错，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str,<span class="number">1</span>,<span class="keyword">sizeof</span>(str));<span class="comment">//这样是错误的</span></span><br></pre></td></tr></table></figure><p> 3.3 错误分析</p><pre><code>- &lt;code&gt;memset&lt;/code&gt;在进行赋值时，是按字节为单位来进行赋值的，每次填充的数据长度为一个字节；- 对于其他类型的变量，比如int，占4个字节 所以sizeof(str)=40；- 用memset赋值时，将会对指向str地址的前40个字节进行赋值0x01（00000001） 的操作；**把0x00000000赋值4次0x01操作变为&lt;code&gt;0x01010101&lt;/code&gt;**(错误主要原因)；- 相当于给 “(所有)10个int” 进行了赋值&lt;code&gt;0x01010101&lt;/code&gt;的操作 对应十进制的16843009，所以会出很大的错误。</code></pre></li><li><p>用指针（注意内存分配方式）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str；</span><br><span class="line">str = <span class="string">"I love you"</span>;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这两句话的本质是， 在内存中开辟一段内存空间(字符常量区)，把<code>"I love you"</code>放进这段内存空间，然后把这段内存空间的地址交给str，由于str是变量(栈 或 堆)，所以给它赋值(地址，指向的内容)是合法的。</p><hr><p><strong><font color="red">memset用法总结：</font></strong>如果是清零一个数组用memset还是很方便的；简单赋字符串值，用strcmp函数(或memset)就行。</p><h1 id="七、结构体与指针"><a href="#七、结构体与指针" class="headerlink" title="七、结构体与指针"></a>七、结构体与指针</h1><p>&emsp;&emsp;指针指向的是变量所占内存的首地址，在结构体中，指针指向的是结构体变量的起始地址，当然也可指向结构体变量的元素。</p><h2 id="7-1-指向结构体变量的指针"><a href="#7-1-指向结构体变量的指针" class="headerlink" title="7.1 指向结构体变量的指针"></a>7.1 指向结构体变量的指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;student1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span></span><br><span class="line">p=&amp;student1;</span><br></pre></td></tr></table></figure><p>简单来说以下三种形式是等价的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;cName        //可以进行正常的运算</span><br><span class="line">(*p).cName      //这里的括号不能少，.运算符优先级最高</span><br><span class="line">student1.cName</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要注意的是，结构体访问成员方式和数组访问成员方式有些差别。</p><p>即使<code>*p</code>访问到了结构对象的第一个成员变量a，也不能保证<code>*(p+1)</code>就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定<code>*(pstr+1)</code>就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。 (用sizeof作为偏移量访问下一个成员要注意一下结构体空洞吖！)</p><h2 id="7-2-指向结构体数组的指针"><a href="#7-2-指向结构体数组的指针" class="headerlink" title="7.2 指向结构体数组的指针"></a>7.2 指向结构体数组的指针</h2><p>&emsp;&emsp;在我们想要用指针访问结构体数组的第n个数据时可以用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>[5];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>*<span class="title">p</span>;</span></span><br><span class="line">p=stu[n];</span><br><span class="line">(++p).number<span class="comment">//是指向了结构体数组下一个元素的地址</span></span><br></pre></td></tr></table></figure><h2 id="7-3-结构体成员是指针类型变量"><a href="#7-3-结构体成员是指针类型变量" class="headerlink" title="7.3 结构体成员是指针类型变量"></a>7.3 结构体成员是指针类型变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span>* Name;<span class="comment">//这样防止名字长短不一造成空间的浪费</span></span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;student1;</span><br></pre></td></tr></table></figure><p>在使用时可以很好地防止内存被浪费，但是注意在引用时一定要给指针变量分配地址，如果你不分配地址，结果可能是对的(野指针)，但是Name会被分配到任意的一地址，指针为字符串分配任何内存存储空间具有不确定性，这样就存在潜在的危险。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span>* Name;</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;stu，*stu；</span><br><span class="line"></span><br><span class="line">stu.name=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//内存初始化</span></span><br></pre></td></tr></table></figure><p>所对应的指针类型结构体成员要相应初始化分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span>* Name;</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">char</span> csex;  </span><br><span class="line">&#125;stu,*stu;</span><br><span class="line">stu = (struct student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct student));.<span class="comment">/*结构体指针初始化*/</span></span><br><span class="line">stu-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">/*结构体指针的成员指针同样需要初始化*/</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上，结构体指针、结构体成员指针就是指针，没有区别；只不过结构体成员指针容易被忽略初始化。而指针的初始化是很重要的，详情可以看 野指针一章的内容。</p><h2 id="7-4-结构体嵌套的问题"><a href="#7-4-结构体嵌套的问题" class="headerlink" title="7.4 结构体嵌套的问题"></a>7.4 结构体嵌套的问题</h2><p>结构体的<strong>自引用</strong>(self reference)，就是在结构体内部，包含指向自身类型结构体的指针。<br>结构体的<strong>相互引用</strong>（mutual reference），就是说在多个结构体中，都包含指向其他结构体的指针。</p><h3 id="7-4-1-自引用-结构体"><a href="#7-4-1-自引用-结构体" class="headerlink" title="7.4.1 自引用 结构体"></a>7.4.1 自引用 结构体</h3><blockquote><p>不使用 <code>typedef</code></p></blockquote><ol><li>错误的方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span> <span class="title">A</span>;</span>  </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这种声明是错误的，因为这种声明实际上是一个无限循环，成员A是一个结构体，A的内部还会有成员是结构体，依次下去，类似于永无出口的递归调用。在分配内存的时候，由于无限嵌套，也无法确定这个结构体的长度，所以这种方式是非法的。</p><ol start="2"><li>正确的方式：(使用<strong>指针</strong>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span> *<span class="title">A</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;由于<strong>指针的长度是确定的（在32位机器上指针长度为4），所以编译器能够确定该结构体的长度</strong>。</p><p><strong><font color="red">Ps：</font></strong>这个指针看似指向自身，其实不是，而是指向同一类型的不同结构。链表和树的数据结构就都使用到此技巧。自身的结构体指针指向下一节点或者下一子树的地址。</p><hr><blockquote><p>使用 <code>typedef</code> </p></blockquote><ol><li>错误的方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    NODE *link; </span><br><span class="line">&#125;NODE;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这里的目的是使用typedef为结构体创建一个别名NODE。但是这里是错误的，因为此时还没定义完类型名，而在结构体内部引用了结构类型名，是非法的。</p><ol start="2"><li>正确的方式：(使用<strong>不完全声明</strong>)有三种，差别不大，使用哪种都可以<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_1</span> *<span class="title">link</span>;</span> </span><br><span class="line">&#125; NODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虽然 C 语言编译器完全支持这种做法，但不推荐使用以下的第2种</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_2</span> <span class="title">NODE</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_2</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    NODE *link;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建议使用以下的第3种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_3</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_3</span> *<span class="title">link</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_3</span> <span class="title">NODE</span>;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="7-4-2-相互引用-结构体"><a href="#7-4-2-相互引用-结构体" class="headerlink" title="7.4.2 相互引用 结构体"></a>7.4.2 相互引用 结构体</h3><ol><li>错误的方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    B *bp; </span><br><span class="line">&#125;A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    A *ap;</span><br><span class="line">&#125;B;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;错误的原因和上面一样，这里类型B在定义之前 就被使用。</p><ol start="2"><li>正确的方式：(使用<strong>不完全声明</strong>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐使用第一种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> *<span class="title">bp</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> *<span class="title">ap</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>;</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span> *<span class="title">bp</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag_b</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_a</span> *<span class="title">ap</span>;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-5-结构体作为函数参数-形参"><a href="#7-5-结构体作为函数参数-形参" class="headerlink" title="7.5 结构体作为函数参数(形参)"></a>7.5 结构体作为函数参数(形参)</h2><p>将结构体传递给函数的方式有如下3种：</p><ol><li>用结构体的单个成员作为函数参数，向函数传递结构体的单个成员（属于<strong>传值调用</strong>，不会影响相应的实参结构体的值）</li><li>用结构体变量做函数参数，向函数传递结构体完整结构（属于<strong>传值调用</strong>，不会影响相应的实参结构体的值）</li><li><strong>用结构体指针或结构体数组作函数参数</strong>属于<strong>模拟按引用调用</strong>，会影响相应的实参结构体的值,向函数传递结构体地址，因为仅复制结构体首地址一个值给被调函数，相对于第二种方式，这种传递效率更高</li></ol><hr><blockquote><p>补充：传值调用与模拟按引用调用（参数传递）</p></blockquote><p><strong>按值调用</strong>：将程序将函数调用语句中的实参的一份副本传给函数的形参<br><strong>模拟按引用调用</strong>：指针作为函数的参数，虽然实际上也是传值给被调用函数，但是传给被调用函数的这个值不是变量的值，而是变量的地址，通过向被调用函数传递某个变量的地址值可以在被调函数中改变主调函数中这个变量的值，相当于模拟C++中的按引用调用因此称为模拟按引用调用</p><p>&emsp;&emsp;使用结构体变量作为函数参数的时候，是采取传值调用，将结构体所占内存单元的内容全部传递给形参，并且形参必须也要是同类型的结构体变量，在使用时，会自动创建一个结构体变量作为原变量的副本，并且也需要占内存，效率较低。且无法修改实际的结构体变量中成员的值。</p><p>&emsp;&emsp;如果用指针作为实参，传递给函数的形参，这时候传递的是结构体变量的地址，形参所指向的地址就是结构体变量的地址，这时候进行修改的话是可以修改的(这正是指针的精华所在)。</p><hr><h2 id="7-6-结构体的一些小技巧"><a href="#7-6-结构体的一些小技巧" class="headerlink" title="7.6 结构体的一些小技巧"></a>7.6 结构体的一些小技巧</h2><h3 id="7-6-1-互换结构体"><a href="#7-6-1-互换结构体" class="headerlink" title="7.6.1 互换结构体"></a>7.6.1 互换结构体</h3><p>在这里我们再提供几种互换两个结构体的方法：</p><ol><li>结构体指针互换地址</li><li>直接互换值(同类型结构体)</li><li>比较笨的方法：用for循环互换<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student student1=&#123;<span class="string">"Wang"</span>,<span class="number">12345</span>,<span class="string">'W'</span>&#125;;</span><br><span class="line">Student student2=&#123;<span class="string">"Zhao"</span>,<span class="number">54321</span>,<span class="string">'M'</span>&#125;; </span><br><span class="line">Student *stu1=&amp;student1;</span><br><span class="line">Student *stu2=&amp;student2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line">Student *stu3;</span><br><span class="line">stu3=stu1;</span><br><span class="line">stu1=stu2;</span><br><span class="line">stu2=stu3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">student3</span>;</span></span><br><span class="line">student3=student1;</span><br><span class="line">student1=student2;</span><br><span class="line">student2=student3;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-6-2-meset的妙用"><a href="#7-6-2-meset的妙用" class="headerlink" title="7.6.2 meset的妙用"></a>7.6.2 meset的妙用</h3><p>&emsp;&emsp;最后提下memset清空结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">char</span> cName[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> number;</span><br><span class="line"> <span class="keyword">char</span> csex;  </span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure><p>一般情况下，清空str的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　str.cName[<span class="number">0</span>]=<span class="string">'\0'</span>;</span><br><span class="line">　　str.csex=<span class="string">'0'</span>;</span><br><span class="line">　　str.number=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>但是我们用memset就非常方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;str,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct Student));</span><br></pre></td></tr></table></figure><p>如果是数组，就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[10];</span></span><br><span class="line"><span class="built_in">memset</span>(stu,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct Student)*<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="八、拓展-待写"><a href="#八、拓展-待写" class="headerlink" title="八、拓展(待写)"></a>八、拓展(待写)</h1><p>二叉树遍历算法<br>二叉树的二叉链表类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span>&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btnode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="九、友情链接"><a href="#九、友情链接" class="headerlink" title="九、友情链接"></a>九、友情链接</h1><p>多亏主要如下几位网友的资料<br><a href="https://www.cnblogs.com/tongongV/p/11008473.html" target="_blank" rel="noopener">结构体嵌套中的问题</a><br><a href="https://blog.csdn.net/as480133937/article/details/83473208" target="_blank" rel="noopener">c语言结构体学习整理(结构体初始化，结构体指针)</a><br><a href="https://www.cnblogs.com/lvjunjie/p/8961731.html" target="_blank" rel="noopener">结构体中定义函数指针</a><br><a href="https://www.cnblogs.com/lanhaicode/p/10312032.html" target="_blank" rel="noopener">结构体（结构体嵌套、结构体指针、结构体参数传递）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="结构体" scheme="http://shatang.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>结构体的洞和 #pragma pack</title>
    <link href="http://shatang.github.io/2020/03/15/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%B4%9E%E5%92%8C-pragma-pack/"/>
    <id>http://shatang.github.io/2020/03/15/结构体的洞和-pragma-pack/</id>
    <published>2020-03-15T03:41:45.000Z</published>
    <updated>2020-03-15T03:46:44.933Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、结构体中的“洞”"><a href="#一、结构体中的“洞”" class="headerlink" title="一、结构体中的“洞”"></a>一、结构体中的“洞”</h1><p>&emsp;&emsp;结构体中的每一个模块在内存中并不是禁止排列存储的，而是上下对齐存储。这种现象叫做内存对齐。这样做的目的是为了是处理器能够更快速的进行寻址，执行速度更快。以空间换取时间。看来鱼与熊掌还是不能兼得啊。</p><p>&emsp;&emsp;既然是上下对齐的，那么并不是每个模块都能准确的填满一行的内存空间。那么没有被填满的内存空间就造成了空洞。<br>&emsp;&emsp;这样的话，在查看结构体所占的空间时，就不能把每个模块所分别占的内存空间简单的相加。因为他们中间存在空洞。</p><h1 id="二、-pragma-pack"><a href="#二、-pragma-pack" class="headerlink" title="二、#pragma pack"></a>二、#pragma pack</h1><p>&emsp;&emsp;这是给编译器用的参数设置，有关结构体字节对齐方式设置， #pragma pack是指定数据在内存中的对齐方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack (n)             <span class="comment">//作用：C编译器将按照n个字节对齐。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack ()              <span class="comment">//作用：取消自定义字节对齐方式。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack (push,1)</span></span><br><span class="line"><span class="comment">//作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="comment">//作用：恢复对齐状态</span></span><br></pre></td></tr></table></figure><blockquote><p>#pragma pack(push,1)与#pragma pack(1)的区别</p></blockquote><p>&emsp;&emsp;因此可见，加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优。但是很多时候两者差别不大，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">//保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">//设定为4字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于 #pragma  pack (push,4)</span></span><br></pre></td></tr></table></figure><p>具体的使用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack (1)           </span></span><br><span class="line"><span class="comment">//结构体内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack ()</span></span><br><span class="line"><span class="comment">//作用：调整结构体的边界对齐，让其以一个字节对齐；&lt;使结构体按1字节方式对齐&gt;</span></span><br></pre></td></tr></table></figure><p>具体例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注：若不用#pragma pack(1)和#pragma pack()括起来，则sample按编译器默认方式对齐（成员中size最大的那个）。即按8字节（double）对齐，则sizeof(sample)==16.成员char a占了8个字节（其中7个是空字节）；若用#pragma pack(1)，则sample按1字节方式对齐sizeof(sample)＝＝9.（无空字节），比较节省空间啦。在有些场合还可使结构体更易于控制。</p><h1 id="三、应用实例"><a href="#三、应用实例" class="headerlink" title="三、应用实例"></a>三、应用实例</h1><p>&emsp;&emsp;在网络协议编程中，经常会处理不同协议的数据报文。一种方法是通过指针偏移的方法来得到各种信息，但这样做不仅编程复杂，而且一旦协议有变化，程序修改起来也比较麻烦。</p><p>&emsp;&emsp;在了解了编译器对结构空间的分配原则之后，我们完全可以利用这一特性定义自己的协议结构，通过访问结构的成员来获取各种信息。这样做，不仅简化了编程，而且即使协议发生变化，我们也只需修改协议结构的定义即可，其它程序无需修改，省时省力。下面以TCP协议首部为例，说明如何定义协议结构。其协议结构定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">// 按照1字节方式进行对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TCPHEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">short</span> SrcPort;     <span class="comment">// 16位源端口号</span></span><br><span class="line">     <span class="keyword">short</span> DstPort;     <span class="comment">// 16位目的端口号</span></span><br><span class="line">     <span class="keyword">int</span> SerialNo;      <span class="comment">// 32位序列号</span></span><br><span class="line">     <span class="keyword">int</span> AckNo;         <span class="comment">// 32位确认号</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> HaderLen : <span class="number">4</span>; <span class="comment">// 4位首部长度</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> Reserved1 : <span class="number">4</span>; <span class="comment">// 保留6位中的4位</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> Reserved2 : <span class="number">2</span>; <span class="comment">// 保留6位中的2位</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> URG : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> ACK : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> PSH : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> RST : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> SYN : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> FIN : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">short</span> WindowSize; <span class="comment">// 16位窗口大小</span></span><br><span class="line">     <span class="keyword">short</span> TcpChkSum; <span class="comment">// 16位TCP检验和</span></span><br><span class="line">     <span class="keyword">short</span> UrgentPointer; <span class="comment">// 16位紧急指针</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样的代码编译出来的是以1个字节的方式对齐的。这样能节约内存资源，但是会在效率上有所影响。</p><p>&emsp;&emsp;虽说在效率上有一定的影响，不过，如果编写的是基于协议，如网口、串口通讯的程序，最好严格按照一定的规则进行接收数据包。使用 <code>#pragma pack(1)</code>，让数据在内存中是连续的，实现结构体通过指针偏移(没有空洞)比较好处理。</p><p>&emsp;&emsp;用sizeof运算符求算某结构体所占空间时，并不是简单地将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题，有时候为了内存对齐需要补齐空字节。<strong>通常写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略</strong>。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。</p><p>&emsp;&emsp;也就是如果用编译器的(自动)对齐策略，采用指针偏移方式的方法可能会出现一些(不同编译器，对齐不同，错位)问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="结构体" scheme="http://shatang.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="字节对齐" scheme="http://shatang.github.io/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>关于函数指针的 强制转换 &amp; void指针</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-void%E6%8C%87%E9%92%88/"/>
    <id>http://shatang.github.io/2020/03/15/关于函数指针的-强制转换-void指针/</id>
    <published>2020-03-15T03:33:44.000Z</published>
    <updated>2020-03-15T03:40:06.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、大佬链接-和-结论"><a href="#一、大佬链接-和-结论" class="headerlink" title="一、大佬链接 和 结论"></a>一、大佬链接 和 结论</h1><p>&emsp;&emsp;下面链接是这篇博文的主力大佬，我只是润润色。<br><a href="https://blog.csdn.net/mickey35/article/details/80756348" target="_blank" rel="noopener">函数指针的强制类型转换与void指针</a><br><a href="https://blog.csdn.net/whshiyun/article/details/41379579?utm_source=blogxgwz2" target="_blank" rel="noopener">关于函数指针类型强制转换的一些摸索</a></p><p>先说结论：</p><ul><li>函数指针的指针参数只是一个标记，总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。<ul><li>换一种说法，函数指针中的形参最后使用的效果只由函数指针指向的实际函数的形参类型决定，中间处理过程只是作为一个没有类型的32位或者16位二进制数来处理。效果跟函数指针申明的形参没有多大关系。</li></ul></li><li>我们在<strong>使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参保持一致</strong>。</li></ul><h1 id="二、-常见的情况"><a href="#二、-常见的情况" class="headerlink" title="二、 常见的情况"></a>二、 常见的情况</h1><h2 id="2-1-函数指针常见用法"><a href="#2-1-函数指针常见用法" class="headerlink" title="2.1 函数指针常见用法"></a>2.1 函数指针常见用法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_int */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_int</span><span class="params">(<span class="keyword">int</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"整数:%d\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">200</span>;                <span class="comment">/* 真实整数变量 */</span></span><br><span class="line">    <span class="keyword">int</span>* p_i = &amp;i;              <span class="comment">/* 整数指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*f_ptr)(<span class="keyword">int</span> *p_fun);  <span class="comment">/* 函数指针 */</span></span><br><span class="line">    f_ptr = fun_int;            <span class="comment">/* 函数指针赋值 */</span></span><br><span class="line">    f_ptr(p_i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure><p>运行结果如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">整数:200</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总之就是，定义一个包含返回值类型和参数的函数指针，然后把一个返回值类型，参数类型及个数都相同的函数名（即地址）赋值给这个函数指针，这个函数指针就可以当成普通函数用了。</p><h2 id="2-2-函数指针强制类型转换"><a href="#2-2-函数指针强制类型转换" class="headerlink" title="2.2 函数指针强制类型转换"></a>2.2 函数指针强制类型转换</h2><p>&emsp;&emsp;此处只展示一种情况：函数指针和真实函数的返回值及参数个数都相同，只有参数类型不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_float */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_float</span><span class="params">(<span class="keyword">float</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"小数:%f\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20000</span>;      <span class="comment">/* 真实整数变量 */</span></span><br><span class="line">    <span class="keyword">int</span>* p_i = &amp;i;      <span class="comment">/* 整数指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">9.999f</span>;   <span class="comment">/* 真实浮点变量 */</span></span><br><span class="line">    <span class="keyword">float</span>* p_f = &amp;f;    <span class="comment">/* 浮点指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*f_ptr)(<span class="keyword">int</span> *p_fun);          <span class="comment">/* 函数指针 */</span></span><br><span class="line">    f_ptr = (<span class="keyword">void</span> (*)(<span class="keyword">int</span> *))fun_float; <span class="comment">/* 函数指针强制类型转换 */</span></span><br><span class="line">    f_ptr(p_i);         <span class="comment">/* 传入int指针 */</span></span><br><span class="line">    f_ptr((<span class="keyword">int</span> *)p_f);  <span class="comment">/* 传入float指针 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小数:<span class="number">0.000000</span></span><br><span class="line">小数:<span class="number">9.999000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时我们可以发现一件有趣的事情：尽管函数指针f_ptr的参数是int，但传入的int指针打印数据不正常（正常为20000），而类型不匹配的float指针却是对的（9.999）。</p><p>对此我总结了两点：</p><ul><li>函数指针的指针参数只是一个标记（或者说只是一个保存指针的地址？），总之其类型更多是为了编译器检查以及代码可读性，实际工作时只要产生强制类型转换之后，其类型就没有意义了，只是单纯的一个指针而已。</li><li>我们在使用函数指针时，需要保证调用该指针时的入参与该指针指向的真实函数的入参个数保持一致。</li></ul><h2 id="2-3-以void指针作为参数的函数指针"><a href="#2-3-以void指针作为参数的函数指针" class="headerlink" title="2.3 以void指针作为参数的函数指针"></a>2.3 以void指针作为参数的函数指针</h2><p>&emsp;&emsp;结合之前的结论，在函数指针中包含指针参数时，都可以用void指针进行替代（如果类型很明确就另当别论，直接写）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_int */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_int</span><span class="params">(<span class="keyword">int</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"整数:%d\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真实函数fun_float */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_float</span><span class="params">(<span class="keyword">float</span> *p_fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"小数:%f\n"</span>, *p_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">20000</span>;  <span class="comment">/* 真实整数变量 */</span></span><br><span class="line">    <span class="keyword">int</span>* p_i = &amp;i;  <span class="comment">/* 整数指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">9.999f</span>;   <span class="comment">/* 真实浮点变量 */</span></span><br><span class="line">    <span class="keyword">float</span>* p_f = &amp;f;    <span class="comment">/* 浮点指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*f_ptr)(<span class="keyword">void</span> *p_fun); <span class="comment">/* 函数指针 */</span></span><br><span class="line">    f_ptr = (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))fun_int;  <span class="comment">/* 强制为void* */</span></span><br><span class="line">    f_ptr(p_i);</span><br><span class="line">    f_ptr = (<span class="keyword">void</span>(*)(<span class="keyword">void</span> *))fun_float; <span class="comment">/* 强制为void* */</span></span><br><span class="line">    f_ptr(p_f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数:<span class="number">20000</span></span><br><span class="line">小数:<span class="number">9.999000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如此一来，只需要在函数指针赋值时进行强制类型转换就可以适应不同的真实函数。在调用时只要保证以void指针作为参数的函数指针结论中的第2点(形参个数保持一致)即可。</p><h1 id="三、参数个数不同的函数指针"><a href="#三、参数个数不同的函数指针" class="headerlink" title="三、参数个数不同的函数指针"></a>三、参数个数不同的函数指针</h1><p>&emsp;&emsp;这一块的知识简单了解一下就行。太内核了，从外面看就是玄学。</p><h2 id="3-1-“运气”例子"><a href="#3-1-“运气”例子" class="headerlink" title="3.1 “运气”例子"></a>3.1 “运气”例子</h2><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*F1)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*F2)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ff1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ff2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F1 f1 = (F1)ff2;</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">F2 f2 = (F2)ff1;</span><br><span class="line">f2(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>= =本人运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">2147483646</span></span><br></pre></td></tr></table></figure><p>原本例子的运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从运行结果中可以看到，当函数ff2被强制转换成一个F1类型的函数后，ff2的形参a的取值为F1类型函数的第一个形参的值，这里说明程序在执行的时候，如果该函数为一个只有n个形参的函数，如果你传递给他m个形参（n&lt;=m）,则该函数只会使用前n个形参。至于这里为什么可以允许这样的操作，后面将试探的分析一下。</p><p>&emsp;&emsp;接着，我们试图把一个ff1类型的函数，强制转换为一个F2类型的函数，并执行，执行结果还是在上面的图中，可以看到函数ff1的运行结果为3，2。</p><p>&emsp;&emsp;问题来了，我明明只传递给ff1这个函数1个参数，但为什么编译器没报错？虽然类型经过了强制转换，也许可以骗过编译器，但是在执行的时候，明明少了一个参数，程序执行的时候为什么也不报错？而且第二个参数的值还比较诡异，从打印的情况看，第二个参数为2，该值正是调用ff2的时候传递的第二个参数，该参数没被ff2处理，这里却被ff1处理，神马情况？</p><h2 id="3-2-测试”运气”"><a href="#3-2-测试”运气”" class="headerlink" title="3.2 测试”运气”"></a>3.2 测试”运气”</h2><p>&emsp;&emsp;首先，有一点，当每个函数被调用时，都被赋予了相对独立的栈空间，当该函数的生命周期结束后，该栈空间同时也被回收。</p><p>&emsp;&emsp;这样，当我们的main函数执行后，main函数有一个栈空间，假设为mem_A。那么根据上述实验结果，我这里有一个猜想，关于函数的参数是如何实现传递的。我的猜想是这样的，main函数在mem_A的栈空间中单独保留了一块类存给参数传递使用，假设该类存空间为mem_B。当一个函数运行时，程序把需要传递的参数按照顺序，放置在mem_B中，且每次都是从头开始放置。</p><p>&emsp;&emsp;回到刚刚的实验中，当ff2被执行后，mem_B中应该存放着0x00000001和0x00000002，这时再执行ff1，由于这里把ff1强制转换成了只含有一个形参的函数，所以当我们只传递给ff1一个参数3时，mem_B中应该存放着0x00000003和0x00000002，这样，ff1调用的结果可以符合以上输出结果，这里为了确定这样的结果不是巧合，又进行了数次实验，均与以上猜想相符。按照以上猜想，如果ff1先执行，ff2后执行，则ff1的第二个参数应该为一个随机数，为了验证该想法，又进行了如下实验。</p><p>其他代码都一样，就是把两个函数的执行顺序掉了一下顺序，输出结果下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F2 f2 = (F2)ff1;</span><br><span class="line">f2(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">F1 f1 = (F1)ff2;</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本人和原例运行类似，结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">-417232744</span></span><br><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，现在的编译器则是另外开辟栈空间。由于是另外开辟的情况，无法验证第二位博主的： 参数的存储是以4字节为一个存储单元的，也就是说当一个char类型的变量作为参数传递，在mem_B中占的内存大写依旧为4字节。</p><h2 id="3-3-无卵用-总结"><a href="#3-3-无卵用-总结" class="headerlink" title="3.3 (无卵用)总结"></a>3.3 (无卵用)总结</h2><p>&emsp;&emsp;由于不能复现之前博主的情况，也无法确定他的结论。但是也有发现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">F1 f1 = (F1)ff2;</span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">F2 f2 = (F2)ff1;</span><br><span class="line">f2(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本人运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff2</span><br><span class="line"><span class="number">1</span></span><br><span class="line">ff1</span><br><span class="line"><span class="number">3</span>,<span class="number">2147483646</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;无论如何改动f1中的第二个参数，最后打印的随机值都不会发生变化。但是如果更换成ff2先执行，ff1后执行，该值就会随着f1中的第二个参数变化而变化。</p><p>简单分析，按照程序执行顺序：</p><ul><li>如果先执行：多形参的函数；会多开辟多的栈空间，但是由于被强转为单形参，另外一个形参值则为一个随机值。后面执行单形参函数，开辟的栈小，多出来的形参会影响到之前双形参的栈空间存放值。</li><li>如果先执行：单形参函数；实际的栈开辟小，打印出来的随机值则不受第二个形参输入的影响(不是明确关系，值波动很大)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="强制转换" scheme="http://shatang.github.io/tags/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="函数指针" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>指针类型_的_函数（函数指针）</title>
    <link href="http://shatang.github.io/2020/03/15/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%EF%BC%88%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89/"/>
    <id>http://shatang.github.io/2020/03/15/指针类型-的-函数（函数指针）/</id>
    <published>2020-03-15T03:26:30.000Z</published>
    <updated>2020-03-15T03:31:30.297Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、函数指针的概念"><a href="#一、函数指针的概念" class="headerlink" title="一、函数指针的概念"></a>一、函数指针的概念</h1><h2 id="1-1-什么是函数指针"><a href="#1-1-什么是函数指针" class="headerlink" title="1.1 什么是函数指针"></a>1.1 什么是函数指针</h2><p>&emsp;&emsp;如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><ul><li><strong>函数指针 和 函数名 本质上是一样的，都是指向函数调用地址的指针；</strong></li><li><strong>只是 函数名 是常量指针，函数指针 是变量指针。</strong></li></ul><h2 id="1-2-如何定义函数指针"><a href="#1-2-如何定义函数指针" class="headerlink" title="1.2 如何定义函数指针"></a>1.2 如何定义函数指针</h2><p>&emsp;&emsp;那么这个指针变量怎么定义呢？</p><p>虽然同样是指向一个地址，但指向函数的指针变量和指向变量的指针变量的定义方式是不同的。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个语句就定义了一个指向函数的指针变量p。首先它是一个指针变量，所以要有一个“*”，即（*p）；其次前面的 int 表示这个指针变量可以指向返回值类型为<code>int</code>型的函数；后面括号中的两个<code>int</code>表示这个指针变量可以指向有两个参数且都是<code>int</code>型的函数。所以合起来这个语句的意思就是：定义了一个指针变量<code>p</code>，该指针变量可以指向返回值类型为<code>int</code>型，且有两个整型参数的函数。<code>p</code>的类型为<code>int(*)(int，int)</code>。</p><p>所以函数指针的定义方式为：</p><p><code>函数返回值类型 (* 指针变量名) (函数参数列表);</code></p><ol><li>“函数返回值类型”表示该指针变量可以指向具有什么返回值类型的函数；</li><li>“函数参数列表”表示该指针变量可以指向具有什么参数列表的函数。这个参数列表中只需要写函数的参数类型即可。</li></ol><h2 id="1-3-注意要点"><a href="#1-3-注意要点" class="headerlink" title="1.3 注意要点"></a>1.3 注意要点</h2><blockquote><p>函数指针定义时，(*指针变量名)”两端的括号不能省略</p></blockquote><p>&emsp;&emsp;我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“（*指针变量名）”。但是这里需要注意的是：“(*指针变量名)”两端的括号不能省略，括号改变了运算符的优先级。<strong>如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数(指针函数)</strong>。</p><blockquote><p>如何判断 指针变量 是 指向 变量 还是 函数 ？</p></blockquote><ol><li>首先看变量名前面有没有“*”，如果有“*”说明是指针变量；</li><li>其次看变量名的后面有没有带有形参类型的圆括号，如果有就是指向函数的指针变量，即函数指针，如果没有就是指向变量的指针变量；</li><li>最后需要注意的是，指向函数的指针变量没有 ++ 和 – 运算。</li></ol><h1 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h1><p>&emsp;&emsp;函数指针怎么用？</p><h2 id="2-1-调用例子"><a href="#2-1-调用例子" class="headerlink" title="2.1 调用例子"></a>2.1 调用例子</h2><p>要点分为两个:</p><ol><li>指针 赋值 为函数地址：</li></ol><p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure><p>取地址运算符<code>&</code>不是必需的，因为<strong>一个函数标识符就表示了它的地址</strong>，如果是函数调用，还必须包含一个圆括号括起来的参数表。</p><ol start="2"><li>调用 函数指针：</li></ol><p>调用函数指针的方式也有两种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用函数的写法(*func)()、func()均可；而我们大多数情况下都会写成前者(看上去和普通的函数调用没啥区别)，应该是（C/C++标准制定者）为了方便大家对函数的调用。如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。</p><blockquote><p>简单例子</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;   <span class="comment">/*声明一个函数*/</span></span><br><span class="line"><span class="keyword">int</span> (*p) (<span class="keyword">int</span> x);  <span class="comment">/*定义一个函数指针*/</span></span><br><span class="line">p = Func;          <span class="comment">/*将Func函数的首地址赋给指针变量p*/</span></span><br></pre></td></tr></table></figure><ol><li>赋值时函数 Func 不带括号，也不带参数。</li><li>由于函数名Func代表函数的首地址，因此经过赋值以后，指针变量 p 就指向函数 Func() 代码的首地址了。</li></ol><h2 id="2-2-实际例子"><a href="#2-2-实际例子" class="headerlink" title="2.2 实际例子"></a>2.2 实际例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;      <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>(*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);  <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    p = Max;            <span class="comment">//把函数Max赋给指针变量p, 使p指向Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please enter a and b:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    c = (*p)(a, b);     <span class="comment">//通过函数指针调用Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\nb = %d\nmax = %d\n"</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  <span class="comment">//定义Max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">please enter a and b:<span class="number">3</span> <span class="number">4</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">max = <span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="三、函数指针的优点"><a href="#三、函数指针的优点" class="headerlink" title="三、函数指针的优点"></a>三、函数指针的优点</h1><p>&emsp;&emsp;有的通用函数中要涉用到另一个函数，但函数名称未定，是让用户编的，当然要做成函数指针，即API（application programming interface，应用编程接口）。函数指针的优点，其实就是函数指针的应用：回调函数</p><p><strong>回调函数，本质上都是“你想让别人的代码执行你的代码，而别人的代码你又不能动”这种需求下产生的。</strong></p><blockquote><p>举例1</p></blockquote><p>&emsp;&emsp;别人给你的不是源代码，是一个已经编译好的模块，并且不会给你源代码，那是商业机密，留给你一个接口，你把你要执行的代码以回调函数的形式交给这个接口，由别人编写的模块在需要的时候调用。</p><blockquote><p>举例2</p></blockquote><p>&emsp;&emsp;进行通用定积分计算，被计算函数是待定的，是由调用者确定的函数，这也得是函数指针。</p><h1 id="四、回调函数"><a href="#四、回调函数" class="headerlink" title="四、回调函数"></a>四、回调函数</h1><p>&emsp;&emsp;对指针的应用是C语言编程的精髓所在，而回调函数就是C语言里面对函数指针的高级应用。简而言之，回调函数是一个通过函数指针调用的函数。</p><ul><li><strong>函数指针和函数名本质上是一样的，都是指向函数调用地址的指针；</strong></li><li><strong>只是函数名是常量指针，函数指针是变量指针。</strong></li></ul><h2 id="4-1-回调函数的定义"><a href="#4-1-回调函数的定义" class="headerlink" title="4.1 回调函数的定义"></a>4.1 回调函数的定义</h2><p>&emsp;&emsp;把函数指针（函数的入口地址）传递给另一个函数(的形参)，当这个函数指针被用来调用它所指向的函数时，我们就说这个函数是回调函数。</p><h2 id="4-2-回调函数的意义-简易"><a href="#4-2-回调函数的意义-简易" class="headerlink" title="4.2 回调函数的意义(简易)"></a>4.2 回调函数的意义(简易)</h2><ol><li>其他情况：当一个函数要调用另外一个函数，直接在函数体调用对应的函数；</li><li>回调情况：当一个函数要调用另外一个函数，将另外函数的指针作为形参，当需要调用对应函数时，调用指针进而可调用对应函数。</li></ol><p>&emsp;&emsp;很多朋友可能会想，为什么不像普通函数调用那样，在回调的地方直接写函数的名字呢？这样不也可以吗？为什么非得用回调函数呢？在网上看到解析回调函数的很多例子，其实完全可以用普通函数调用来实现的。</p><p>&emsp;&emsp;要回答这个问题，我们先来了解一下回到函数的好处和作用：那就是解耦。<br>对，就是这么简单的答案，就是因为这个特点，普通函数代替不了回调函数。</p><p>&emsp;&emsp;当你在库函数传入其他函数指针，只要函数指针的函数类型相同，就能做到改动函数指针指向的函数功能，而且还不影响传入(函数)指针形参的库函数(不需要改动)。甚至你可以调用同类型的函数指针 传入 库函数。(例如多驱动，Uart4和Uart5两个串口驱动，只要传入函数指针变动传入指针就行)。</p><h2 id="4-3-回调函数的意义-深入"><a href="#4-3-回调函数的意义-深入" class="headerlink" title="4.3 回调函数的意义(深入)"></a>4.3 回调函数的意义(深入)</h2><p>&emsp;&emsp;<strong><font color="red">函数指针的语法理解上并不难，难就难在对函数指针实现设计模式和设计方法上的运用。</font></strong> </p><p>原因在于，难的不是函数指针的概念和语法本身，而是在什么时候，什么地方该使用它。函数指针不仅是语法上的问题，更重要的是它是一个设计范畴。真正的高手当然不单应该懂得语法层面上的技巧，更应该懂得设计上的方法。不懂设计，能算高手吗？怀疑我在夸大其辞吗？那我们先看看函数指针与哪些设计方法有关：</p><p><strong><em>与分层设计有关</em></strong>。分层设计早就不是什么新的概念，分层的好处是众所周知的，比较明显好处就是简化复杂度、隔离变化。采用分层设计，每层都只需关心自己的东西，这减小了系统的复杂度，层与层之间的交互仅限于一个很窄的接口，只要接口不变，某一层的变化不会影响其它层，这隔离了变化。</p><p>分层的一般原则是，上层可以直接调用下层的函数，下层则不能直接调用上层的函数。这句话说来简单，在现实中，下层常常要反过来调用上层的函数。比如你在拷贝文件时，在界面层调用一个拷贝文件函数。界面层是上层，拷贝文件函数是下层，上层调用下层，理所当然。但是如果你想在拷贝文件时还要更新进度条，问题就来了。一方面，只有拷贝文件函数才知道拷贝的进度，但它不能去更新界面的进度条。另外一方面，界面知道如何去更新进度条，但它又不知道拷贝的进度。怎么办？常见的做法，就是界面设置一个回调函数给拷贝文件函数，拷贝文件函数在适当的时候调用这个回调函数来通知界面更新状态。</p><p><strong><em>与抽象有关</em></strong>。抽象是面向对象中最重要的概念之一，也是面向对象威力强大之处。面向对象只是一种思想，大家都知道，用C语言一样可以实现面向对象的编程。这可不是为了赶时髦，而是一种实用的方法。如果你对此表示怀疑，可以去看看GTK+、linux kernel等开源代码。</p><p>接口是最高级的抽象。在linux kernel里面，接口的概念无处不在，像虚拟文件系统(VFS)，它定义一个文件系统的接口，只要按照这种接口的规范，你可以自己开发一个文件系统挂上去。设备驱动程序更是如此，不同的设备驱动程序有自己一套不同的接口规范。在自己开发设备开发驱动程序时，只要遵循相应的接口规范就行了。接口在C语言中如何表示？很简单，就是一组函数指针。</p><p><strong><em>与接口与实现分开有关</em></strong>。针对接口编程，而不是针对实现编程，此为《设计模式》的第一条设计准则。分开接口与实现的目标是要隔离变化。软件是变化的，如果不能把变化的东西隔离开来，导致牵一发而动全身，代价是巨大的。这是大家所不愿看到的。</p><p>C语言既然可以实现面向对象的编程，自然可以利用设计模式来分离接口与实现。像桥接模式、策略模式、状态模式、代理模式等等，在C语言中，无一不需要利用函数指针来实现。</p><p><strong><em>与松耦合原则有关</em></strong>。面向过程与面向对象相比，之所以显得苍白无力，原因之一就是它不像面向对象一样，可以直观的把现实模型映射到计算机中。面向过程讲的是层层控制，而面向对象更强调的对象间的分工合作。现实世界中的对象处于层次关系的较少，处于对等关系的居多。也就是说，对象间的交互往往是双向的。这会加强对象间的耦合性。</p><p>耦合本身没有错，实际上耦合是必不可少的，没有耦合就没有协作，对象之间无法形成一个整体，什么事也做不了。关键在于耦合要恰当，在实现预定功能的前提下，耦合要尽可能的松散。这样，系统的一部分变化对其它部分的影响会很少。</p><p>函数指针是解耦对象关系的最佳利器。Signal(如boost的signal和glib中的signal)机制是一个典型的例子，一个对象自身的状态可能是在变化的（或者会触发一些事件），而其它对象关心它的变化。一旦该对象有变化发生，其它对象要执行相应的操作。</p><p>如果该对象直接去调用其它对象的函数，功能是完成了，但对象之间的耦合太紧了。如何把这种耦合降到最低呢，signal机制是很好的办法。它的原理大致如下：其它关注该对象变化的对象主动注册一个回调函数到该对象中。一旦该对象有变化发生，就调用这些回调函数通知其它对象。功能同样实现了，但它们之间的耦合度降低了</p><p>在C语言中，要解决以上这些问题，不采用函数指针，将是非常困难的。在编程中，如果你从没有想到用函数指针，很难想像你是一个C语言高手。</p><h2 id="4-4-回调函数的意义-总结"><a href="#4-4-回调函数的意义-总结" class="headerlink" title="4.4 回调函数的意义(总结)"></a>4.4 回调函数的意义(总结)</h2><p>&emsp;&emsp;我们对回调函数的使用无非是对函数指针的应用，函数指针的概念本身很简单，但是把函数指针应用于回调函数就体现了一种解决问题的策略，一种设计系统的思想。</p><p>&emsp;&emsp;在解释这种思想前我想先说明一下，回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。回调函数本身是一种破坏系统结构的设计思路，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。</p><p>&emsp;&emsp;那么什么是回调函数呢，那是不得以而为之的设计策略，想象一种系统实现：在一个下载系统中有一个文件下载模块和一个下载文件当前进度显示模块，系统要求实时的显示文件的下载进度，想想很简单在面向对象的世界里无非是实现两个类而已。但是问题恰恰出在这里，显示模块如何驱动下载进度条？显示模块不知道也不应该知道下载模块所知道的文件下载进度（面向对象设计的封装性，模块间要解耦，模块内要内聚），文件下载进度是只有下载模块才知道的事情，解决方案很简单给下载模块传递一个函数指针作为回调函数驱动显示模块的显示进度。</p><p>&emsp;&emsp;在面向对象的世界中这样的例子还真不少，造成这样的问题的根源，相信大家已经从上面的叙述中体会到了，就是面向对象的程序设计思想，就是设计模式中要求的模块独立性，高内聚低耦合等特性。</p><p>&emsp;&emsp;封装变化的编程策略给编程人员第一位的指导思想就是面向接口编程，即设计模式中提到的面向虚拟编程而不是面向实现。这样的编程思想极大地革新了编程世界，可以说没有这一原则就没有面向对象的程序设计，这一原则给程序设计一种指导思想即如何更高的将现实模型映射成程序模型。这样的设计思想在极大地催生高度独立性模块的同时削弱了模块间的协作性，也就是耦合性，它使得模块间更多的从事着单向的调用工作，一个模块需要某种服务就去找另一个模块，这使得程序呈现出层次性，高层通过接口调用底层，底层提供服务。但是现实世界中严格遵循现层次特性的系统是很少见的，绝对的MVC是不存在的，因为更多的模块要求通并协作，可见没有耦合就没有协作没有好的调用关系，耦合真的不是错。</p><p>&emsp;&emsp;既然我们需要模块间的协作，同时我们又厌恶的摒弃模块间你中有我我中有你的暧昧关系那如何生成系统呢，答案是函数指针（不一定一定是函数指针）也就是使用回调的方式。如果一个对象关心另一个对象的状态变化那么给状态的变化注册回调函数让它通知你这类状态的改变，这样在封装了模块变化的同时实现了模块间的协作关系另辟独径的给对象解耦。</p><h1 id="五、回调函数应用"><a href="#五、回调函数应用" class="headerlink" title="五、回调函数应用"></a>五、回调函数应用</h1><h2 id="5-1-typedef-void-pFunc"><a href="#5-1-typedef-void-pFunc" class="headerlink" title="5.1 typedef void (*pFunc)();"></a>5.1 <code>typedef void (*pFunc)();</code></h2><p>&emsp;&emsp;事实上,为了代码的移植考虑,一般使用typedef定义函数指针类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef int (*funcptr)();</span></span><br><span class="line"><span class="comment">//定义一个返回值为int，不带参数的函数指针</span></span><br><span class="line"><span class="comment">//就是说funcptr 是 int (*)()型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//funcptr table[10]; </span></span><br><span class="line"><span class="comment">//定义一个数组，这个数组是funcptr类型的</span></span><br><span class="line"><span class="comment">//就是说这个数组内的元素都是一个(函数)指针</span></span><br><span class="line"><span class="comment">//这个指针指向一个返回值为int，不带参数的函数</span></span><br></pre></td></tr></table></figure><p>有了函数指针类型，以后我们就可以象变量一样声明函数指针，如下例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pFunc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFunc func;</span><br><span class="line">    unc = &amp;myFunc;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-怎么使用带参数的回调函数？"><a href="#5-2-怎么使用带参数的回调函数？" class="headerlink" title="5.2 怎么使用带参数的回调函数？"></a>5.2 怎么使用带参数的回调函数？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_1</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_1: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_2: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Callback_3</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// Callback Function 3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, this is Callback_3: x = %d "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Handle</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> (*Callback)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Handle Function. "</span>);</span><br><span class="line">    Callback(y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Handle Function. "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Entering Main Function. "</span>);</span><br><span class="line">    Handle(a, Callback_1);</span><br><span class="line">    Handle(b, Callback_2);</span><br><span class="line">    Handle(c, Callback_3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaving Main Function. "</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Entering Main Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_1: x = 2</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_2: x = 4</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Entering Handle Function.</span><br><span class="line">Hello, this is Callback_3: x = 6</span><br><span class="line">Leaving Handle Function.</span><br><span class="line">Leaving Main Function.</span><br><span class="line">``` </span><br><span class="line">&amp;emsp;&amp;emsp;可以看到，并不是直接把&lt;code&gt;int Handle(int (\*Callback)())&lt;/code&gt; 改成 &lt;code&gt;int Handle(int (\*Callback)(int))&lt;/code&gt;  就可以的。而是通过另外增加一个参数来保存回调函数的参数值，像这里 &lt;code&gt;int Handle(int y, int (*Callback)(int))&lt;/code&gt; 的参数 y。同理，可以使用多个参数的回调函数。</span><br><span class="line"></span><br><span class="line">## 5.3 结构体中的函数指针</span><br><span class="line">&amp;emsp;&amp;emsp;C语言中的struct是最接近类的概念，但是在C语言的struct中只有成员，不能有函数，但是可以有指向函数的指针，这也就方便了我们使用函数了。举个例子，如下：</span><br><span class="line">```C</span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">      </span><br><span class="line">typedef struct student  </span><br><span class="line">&#123;  </span><br><span class="line">    int id;  </span><br><span class="line">    char name[50];   </span><br><span class="line">    void (*initial)();  </span><br><span class="line">    void (*process)(int id, char *name);  </span><br><span class="line">    void (*destroy)();  </span><br><span class="line">&#125;stu;  </span><br><span class="line">      </span><br><span class="line">void initial()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;initialization...\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line">void process(int id, char *name)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;process...\n%d\t%s\n&quot;,id, name);  </span><br><span class="line">&#125;  </span><br><span class="line">     </span><br><span class="line">void destroy()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;destroy...\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">      </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    stu *stu1;  </span><br><span class="line">    //在VC和TC下没有malloc也可以正常运行，但是linux gcc下就会出错，为段错误，必须使用malloc  </span><br><span class="line">    stu1=(stu *)malloc(sizeof(stu));  </span><br><span class="line">    //使用的时候必须要先初始化  </span><br><span class="line">    stu1-&gt;id=1000;  </span><br><span class="line">    strcpy(stu1-&gt;name,&quot;C++&quot;);  </span><br><span class="line">    stu1-&gt;initial=initial;  </span><br><span class="line">    stu1-&gt;process=process;  </span><br><span class="line">    stu1-&gt;destroy=destroy;  </span><br><span class="line">    printf(&quot;%d\t%s\n&quot;,stu1-&gt;id,stu1-&gt;name);  </span><br><span class="line">    stu1-&gt;initial();  </span><br><span class="line">    stu1-&gt;process(stu1-&gt;id, stu1-&gt;name);  </span><br><span class="line">    stu1-&gt;destroy();  </span><br><span class="line">    free(stu1);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端显示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span>    C++</span><br><span class="line">initialization...</span><br><span class="line">process...</span><br><span class="line"><span class="number">1000</span>    C++</span><br><span class="line">destroy..</span><br></pre></td></tr></table></figure><p><strong><font color="red">Ps：</font></strong>无论是什么类型(结构体也是)的指针，都要主要初始化(或赋内存)。</p><h2 id="5-3-结构体拓展——协议类"><a href="#5-3-结构体拓展——协议类" class="headerlink" title="5.3 结构体拓展——协议类"></a>5.3 结构体拓展——协议类</h2><p>&emsp;&emsp;c语言中，如何在结构体中实现函数的功能？把结构体做成和类相似，让他的内部有属性，也有方法，<br>这样的结构体一般称为协议类，提供参考： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">　　<span class="keyword">int</span> funcid; </span><br><span class="line">　　<span class="keyword">char</span> *funcname; </span><br><span class="line">　　<span class="keyword">int</span> (*funcint)();   <span class="comment">/* 函数指针 int 类型*/</span> </span><br><span class="line">　　<span class="keyword">void</span> (*funcvoid)();  <span class="comment">/* 函数指针 void类型*/</span> </span><br><span class="line">&#125;XXX;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每次都要注意：需要初始化。</p><p>该回调函数的用法为： </p><ol><li>甲方进行结构体的定义（成员中包括回调函数的指针）</li><li>乙方定义结构体变量，并向甲方注册， </li><li>甲方收集N个乙方的注册形成结构体链表，在某个特定时刻遍历链表，进行回调。 </li><li>当函数指针做为函数的参数，传递给一个被调用函数，被调用函数就可以通过这个指针调用外部的函数，这就形成了回调</li><li>一般的程序中回调函数作用不是非常明显，可以不使用这种形式</li><li>最主要的用途就是当函数不处在同一个文件当中，比如动态库，要调用其他程序中的函数就只有采用回调的形式</li><li>通过函数指针参数将外部函数地址传入来实现调用函数的代码作了修改，也不必改动库的代码(只是函数指针指向的函数修改变动，库的处理没有变动)，就可以正常实现调用便于程序的维护和升级 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="函数指针" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
      <category term="函数" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>指针类型_的_函数返回值(指针函数)</title>
    <link href="http://shatang.github.io/2020/03/15/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/"/>
    <id>http://shatang.github.io/2020/03/15/指针类型-的-函数返回值-指针函数/</id>
    <published>2020-03-15T03:13:04.000Z</published>
    <updated>2020-03-15T03:25:37.433Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、函数返回值的要点"><a href="#一、函数返回值的要点" class="headerlink" title="一、函数返回值的要点"></a>一、函数返回值的要点</h1><p><strong><font color="red">注意（原则）</font></strong>：可以返回局部变量本身，<strong>但永远不要返回一个局部变量的指针或引用(其实是隐式的指针)</strong>；</p><p>原因：<strong>局部变量只是临时的存储空间，因为函数执行完之后，将释放分配给局部变量的存储空间</strong>，此时，对局部变量的引用和地址就会返回不确定的内存(野指针)。</p><blockquote><p>系统堆栈的知识点</p></blockquote><p>&emsp;&emsp;函数调用过程中，一个函数在调用另外一个函数的时候，会先将调用前的现场信息保存在系统堆栈中，然后按照从又向左的顺序(c语言)将实参的结果入栈，而被调用的函数的形参，用的就是实参的空间，当被调用的函数运行结束后，局部变量的空间被“释放”的本质，其实是栈顶的指针，移动到了调用前函数的现场信息的地方，所以刚才被调用的函数的局部变量，实际上它的值还是存放在内存中，并且在当前栈顶指针的上面的连续空间中。</p><blockquote><p>简单理解</p></blockquote><p>&emsp;&emsp;函数执行完，局部变量会被释放，此时指向 已释放的局部变量 的指针 是很危险(不确定)的；如果不调用还好(但不调用，那要返回值干嘛?)；</p><p>&emsp;&emsp;一旦其他函数调用该函数返回值指针，该指针指向的内存不确定就会造成不可知的错误。</p><h1 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h1><ol><li><p>返回变量本身</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个返回变量本身内存可以，正确</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回局部变量指针，用法错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> &amp;sum;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>会出现以下警告： </p><p><code>warning: function returns address of local variable [-Wreturn-local-addr] return &amp;sum;</code></p><p>警告：函数返回地址是局部变量地址—&gt;这是不安全的</p><h1 id="三、解决方案和利弊"><a href="#三、解决方案和利弊" class="headerlink" title="三、解决方案和利弊"></a>三、解决方案和利弊</h1><h2 id="3-1-解决方案"><a href="#3-1-解决方案" class="headerlink" title="3.1 解决方案"></a>3.1 解决方案</h2><p>该如何解决这种错误呢？有以下3种常用方案：</p><ol><li>使用静态变量</li><li>使用全局变量</li><li>申请堆区变量</li></ol><p>其实，使用这三种方法都是为了延长变量的声明周期，从而达到返回的地址是确定的而不是不确定的。</p><p>法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> &amp;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *add(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* sum = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> *result;</span><br><span class="line">    result = add(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但法3需要注意，由于用new申请的动态内存，调用者（这里是main）需要释放这个申请的指针free, delete</p><h2 id="3-2-利弊"><a href="#3-2-利弊" class="headerlink" title="3.2 利弊"></a>3.2 利弊</h2><ol><li>法3的 申请堆区变量 比较麻烦，一般不常用；</li><li>法2的 使用全局变量 比较鸡肋；如果是全局变量的(函数返回值)指针，为啥不直接调用该指针，函数就不需要返回(全局)指针，该返回值充其量像是 提示 ，或者是函数格式要求</li><li>法1的 使用局部变量 比较推荐</li></ol><blockquote><p>总结：指针类型的函数返回值 还是不推荐用。</p></blockquote><p>&emsp;&emsp;采用<code>return</code>语句返回的指针，原本想法是让函数返回多个数值(数组、结构体)；但<strong>指针往往是作为函数形参来直接改变实参(数值)，从而让函数变相返回多个数值</strong>；因此，指针类型的函数返回值，功能少且鸡肋(容易出事)，不推荐使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="函数" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数返回值" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>指针类型_的_函数形参</title>
    <link href="http://shatang.github.io/2020/03/15/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-%E7%9A%84-%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82/"/>
    <id>http://shatang.github.io/2020/03/15/指针类型-的-函数形参/</id>
    <published>2020-03-15T03:03:12.000Z</published>
    <updated>2020-03-15T03:10:58.442Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、指针作为函数参数"><a href="#一、指针作为函数参数" class="headerlink" title="一、指针作为函数参数"></a>一、指针作为函数参数</h1><h2 id="1-1-函数参数的传递方式"><a href="#1-1-函数参数的传递方式" class="headerlink" title="1.1 函数参数的传递方式"></a>1.1 函数参数的传递方式</h2><p>C语言的函数参数的传递方式有以下两种：</p><ol><li><strong>值传递</strong>：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</li><li><strong>指针传递</strong>：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作</li></ol><h2 id="1-2-函数相关的知识"><a href="#1-2-函数相关的知识" class="headerlink" title="1.2 函数相关的知识"></a>1.2 函数相关的知识</h2><ol><li>函数(return)返回值：实际一般是返回(处理过的)局部变量；且只能返回单个值；</li><li>指针作为函数参数，<strong>指针能使被调函数(变相)返回一个以上的结果</strong>。（直接对内存操作3改变多个实参）</li><li>函数内部修改外部变量的值，需要一级指针；</li><li>函数内部修改外部指针变量的值，需要二级指针；</li></ol><p>所以要想直接对内存单元进行操控，用指针最直接，指针的功能很强大。</p><h2 id="1-3-举例"><a href="#1-3-举例" class="headerlink" title="1.3 举例"></a>1.3 举例</h2><hr><p>经典例子1 ：交换CET1 和 CET2 的值（一级指针交换值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wrong</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_val</span><span class="params">(<span class="keyword">int</span> a,intb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误原因：因为交换的是副本(形参)，真品(实参)没改变的。</p><hr><p>经典例子2：是在学习STM32的库函数的使用。当初刚接触库函数，对于函数初始化接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure><p>分析：为什么要取初始化结构体变量的地址传递进库函数（&amp;GPIO_InitStructure），而不是直接将结构体变量本身（GPIO_InitStructure）传递进去？</p><hr><h1 id="二、实际例子"><a href="#二、实际例子" class="headerlink" title="二、实际例子"></a>二、实际例子</h1><h2 id="2-1-两数值交换"><a href="#2-1-两数值交换" class="headerlink" title="2.1 两数值交换"></a>2.1 两数值交换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    Swap(&amp;i, &amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d, j = %d\n"</span>, i, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf;</span><br><span class="line">    buf = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = buf;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：i = 5, j = 3</p><p>&emsp;&emsp;此时实参向形参传递的不是变量 i 和 j 的数据，而是变量 i 和 j 的地址。其实传递指针也是拷贝传递，只不过它拷贝的不是内存单元中的内容，而是内存单元的地址，这就是天壤之别了。拷贝地址就可以直接对地址所指向的内存单元进行操作，即此时被调函数就可以直接对变量 i 和 j 进行操作了。有人会说：“被调函数用完就释放了，不就把 i 和 j 都释放了吗？”不是的，当函数调用完之后，释放的是 p 和 q，不是 i 和 j。p 和 q 中存放的是 i 和 j 的地址。所以 p 和 q 被释放之后并不会影响 i 和 j 中的值。前面讲过，修改指针变量的值不会影响所指向变量中的数据。只不过它们之间的指向关系没有了而已。 </p><p>此外需要注意的是，形参中变量名分别为 p 和 q，变量类型都是 int* 型。所以实参 i 和 j 的地址，即 &amp;i 和 &amp;j 是分别传递给 p 和 q，而不是传递给 *p 和 *q。</p><blockquote><p><strong>函数参数传指针和传数据的区别</strong></p></blockquote><p>&emsp;&emsp;综上所述，如果希望在另外一个函数中修改本函数中变量的值，那么在调用函数时只能传递该变量的地址。如果这个变量是普通变量，那么传递它的地址就可以直接操作该变量的内存空间。</p><p>&emsp;&emsp;那么，是不是要定义一个指针变量指向它然后传递这个指针变量呢？不用多此一举。比如有一个“int i；”，如果想传递i的地址那就直接传递 &amp;i 就行了，不用专门定义一个指针变量指向它，然后再传递这个指针变量。</p><p>如果要传递的变量本身就是一个指针变量怎么办？如果要操作该指针变量所指向的内存空间是不是要传递该指针变量的地址呢？</p><p>&emsp;&emsp;指针变量本身就是地址，本身就是指向那个内存空间的，所以直接把它传过去就行了。除非你要改变那个指针变量里面存放的地址，即你要改变指针变量的指向，那么你就必须要传递指针变量的地址。<br>指针可以使得函数返回一个或者一个以上的值</p><h2 id="2-2-数组中的n个元素的值分别减去20"><a href="#2-2-数组中的n个元素的值分别减去20" class="headerlink" title="2.2 数组中的n个元素的值分别减去20"></a>2.2 数组中的n个元素的值分别减去20</h2><blockquote><p>需求分析:编写函数,要求将数组中的n个元素的值分别减去20</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数前置声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">traverseArray</span><span class="params">(<span class="keyword">int</span> *pArr,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">subArray</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subArray1</span><span class="params">(<span class="keyword">int</span> * pArr,<span class="keyword">int</span> length )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">traverseArray</span><span class="params">(<span class="keyword">int</span> *pArr,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,*(pArr+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组中所有元素都减去20</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">subArray</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = a[i] - <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组中所有元素都减去20</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subArray1</span><span class="params">(<span class="keyword">int</span> * pArr,<span class="keyword">int</span> length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(pArr + i) = *( pArr + i) - <span class="number">20</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N]=&#123;<span class="number">51</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">58</span>,<span class="number">59</span>,<span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原来数组中的元素为:\n"</span>);</span><br><span class="line">    traverseArray(a,N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组中元素第一次减去20后为:\n"</span>);</span><br><span class="line">    subArray(a,N);</span><br><span class="line">    traverseArray(a,N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组中元素第二次减去20后为:\n"</span>);</span><br><span class="line">    subArray1(a,N);</span><br><span class="line">    traverseArray(a,N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：</p><ol><li>不允许拷贝数组；</li><li>使用数组时通常会将其转换成指针。</li></ol><p>&emsp;&emsp;因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。<br>因此数组会被转换成指针(数组退化现象)，所以当我们为<strong>函数传递一个数组时，实际上传递的是指向数组首元素的指针</strong>。</p><p>尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽管形式不同，但这三个printf函数是等价的</span></span><br><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span><span class="comment">//这里的维度表示我们期望数组含有多少元素，实际不一定</span></span></span><br></pre></td></tr></table></figure><p>当编译器处理对printf函数的调用时，只检查传入的参数是否是const int*类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">print(&amp;i);  <span class="comment">//正确，&amp;i的类型是int*</span></span><br><span class="line">print(j);   <span class="comment">//正确，j被转换成int*并指向j[0]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果我们传给printf函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。</p><h1 id="三、指针作为函数参数的好处"><a href="#三、指针作为函数参数的好处" class="headerlink" title="三、指针作为函数参数的好处"></a>三、指针作为函数参数的好处</h1><p>&emsp;&emsp;此外，传指针和传数据相比还有一个好处就是节约内存。我们知道，传数据拷贝的是内存单元的数据，如果数据很多的话拷贝过来都要为它们分配内存。而传指针的话只需要传递 4 字节的地址就行了。而且传数据非常消耗效率，为形参分配内存需要时间，拷贝需要时间，最后结束了返回还是需要时间。前面说过，return时系统会先自动创建一个临时变量来存放返回的值。所以传数据时很消耗效率，而传指针就是为了提高效率。</p><p>&emsp;&emsp;事实上，在实际编程中我们都是传递指针！</p><p>往往只有满足下面这两个条件的时候我们才会直接传递数据而不是传递指针，而且这两个条件缺一不可：</p><ol><li>数据很小，比如就一个 int 型变量。</li><li>不需要改变它的值，只是使用它的值。</li></ol><p>此时不是不能用指针，当然也可以用指针，只是没有必要。</p><p>&emsp;&emsp;以后在使用函数的时候，只要函数的参数不满足上面这两个条件，那么就用指针。此外需要注意的是，数组名本身就是地址，所以如果传递数组的话直接传递数组名就行了。接收的形参可以定义成数组(形式方面上而已)也可以定义为同类型的指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="函数" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数形参" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>指针&amp;数组&amp;字符串</title>
    <link href="http://shatang.github.io/2020/03/15/%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://shatang.github.io/2020/03/15/指针-数组-字符串/</id>
    <published>2020-03-15T02:53:44.000Z</published>
    <updated>2020-03-15T03:01:33.345Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><h1 id="一、指针-amp-数组-细品"><a href="#一、指针-amp-数组-细品" class="headerlink" title="一、指针 &amp; 数组(细品)"></a>一、指针 &amp; 数组(细品)</h1><p>&emsp;&emsp;指针就是指针，指针<strong>变量</strong>在32位系统下，永远占4字节，其值为某一个内存的地址。指针可以指向任何地方(内存)，但是不是任何地方你都能通过这个指针变量访问到呢？(有地址，无[权限]空间)</p><p>&emsp;&emsp;数组就是数组，其大小与元素的类型和个数有关；定义数组时，必须指定其元素的类型和个数；数组可以存任何类型的数据，但是不能存函数。</p><p>总结如下：</p><ul><li>指针本质上也是一个变量</li><li>指针要占用一定的内存空间（任何类型的指针的内存大小是一样的）</li><li>指针用于保存内存地址的值</li></ul><hr><blockquote><p>数组&amp;结构体</p></blockquote><ul><li><strong>数组</strong>：所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙</li><li><strong>结构体</strong>：在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。</li></ul><hr><h1 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h1><h2 id="2-1-数组的基础"><a href="#2-1-数组的基础" class="headerlink" title="2.1 数组的基础"></a>2.1 数组的基础</h2><ol><li>数组在一片连续的内存中存储元素</li><li>元素的个数可以是显示的也可以是隐式的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//其中,其他的元素都为0来填充</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-数组地址与数组名"><a href="#2-2-数组地址与数组名" class="headerlink" title="2.2 数组地址与数组名"></a>2.2 数组地址与数组名</h2><ol><li>数组名代表数组首元素的地址</li><li>数组的地址需要取地址才可以得到</li><li>数组首元素的地址值 与 数组的地址值 相同(注意是值)</li><li>数组首元素的地址 <code>&a[0]</code> 与数组的地址 <code>&a</code> 是两个不同的概念</li></ol><p>&emsp;&emsp;举例，湖南省的省政府在长沙，长沙的市政府也在长沙，两个政府都在长沙。</p><h2 id="2-3-数组名的盲点"><a href="#2-3-数组名的盲点" class="headerlink" title="2.3 数组名的盲点"></a>2.3 数组名的盲点</h2><p>&emsp;&emsp;数组名如何理解呢？用来存放数组的区域是一块在栈中静态分配的内存(非static)，而数组名是这块内存的代表，它被定义为这块内存的首地址。这就说明了数组名是一个地址，而且，还是一个不可修改的常量，完整地说，就是一个地址常量。</p><p>&emsp;&emsp;数组名跟枚举常量类似，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。注意了！不是数组名这个符号的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值，它就是这个地址，这就是数组名属于符号常量的意义所在。</p><p>&emsp;&emsp;由于数组名是一种符号常量，因此它是一个右值，而指针，作为变量，却是一个左值，一个右值永远都不会是左值，那么，数组名永远都不会是指针！</p><ol><li>数组名可以看作一个常量指针（指针所指向的内容不能改变）</li><li>既然是指向常量，那就不能作为表达式左值，因为左值能被修改</li><li>可以单独修改数组元素，但用数组名(实际上是符号常量)不能直接修改数组</li></ol><h2 id="2-4-指针-amp-数组-的定义与声明-经典错误"><a href="#2-4-指针-amp-数组-的定义与声明-经典错误" class="headerlink" title="2.4 指针 &amp; 数组 的定义与声明(经典错误)"></a>2.4 指针 &amp; 数组 的定义与声明(经典错误)</h2><h3 id="2-4-1-定义为指针，声明为数组"><a href="#2-4-1-定义为指针，声明为数组" class="headerlink" title="2.4.1 定义为指针，声明为数组"></a>2.4.1 定义为指针，声明为数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1 文件1</span></span><br><span class="line"><span class="keyword">char</span> * p=<span class="string">"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test2 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> p[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);<span class="comment">//printf("%s\n",*(unsigned int *)p);正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-定义为数组，声明为指针"><a href="#2-4-2-定义为数组，声明为指针" class="headerlink" title="2.4.2 定义为数组，声明为指针"></a>2.4.2 定义为数组，声明为指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1 文件1</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//test2 文件2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *a;</span><br></pre></td></tr></table></figure><h2 id="2-5-定义数组类型"><a href="#2-5-定义数组类型" class="headerlink" title="2.5 定义数组类型"></a>2.5 定义数组类型</h2><p>&emsp;&emsp;C语言中，可以通过typedef为数组类型重命名</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef type(name)[size];</span><br></pre></td></tr></table></figure><p>数组类型(重命名了一种一个数组类型）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef int(AINT5)[5];</span><br><span class="line">typedef float(AFLOAT10)[10];</span><br></pre></td></tr></table></figure><p>数组定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AINT5 i = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">AFLOAT10 f;</span><br></pre></td></tr></table></figure><h1 id="三、-字符串"><a href="#三、-字符串" class="headerlink" title="三、 字符串"></a>三、 字符串</h1><ul><li>从概念上讲，C语言中没有字符串数据类型</li><li>在C语言中使用字符数组来模拟字符串<ul><li>单引号<code>' '</code>括起来的一个字符代表整数</li><li>双引号<code>" "</code>括起来的字符(串)代表一个指针 </li></ul></li><li>字符串是以 <code>'\0'</code>结束的字符数组</li><li>字符串可以分配于栈空间，堆空间或者 字符常量区（不能被改变）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s1 = <span class="string">"Hello World"</span>；      <span class="comment">//在字符常量区,不可改变这个字符串中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">100</span>] = <span class="string">"Hello world"</span>;   <span class="comment">//在栈上，可修改(不能通过数组名！)</span></span><br></pre></td></tr></table></figure><h2 id="3-1-实-字符数组、-虚-字符串"><a href="#3-1-实-字符数组、-虚-字符串" class="headerlink" title="3.1 (实)字符数组、(虚)字符串"></a>3.1 (实)字符数组、(虚)字符串</h2><p>&emsp;&emsp;下面的代码合法吗？使用它有什么隐患？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;a;</span><br><span class="line">p[<span class="number">0</span>]= <span class="string">'I'</span>;</span><br><span class="line">答案与分析：</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在标准C中这是合法的，但是它的生存环境非常狭小；它定义一个大小为3的字符数组，初始化为“abc”；注意，它没有通常的字符串终止符’\0’，因此这个数组只是看起来像C语言中的字符串，实质上却不是。因此所有对字符串进行处理的函数，比如strcpy、printf等，都不能够被使用在这个假字符串上。</p><h2 id="3-2-字符串的长度"><a href="#3-2-字符串的长度" class="headerlink" title="3.2 字符串的长度"></a>3.2 字符串的长度</h2><ul><li>字符串的长度就是字符串说包含字符的个数</li><li>C语言中的字符串的长度值得是第一个<code>'\0'</code>字符串出现的字符个数</li><li>C语言中通过<code>'\0'</code>结束来确定字符串的长度</li></ul><p>以<code>strlen()</code>为例，<code>strlen()</code>为无符号类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个字符串的长度的时候</span></span><br><span class="line"><span class="comment">//正确用法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(a)&gt;=<span class="built_in">strlen</span>(b))</span><br><span class="line"><span class="comment">//错误用法</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(a)-<span class="built_in">strlen</span>(b)&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="3-3-不受限制的字符串函数"><a href="#3-3-不受限制的字符串函数" class="headerlink" title="3.3 不受限制的字符串函数"></a>3.3 不受限制的字符串函数</h2><p>&emsp;&emsp;不受限制的字符串函数是通过寻找字符串得结束符 <code>'\0'</code>来判断长度。</p><ul><li>字符串复制函数： <code>char* strcpy(char* dst,const char* src)</code></li><li>字符串连接： <code>char* strcat(char* dst,const char* src)</code></li><li>字符串比较函数：<code>int strcmp(const char* s1,const char* s2)</code></li></ul><p>注意事项</p><ul><li>不受限制的字符串函数都是以’\0’作为结束标记来进行的，因此输入参数必须包含’\0’</li><li>strcat和strcpy必须保证目标字符数组的剩余空间足以保存整个源字符串</li><li>strcmp以0值表示两个字符串相同<ul><li>第一个字符串大于第二个字符串的时候返回值大于0</li><li>第一个字符串小于第二个字符串的时候返回值小于0</li><li>strcmp不会修改参数值，但依然以’\0’作为结束符号</li></ul></li></ul><h2 id="3-4-长度受限制的字符串函数"><a href="#3-4-长度受限制的字符串函数" class="headerlink" title="3.4 长度受限制的字符串函数"></a>3.4 长度受限制的字符串函数</h2><p>&emsp;&emsp;长度受限的字符串函数接收一个显示的长度参数用于限定操作的字符串。</p><ul><li>字符串复制:<code>char* strncpy</code></li><li>字符串连接:<code>char* strncat</code></li><li>字符串比较:<code>char* strncmp</code></li></ul><h1 id="四、数组参数和指针参数-针对函数传入"><a href="#四、数组参数和指针参数-针对函数传入" class="headerlink" title="四、数组参数和指针参数(针对函数传入)"></a>四、数组参数和指针参数(针对函数传入)</h1><p>&emsp;&emsp;数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：</p><ul><li>不允许拷贝数组</li><li>使用数组时通常会将其转换成指针</li></ul><p>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。</p><p>因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。(数组参数退化为指针)</p><p>尽管不能以值传递的形式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽管形式不同，但这三个进行print函数是等价的</span></span><br><span class="line"><span class="comment">//每个函数都有一个const int*类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span><span class="comment">//这里的维度表示我们期望数组含有多少元素，实际不一定</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//第三种容易被误会，且容易造成数组越界:</span></span></span><br><span class="line"><span class="function"><span class="comment">//实际元素不确定，但是函数操作(传入数组较短)以10个操作，越界</span></span></span><br></pre></td></tr></table></figure><p>当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">print(&amp;i);  <span class="comment">//正确，&amp;i的类型是int*</span></span><br><span class="line">print(j);   <span class="comment">//正确，j被转换成int*并指向j[0]</span></span><br></pre></td></tr></table></figure><p>如果我们传给printf函数的是一个数组，则实参自动地转换成指向首元素的指针，数组的大小对函数的调用没有影响。</p><h1 id="五、二维数组"><a href="#五、二维数组" class="headerlink" title="五、二维数组"></a>五、二维数组</h1><h2 id="5-1-二维数组参数和指针参数"><a href="#5-1-二维数组参数和指针参数" class="headerlink" title="5.1 二维数组参数和指针参数"></a>5.1 二维数组参数和指针参数</h2><p>&emsp;&emsp;C语言的编译器会让（不论是一维数组还是二维数组）数组参数退化为指针。C语言中无法向一个函数传递任意的多维数组。</p><ul><li>二维数组参数同样存在退化问题。<ul><li>二维数组可以看作是一维数组</li><li>二维数组中的每一个元素是一维数组</li></ul></li><li>二维数组参数中第一维的参数可以省略（退化过程） </li></ul><p>注意事项</p><ul><li>C语言中无法向一个函数传递任意的多维数组</li><li>为了提供正确的指针运算，必须提供除一维之外的所有维的长度(程序写法)<br>限制<ul><li>一维数组-必须提供结束的标志</li><li>二维数组-不能直接传递给函数</li><li>多维-无法使用</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>],<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col=<span class="keyword">sizeof</span>(*a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">//去推导出列的数量</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    access(a,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-二维数组与数组指针"><a href="#5-2-二维数组与数组指针" class="headerlink" title="5.2 二维数组与数组指针"></a>5.2 二维数组与数组指针</h2><ul><li>二维数组在内存中以一维的方式排布</li><li>二维数组中的第一维是一维数组</li><li>二维数组中的第二维才是具体的值</li><li>二维数组的数组名同样可以看作常量指针</li><li>二维数组同样代表数组首元素的地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> (*p) [<span class="number">4</span>];</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;p[<span class="number">4</span>][<span class="number">2</span>]-&amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案为-4，因为（*p）一次跨越4个，而a一次跨越5个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用指针遍历二维数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j; </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;&#123;&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            *(*(a+i)+j)=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,*(*(a+i)+j));     </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、指向指针的指针"><a href="#六、指向指针的指针" class="headerlink" title="六、指向指针的指针"></a>六、指向指针的指针</h1><p>为什么需要指向指针的指针？</p><ul><li>指针在本质上也是一个变量</li><li>对于指针来讲也有传值调用与传址调用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重置动态空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rest</span><span class="params">(<span class="keyword">char</span>** p,<span class="keyword">int</span> size,<span class="keyword">int</span> new_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* mid=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>* pt=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>* pp=*p;</span><br><span class="line">    <span class="keyword">if</span>((p!=<span class="literal">NULL</span>)&amp;&amp;(new_size&gt;<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">3</span>);</span><br><span class="line">        pt=mid;</span><br><span class="line">        len=(size&lt;new_size)?size:new_size;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *pt++=*pp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(*p);</span><br><span class="line">        *p=pt;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ret=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0X\n"</span>,p);</span><br><span class="line">    <span class="keyword">if</span>(rest(&amp;p,<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0X\n"</span>,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="数组" scheme="http://shatang.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="字符串" scheme="http://shatang.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>在嵌入式中的各种指针用法和概念</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95%E5%92%8C%E6%A6%82%E5%BF%B5/"/>
    <id>http://shatang.github.io/2020/03/15/在嵌入式中的各种指针用法和概念/</id>
    <published>2020-03-15T02:48:54.000Z</published>
    <updated>2020-03-15T02:50:30.093Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器= =</p><a id="more"></a><p><strong><font color="red">Ps：</font></strong>以下所有指针的概念的理解思路可以从字义层面上，从右到左进行理解。</p><hr><ul><li>指针数组    ：    int    *p1[10];</li><li>数组指针    ：    int    (*p2)[10];<ul><li>对应概念<ul><li>指针数组：一个存放多个指针的数组</li><li>数组指针：一个指向数组的指针(首地址)</li></ul></li><li>对应用法<ul><li>指针数组：一般是存放多个指针分别指向各个不同的字符串，不同的指针可组合起来一段话。</li><li>数组指针：一般是作为函数的数组形参，打印字符串可以只修改指向的字符串地址。</li></ul></li></ul></li><li>结构体指针    ：Student *p2;</li><li>结构体数组指针 ：Student (*p2)[10];</li><li>结构体成员是指针：<ul><li>对应概念<ul><li>结构体指针：跟数组指针差不多</li><li>结构体数组指针：跟指针数组差不多，存放多个结构体指针</li><li>结构体成员是指针：跟普通数组差不多，但只是部分成员(元素)是指针</li></ul></li><li>对应用法<ul><li>结构体指针：普遍常用</li><li>结构体数组指针：普遍常用，可对应不同驱动的通道号(例如两路硬件选择)</li><li>结构体成员是指针：很常见，不过<strong>要注意初始化赋值</strong></li></ul></li></ul></li></ul><hr><ul><li>指针函数：    int    *p3(int，int);</li><li>函数指针：    <ul><li>int (*p4)(int，int);</li><li>char *(*pf)(char * p);</li></ul></li><li>传递指针：    int    p5(int*，int*)<ul><li>对应概念<ul><li>指针函数：一个返回值是 指针变量 的函数</li><li>函数指针：一个指向函数的指针</li><li>传递指针：函数形参是指针</li></ul></li><li>对应用法<ul><li>指针函数：不常用，有风险。不能返回局部变量指针，全局指针变量还需要返回吗？</li><li>函数指针：相当于留出自定义函数接口，常用于回调函数 或 程序适应(选择)不同(硬件)版本的驱动(函数)</li><li>传递指针：很常用，传入实参需要修改值时，就传入实参指针(数组退化被迫传入指针)</li></ul></li></ul></li></ul><p><strong><font color="red">Ps：</font></strong></p><ul><li>函数声明时，可以省略形参名，不能省略形参类型；</li><li>函数定义（写函数体）时，则都不能省略。</li><li>函数内部修改外部变量的值，需要一级指针；(函数形参)</li><li>函数内部修改外部指针变量的值，需要二级指针。</li><li>函数的实参和形参之间的传递是单向的，只能由实参向形参传递(拷贝传递)。被调函数调用完之后系统为其分配的内存单元都会被释放。<strong>我们在对常量，或者是指针进行操作的时候，实质上是对其对应的内存进行操作</strong></li></ul><hr><ul><li>函数指针数组：        <ul><li>int   (*p5[3])(int );</li><li>char *(*pf[3])(char *p);</li></ul></li><li>函数指针数组指针：    char *(*(*pf[3])(char *p);<ul><li>对应概念<ul><li>函数指针数组：一个数组中，所有元素都是指针，且一个指针对应指向一个函数</li><li>函数指针数组指针：一个指针，指向一个数组，这个数组中，所有元素都是指针，一个指针对应指向一个函数 </li></ul></li><li>对应用法<ul><li>函数指针数组：一个数组存放多个不同版本的驱动、算法(函数)</li><li>上面那个已经很极限了；这个真太花里胡哨，用不来，用的来也估计是埋坑给后面的</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器= =&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="指针" scheme="http://shatang.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="数组" scheme="http://shatang.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>自动转换&amp;强制转换</title>
    <link href="http://shatang.github.io/2020/03/15/%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://shatang.github.io/2020/03/15/自动转换-强制转换/</id>
    <published>2020-03-15T02:45:07.000Z</published>
    <updated>2020-03-15T02:49:15.307Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器</p><a id="more"></a><h1 id="一、类型转换的来源"><a href="#一、类型转换的来源" class="headerlink" title="一、类型转换的来源"></a>一、类型转换的来源</h1><p>&emsp;&emsp;计算机硬件进行算术操作时，要求各操作数的类型具有相同的大小（存储位数）及存储方式。例如，由于各操作数大小不同，硬件不能将 char 型（ 1 字节）数据与 int 型（ 2 或 4 字节）数据直接参与运算；由于存储方式的不同，也不能将 int 型数据与 float 型数据直接参与运算。</p><p>&emsp;&emsp;然而，由于 C 语言编程的灵活性，在一个表达式或一条语句中，允许不同类型的数据混合运算。</p><p>&emsp;&emsp;C 语言的灵活性与计算机硬件的机械性是一对矛盾，如处理不好，将会产生错误结果。对于某些类型的转换编译器可隐式地自动进行，不需人工干预，称这种转换为<strong>自动类型转换</strong>；而有些类型转换需要编程者显式指定，通常，把这种类型转换称为<strong>强制类型转换</strong>。</p><h1 id="二、自动类型转换-隐式"><a href="#二、自动类型转换-隐式" class="headerlink" title="二、自动类型转换(隐式)"></a>二、自动类型转换(隐式)</h1><p>&emsp;&emsp;不同数据类型之间的差别在于数据的表示范围及精度上，一般情况下，数据的表示范围越大、精度越高，其类型也越“高级”。</p><ul><li>常见类型级别从低到高依次为：<br>char -&gt; short -&gt; int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; double </li><li>浮点型级别从低到高依次为：<br>float -&gt; double</li></ul><p>不同类型间的混合运算，较低类型将自动向较高类型转换。(精度提高不影响结果)</p><p><strong>注意事项：(以下操作可能会截取精度)</strong></p><ul><li>赋值表达式中，表达式的值 (自动)转换为 左值(变量)的类型</li><li>函数调用时，实参(自动)转化为形式参数的类型</li><li>函数返回值，<code>return 表达式</code> (自动)转化为返回值的类型</li></ul><hr><p>举例如下：</p><ol><li>赋值运算符，两恻的类型不一致</li></ol><p>&emsp;&emsp;当赋值运算符的右值（可能为常量、变量或表达式）类型与左值类型不一致时，将右值类型可能提升或降低为左值类型。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">d=<span class="number">5.1f</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于左值为双精度浮点型，故先把右值单精度浮点型常量 5.1 提升为双精度浮点型后，再赋值给 d，不但不丢失精度反而提高了精度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=<span class="number">5.1</span>; <span class="comment">//右值5.1为双精度，左值为整型</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;右值双精度浮点型 5.1 降低为左值整型，即 5.1 舍弃小数部分后，把 5 赋给整型变量 i，这种情况会丢失精度。</p><hr><ol start="2"><li>赋值运算符，右值超出左值类型范围</li></ol><p>&emsp;&emsp;更糟糕的情况是，赋值运算符右值的范围超出了左值类型的表示范围，将把该右值截断后，赋给左值。所得结果可能毫无意义。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c; <span class="comment">//char 占8位，表示范围-127〜128</span></span><br><span class="line">c=<span class="number">1025</span>; <span class="comment">//1025 对应二进制形式：100 0000 0001，超出了8位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"％d"</span>,c) ; <span class="comment">//以十进制输出c的值</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该输出结果为 1，因为只取 1025 低 8 位 0000 0001（值为1），赋给字符型变量 c，故得到毫无意义的值。</p><hr><h1 id="三、强制类型转换"><a href="#三、强制类型转换" class="headerlink" title="三、强制类型转换"></a>三、强制类型转换</h1><p>&emsp;&emsp;为了给程序设计人员提供更多的类型转换控制权限，使程序设计更加灵活，转换的目的更加清晰，C 语言提供了可显式指定类型转换的语法支持，通常称之为强制类型转换。</p><ul><li>强制类型转换常见的用法:<ul><li>(1)数据的 高类型一般不会强制转换成低类型，因为可能会丢失一部分数据；</li><li>(2)一般是低类型强制转换成高类型，防止数据溢出；</li><li>(3)提高函数指针的适用性</li></ul></li><li>原因如下：<ul><li>(1)高类型转低类型，往往是函数传参，让函数处理更加明确范围；</li><li>(2)低类型转高类型，防止数据溢出；</li><li>(3)强制转换函数指针能够让回调方式更加多样性。</li></ul></li></ul><p>也许有人会问，那一开始都为高类型就不需要强制转换了吗？</p><p>&emsp;&emsp;很简单，能低类型处理能够更好体现对应函数的功能性。当需要调用该变量，再强制转换获取到的数值，防止数据溢出。这种灵活性，还能实现<strong>节省内存</strong>。</p><blockquote><p>举例——强制地址跳转</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> jump(TargetAddr)   (*((void(*)())(TargetAddr)))()</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一个<code>(( void( * )(  ))</code> ，意思为强制类型转换为一个无形参，无返回值的函数指针，<code>(*(TargetAddr))</code>为跳转地址，但是函数指针变量不能为常数所以要加<code>((void( * )(  ))</code> 进行强制类型转换。最后一个<code>()</code>为执行的意思。</p><p>整个宏定义目的是为了跳转到一个绝对地址执行函数。用处如下：</p><ol><li>在单片机中可以实现软件复位，比如跳转到0地址。</li><li>如果程序是由多个程序合并的（bootloader跳转），跳转到某一个确定的用户程序地址执行。</li><li>如果flash空间足够大的话，甚至还可以实现当多份不相同的代码合并为一份后，在软件上做逻辑跳转，好处是新程序不必为旧程序做大量的兼容工作，通常旧程序含有大量的前人的(坏)编程习惯。可以选择执行想要的版本软件程序。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="强制转换" scheme="http://shatang.github.io/tags/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="自动转换" scheme="http://shatang.github.io/tags/%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>关键字&amp;符号&amp;预处理&amp;函数</title>
    <link href="http://shatang.github.io/2020/03/15/%E5%85%B3%E9%94%AE%E5%AD%97-%E7%AC%A6%E5%8F%B7-%E9%A2%84%E5%A4%84%E7%90%86-%E5%87%BD%E6%95%B0/"/>
    <id>http://shatang.github.io/2020/03/15/关键字-符号-预处理-函数/</id>
    <published>2020-03-15T02:23:03.000Z</published>
    <updated>2020-03-15T08:10:55.402Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;无情的搬砖机器</p><a id="more"></a><h1 id="一、关键字"><a href="#一、关键字" class="headerlink" title="一、关键字"></a>一、关键字</h1><h2 id="1-1-struct"><a href="#1-1-struct" class="headerlink" title="1.1 struct"></a>1.1 struct</h2><p>&emsp;&emsp;该关键字看另外博客：<a href="https://shatang.github.io/2020/03/15/30-%E7%BB%93%E6%9E%84%E4%BD%93/#more">结构体</a></p><h2 id="1-2-union"><a href="#1-2-union" class="headerlink" title="1.2 union"></a>1.2 union</h2><p>&emsp;&emsp;该关键字看另外博客：<a href="https://shatang.github.io/2020/03/15/31-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/#more">大小端和联合体</a></p><h2 id="1-3-switch"><a href="#1-3-switch" class="headerlink" title="1.3 switch"></a>1.3 switch</h2><p>switch注意事项:</p><ol><li>case语句中的值只能是整型或字符型的常量或常量表达式（想想字符型数据在内存里是怎么存的）</li><li>default语句只能用于处理真正的默认情况 </li><li>每个case语句分支必须有break，否则分支重叠</li></ol><p><strong><font color="red">Ps：</font></strong>switch可用于<strong>冗长的程序逻辑进程</strong>，每一个case代表一个进程，只有其中进程执行完，才对switch(Temp)判断的值进行改动(例如：Temp++);然后进行下一个流程，方便梳理逻辑。</p><h2 id="1-4-enum"><a href="#1-4-enum" class="headerlink" title="1.4 enum"></a>1.4 enum</h2><p>&emsp;&emsp;相比 <code>#define</code> 标识符常量必须由程序员手工赋值。<code>enum</code> 使程序更容易维护，因为枚举常量是由编译程序自动生成的。</p><p><strong><font color="red">Ps：</font></strong>可搭配<code>switch</code>作为<code>case</code>值方便扩展</p><h2 id="1-5-static-amp-extern"><a href="#1-5-static-amp-extern" class="headerlink" title="1.5 static &amp; extern"></a>1.5 static &amp; extern</h2><h3 id="1-5-1-static"><a href="#1-5-1-static" class="headerlink" title="1.5.1 static"></a>1.5.1 static</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> Shatang;</span><br></pre></td></tr></table></figure><p>常见用法：屏蔽其他源文件对本源文件static修饰的变量</p><ol><li>修饰局部变量：用来延长变量生命周期，<strong>防止再次调用函数时需要再初始化修饰的变量，保留原有数据(常见用法)</strong></li><li>修饰全局变量：用static对全局变量进行修饰改变了其作用域的范围，防止其他源文件对本源文件的变量调用</li></ol><ul><li><code>static 全局变量</code>：、<ul><li>static全局变量只初始化一次，防止在其他文件单元中被引用；</li><li>只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</li></ul></li><li><code>static 局部变量</code>：<ul><li>static局部变量只被初始化一次，下一次依据上一次结果值；</li><li>限制了它的使用范围</li></ul></li><li><code>static 函数</code>：<ul><li>static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为(static)内部函数，内部函数应该在当前源文件中说明和定义。</li><li>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</li></ul></li></ul><p><strong><font color="red">Ps：</font></strong>指针是变量</p><p><strong>总结</strong>：从上面用法描述来看，static不会在 .h文件修饰变量(.c文件都调用不了你，要你何用)，正常情况下都会在 .c文件修饰变量、函数定义(声明往往在.h文件），防止其他 .c文件调用；</p><h3 id="1-5-2-extern"><a href="#1-5-2-extern" class="headerlink" title="1.5.2 extern"></a>1.5.2 extern</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">uint32_t</span> Shatang;</span><br></pre></td></tr></table></figure><p>常见用法：用在变量或者函数的声明前，用来说明“此变量/函数”是在别处定义的，要在此处引用。</p><ul><li><p><strong>问题描述：</strong>因为要使用CAN进行数据传输，因此在主程序”test.c”中采用#include “can.h”，调用”can.h”中的函数和变量。结果编译后出现许多  <code>Error L6200E: symbol xxx multiply defined  ...</code></p></li><li><p><strong>原因：</strong>因为在 <code>"can.h"</code> 中<strong>定义</strong>（不仅声明还进行定义）了许多变量，<code>"can.c"</code>文件中采用 <code>#include "can.h"</code>，调用<code>"can.h"</code>中的变量定义；在主函数<code>"test.c"</code>中也采用 <code>#include "can.h"</code>，调用<code>"can.h"</code>中的变量定义，导致”can.h”中的变量被<strong>重复定义</strong>。</p></li><li><p><strong>解决方法：</strong>首先，<strong>不应该在”can.h”中定义”can.c”中使用的变量</strong>（正常情况都是这样），而是在”can.c”中定义所需的变量。在”can.h”中把变量先进行 <code>extern uint8_t Shatang;</code> 声明，然后 在”can.c”文件再进行定义；此时，主程序”test.c”中将所调用”can.h”中的变量（声明） 将会去”can.c”查找其定义，因此不会存在变量重复定义，问题得到解决。</p></li><li><p>结论：extern往往用于 .h文件变量声明，然后在相应的 .c文件进行定义，这样防止 <strong>.h文件被多个 .c文件调用时产生重复定义的错误</strong></p></li></ul><p>特殊案例：往往图片、字库是按照 .h文件变量定义的，没有.c文件；当你的（lcd.c）文件功能需要调用 某些图片数组.h文件，不能在自身（lcd.h）文件调用 image.h文件，当其他 .c文件调用<code>lcd.h</code> 文件,就会产生上面同样的重复定义；<em>因此对于(只有) .h文件进行变量定义，往往采用直接在（<strong>只能在单个</strong>） lcd.c 文件调用</em></p><h3 id="1-5-3-static-和-extern-的关系"><a href="#1-5-3-static-和-extern-的关系" class="headerlink" title="1.5.3 static 和 extern 的关系"></a>1.5.3 static 和 extern 的关系</h3><p>&emsp;&emsp;<strong><code>static</code>表示是本文件内的变量（在函数中的是静态变量），<code>extern</code>表示是其他文件定义的变量，显然两者是矛盾的</strong>；只有全局变量并且没有被static声明的变量才能声明为extern。</p><h2 id="1-6-const-amp-指针"><a href="#1-6-const-amp-指针" class="headerlink" title="1.6 const &amp; 指针"></a>1.6 const &amp; 指针</h2><p>常见用法：const 修饰变量为<strong>只读变量</strong>(不是常量！！！)。</p><ul><li>为了防止传递的函数参数不被修改，在调用函数的形参中用const关键字</li><li>const可以用来创建数组常量、指针常量、指向常量的指针等</li></ul><p>如何辨别const是修饰什么？方法：无括号的情况下，可以先忽略类型名。</p><p><code>const <del>int</del> *p; //const修饰*p，p是指针，*p是指针指向的对象，不可变</code><br><code><del>int</del> const *p; //const修饰*p，p是指针，*p是指针指向的对象，不可变</code><br><code><del>int</del> *const p; //const修饰p，p不可变，p指向的对象可变</code><br><code>const <del>int</del> *const p;    //前一个const修饰*p，后一个const修饰p，指针p和p指向的对象都不可变</code></p><p>&emsp;&emsp;这里或许就有人要问：<code>const int *const p;</code>这种都不可变的有什么用？只不过是教语法时用到的花里胡哨。<br>诚然，指针p和p指向的对象都不可变，但是p指向的对象还可以是个指针啊！因此    <code>const int *const p;</code>往往是用于二级指针。思路反过来，当别人代码这样写的时候：你就应该明白，这里是二级指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="keyword">const</span> (<span class="keyword">int</span>*)p;</span><br><span class="line">* <span class="keyword">const</span> <span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上的三种情况是等效的。对于<code>const (int *)</code>，因为<code>int *</code>是一个整体，相当于一个类型(如 <code>char</code>)，因此，这个<code>const</code>是限定指针不可变。</p><p><strong><font color="red">Ps：</font></strong>只读变量 和 常量 是有区别的，内存存放区域都不同。详情看内存分配一章。</p><h2 id="1-7-void"><a href="#1-7-void" class="headerlink" title="1.7 void"></a>1.7 void</h2><p>void 常与 (函数)指针 搭配使用：</p><ol><li>C语言规定只有相同类型的指针才可以相互赋值</li><li>void*指针作为左值用于“接收”任意类型的指针</li><li>void指针作为右值赋值给其他指针时需要强制类型转换</li></ol><h2 id="1-8-volatile"><a href="#1-8-volatile" class="headerlink" title="1.8 volatile"></a>1.8 volatile</h2><p>volatile用于告诉编译器必须每次去内存中取变量值：</p><ol><li>volatile主要修饰可能被多个线程访问的变量</li><li>volatile也可以修饰可能被(硬件)未知因数更改的变量</li></ol><p><strong><font color="red">Ps：</font></strong>volatile往往只用于最底层驱动(防止数值被修改，例如通信协议)；最好不要用于封装其他高级应用层的代码，用处不大，而且不利于其他人对你的程序进行移植拓展(极端情况下可能取值问题出错)。</p><p>举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*ptr)*(*ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于*ptr 的值可能被意想不到地该变，这段代码可能返不是你所期望的平方值！</p><h2 id="1-9-sizeof"><a href="#1-9-sizeof" class="headerlink" title="1.9 sizeof"></a>1.9 sizeof</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>) <span class="comment">//计算(int类型)内存大小</span></span><br></pre></td></tr></table></figure><p>常见用法：计算内存大小。<br>在嵌入式c代码中，用于计算数组等大小；它往往会和 struct、#define、#pragma pack 连用，用来计算结构体的偏移量，方便调用结构体成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">块注释：打印参数列表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> ulPrintAuto;<span class="comment">// 0自动打印开关</span></span><br><span class="line"><span class="keyword">uint32_t</span> ulPrintFormat;<span class="comment">// 1打印格式</span></span><br><span class="line"><span class="keyword">uint32_t</span> ulPrintLang;<span class="comment">// 2打印语言</span></span><br><span class="line"><span class="keyword">uint32_t</span> ulPrintRow;<span class="comment">// 3打印走纸行数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> ulPrintAcc;<span class="comment">// 4打印总累计数据</span></span><br><span class="line"><span class="keyword">uint32_t</span> ulPrintRecipeSetting;<span class="comment">// 5打印配方设置表</span></span><br><span class="line"><span class="keyword">uint32_t</span> ulPrintRecipeAcc;<span class="comment">// 6打印配方累计表</span></span><br><span class="line"></span><br><span class="line">&#125;_strPrintParam;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">块注释：获取打印参数结构体成员的偏移量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PRINTF_PARAM_OFFSET(member) (((uint32_t)(&amp;(((_strPrintParam *)0)-&gt;member))) / sizeof(uint32_t))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">块注释：获取打印参数数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_PARAM_NUM(sizeof(_strPrintParam)/sizeof(uint32_t))</span></span><br></pre></td></tr></table></figure><ul><li><code>PRINT_PARAM_NUM</code> 可用于实现结构体成员的(for循环)赋值；</li><li><code>GET_PRINTF_PARAM_OFFSET(member)</code> 计算出来的结构体偏移量可方便 结构体扩展</li></ul><h2 id="1-10-typedef"><a href="#1-10-typedef" class="headerlink" title="1.10 typedef"></a>1.10 typedef</h2><p>&emsp;&emsp;typedef用于给一个已经存在的数据类型重命名。</p><p>下边是一个能够说明typedef的语法例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// the following two objects have the same type</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> l1;</span><br><span class="line">ulong l2;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// more complicated typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">int_t</span>, *<span class="keyword">intp_t</span>, (&amp;fp)(<span class="keyword">int</span>, ulong), <span class="keyword">arr_t</span>[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// the following two objects have the same type</span></span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">arr_t</span> a2;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// common C idiom to avoid having to write "struct S"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> a; <span class="keyword">int</span> b;&#125; S, *pS;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// the following two objects have the same type</span></span><br><span class="line">pS ps1;</span><br><span class="line">S* ps2;</span><br></pre></td></tr></table></figure><ol><li><p>typedef 定义结构体类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> iNum;</span><br><span class="line">    <span class="keyword">long</span> lLength;</span><br><span class="line">&#125;MyStruct;</span><br><span class="line">MyStruct stu1;</span><br><span class="line">MyStruct *stu1;</span><br><span class="line">MyStruct <span class="class"><span class="keyword">class</span>[50];</span></span><br></pre></td></tr></table></figure></li><li><p>typedef 定义数组类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int(AINT5)[5];</span><br><span class="line">typedef float(AFLOAT10)[10];</span><br><span class="line">typedef char(ACHAR9)[9];</span><br><span class="line"></span><br><span class="line">AINT5 a1;</span><br><span class="line">AFLOAT10* pf = &amp;fArray;</span><br><span class="line">ACHAR9 cArray;</span><br><span class="line">AINT5 i = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>typedef 定义(常见)指针类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstr;</span><br><span class="line"></span><br><span class="line">pstr p;</span><br></pre></td></tr></table></figure></li><li><p>typedef 定义函数指针类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pFunc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFunc func;</span><br><span class="line">    unc = &amp;myFunc;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong><font color="red">进阶：</font></strong>typedef 定义函数指针类型后，可以再用 该函数指针类型 定义 数组/结构体成员，让 每个元素 或 结构体成员 为函数指针。</p><p>综合例程，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> arr[<span class="number">2</span>][<span class="number">5</span>];     <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *name[<span class="number">5</span>];      <span class="comment">// 指针数组 </span></span><br><span class="line">typedef char (*lan)[5];     // 数组指针 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr age;</span><br><span class="line">    name named;</span><br><span class="line">    lan land;</span><br><span class="line">    <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">char</span> j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            age[i][j]=i*j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        named[i]=age[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    land=&amp;age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"aged[%d][%d]=%d named[%d][%d]=%d land[%d][%d]=%d\n"</span>,i,j,age[i][j],i,j,named[i][j],i,j,land[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-11-enum-amp-const-amp-typedef-amp-define"><a href="#1-11-enum-amp-const-amp-typedef-amp-define" class="headerlink" title="1.11 enum &amp; const &amp; typedef &amp; #define"></a>1.11 enum &amp; const &amp; typedef &amp; #define</h2><ul><li><code>#define</code>：标识符<strong>常量</strong>必须由程序员手工赋值 </li><li><code>enum</code>：枚举常量是由编译程序自动生成的，使程序更容易维护<ul><li>这两个都是可以用来定义常量</li></ul></li><li><code>const</code>：修饰 <strong>只读变量</strong>，不会变的变量。从内存分配区上来看，就已经不一样了。</li><li><code> typedef</code>：跟<code>#define</code>极其相似，但实际有很大区别</li></ul><hr><blockquote><p>举例区分<code>typedef</code> &amp; <code>#define</code></p></blockquote><p>例子1. 以下p1,p2,p3,p4有什么区别？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一段</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* PCHAR;</span><br><span class="line">PCHAR p1,p2;</span><br><span class="line"><span class="comment">//第二段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCHAR char*</span></span><br><span class="line">PCHAR p3,p4;</span><br></pre></td></tr></table></figure><p>答案：p4是一个char类型</p><p>例子2. 以下是 指针为只读变量 还是 指针指向的内容不可变？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstr;</span><br><span class="line"><span class="keyword">const</span> pstr p;</span><br></pre></td></tr></table></figure><p>答案： const pstr p;&lt;==&gt; char* const p;</p><p>&emsp;&emsp;<strong>错误的原因在于将 typedef 当做文本扩展了</strong>(#define 才是真正的文本扩展！)。声明 const pstring 时，const修饰的是pstring的类型，这是一个指针。因此，该声明语句应该是把cstr定义为指向string 类型对象的const指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pstr p;</span><br><span class="line"><span class="keyword">const</span> (<span class="keyword">char</span>*) p;</span><br><span class="line">* <span class="keyword">const</span> <span class="keyword">char</span> p;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上的四种情况是等效的。</p><hr><h1 id="二、符号"><a href="#二、符号" class="headerlink" title="二、符号"></a>二、符号</h1><h2 id="2-1-单引号、双引号"><a href="#2-1-单引号、双引号" class="headerlink" title="2.1 单引号、双引号"></a>2.1 单引号、双引号</h2><ul><li>单引号引起来的都是字符常量</li><li>双引号引起来的都是字符串常量</li></ul><p>举例：1 ，’1’ , “1”</p><p>第1个是整数常量，32位系统下占4字节；<br>第2个是字符常量，占1字节；<br>第3个是字符串常量，占2字节。</p><p>&emsp;&emsp;字符在内存里是以 ASCII码 存储的，所以字符常量还可以与整形常量或变量进行运算，如：<code>'A' + 1</code> 。</p><h2 id="2-2-逻辑运算符使用分析"><a href="#2-2-逻辑运算符使用分析" class="headerlink" title="2.2 逻辑运算符使用分析"></a>2.2 逻辑运算符使用分析</h2><p>案例分析:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(++i&gt;<span class="number">0</span> || ++j&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为1，0。</p><h2 id="2-3-逻辑运算符-amp-按位运算符"><a href="#2-3-逻辑运算符-amp-按位运算符" class="headerlink" title="2.3 逻辑运算符 &amp; 按位运算符"></a>2.3 逻辑运算符 &amp; 按位运算符</h2><p>&emsp;&emsp;举例：以下例子函数的<code>DATAx</code>为宏定义stm32各个IO管脚，封装函数实现8pin并口数据输出；以下函数均能在C编译器编译通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DATA_Process</span><span class="params">(uchar com)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DATA0=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA1=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA2=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA3=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA4=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">4</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA5=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">5</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA6=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">6</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA7=((com &amp;(<span class="number">1</span>&lt;&lt;<span class="number">7</span>))==<span class="number">1</span>)    ? <span class="number">1</span> : <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//correct</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DATA_Process</span><span class="params">(<span class="keyword">uint8_t</span> com)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DATA0=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">0</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA1=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">1</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA2=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">2</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA3=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">3</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA4=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">4</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA5=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">5</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA6=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">6</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">    DATA7=(com &amp;(<span class="number">0x01</span>&lt;&lt;<span class="number">7</span>))    ? <span class="number">1</span> : <span class="number">0</span> ;  </span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>当调用该函数时，错误案例是无法实现相应的输出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA_Process(<span class="number">0xff</span>);</span><br></pre></td></tr></table></figure><p>提示：因为是 按位&amp; ，所以得出来的值 并非 1 或0 ；只有 &amp;&amp; 条件判断 才是得出来的值 1或0。</p><h2 id="2-4-优先级"><a href="#2-4-优先级" class="headerlink" title="2.4 优先级"></a>2.4 优先级</h2><img src="/2020/03/15/关键字-符号-预处理-函数/1.png"><h1 id="三、预处理"><a href="#三、预处理" class="headerlink" title="三、预处理"></a>三、预处理</h1><p>&emsp;&emsp;预处理是在编译环节中最早开始执行的，并且后面的代码(因条件变化)都不会影响到任何预处理的一些操作(例如：#define)</p><h2 id="3-1-宏定义"><a href="#3-1-宏定义" class="headerlink" title="3.1 宏定义"></a>3.1 宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>       <span class="comment">//定义一个预处理宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>        <span class="comment">//取消宏的定义</span></span></span><br></pre></td></tr></table></figure><hr><p>举例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SREG   (*(volatile unsigned char*)0x5F)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;嵌入式系统编程，要求程序员能够利用C语言访问固定的内存地址。</p><ul><li>既然是个地址，那么按照C语言的语法规则，这个表示地址的量应该是指针类型。<ul><li>所以，知道要访问的内存地址后，比如0x5F，第一步是要把它强制转换为指针类型<code>(unsigned char*)0x5F</code>，AVR的SREG是八位寄存器，所以0x5F强制转换为指向<code>unsigned char</code>类型。</li><li>volatile（可变的）这个关键字说明这变量可能会被意想不到地改变，这样编译器就不会去假设这个变量的值了。这种“意想不到地改变”，不是由程序去改变，而是由硬件去改变——意想不到。</li></ul></li><li>第二步，对指针变量解引用，就能操作指针所指向的地址的内容了<code>*(volatile unsigned char*)0x5F</code></li><li>第三步，小心地把#define宏中的参数用括号括起来，这是一个很好的习惯，所以<ul><li><code>#define SREG    (<em>(volatile unsigned char</em>)0x5F)</code></li></ul></li></ul><p>类似的，如果使用一个32位处理器，要对一个32位的内存地址进行访问，可以这样定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAM_ADDR    (*(volatile unsigned long *)0x0000555F)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就可以用C语言对这个内存地址进行读写操作了.</p><p>读：tmp = RAM_ADDR；<br>写：RAM_ADDR = 0x55；</p><hr><h2 id="3-2-条件编译"><a href="#3-2-条件编译" class="headerlink" title="3.2 条件编译"></a>3.2 条件编译</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>        <span class="comment">//判断某个宏是否被定义，若已定义，执行随后的语句</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>       <span class="comment">//与#ifdef相反，判断某个宏是否未被定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>           <span class="comment">//编译预处理中的条件命令，相当于C语法中的if语句</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span>         <span class="comment">//若#if,或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>         <span class="comment">//与#if对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>        <span class="comment">//#if,#ifdef,#ifndef,这些条件命令的结束标志</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>      <span class="comment">//用于生成一个编译错误的消息，并停止编译</span></span></span><br></pre></td></tr></table></figure><p>条件编译的意义，实际工程中条件编译主要用于以下情况：</p><ol><li>不同的产品线公用一份代码</li><li>区分编译产品的调试版和发布版</li><li>方便变动程序，例如不同的软件驱动方式</li></ol><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> Test_Version_Enable</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"The version is a test version,please try it to be unable"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="四、函数的设计技巧"><a href="#四、函数的设计技巧" class="headerlink" title="四、函数的设计技巧"></a>四、函数的设计技巧</h1><ul><li>参数名要能够体现参数意义</li><li>如果说传递的参数为指针，且仅仅作输入参数用，则应在类型前加const，以防止该指针在函数体内被恶意修改</li><li>不要省略返回值的类型，如果函数没有返回值，那么应当声明为void</li><li>在函数体的“入口处”，对参数的有效性进行检查，对指针的检查尤为重要</li><li>语句不可返回指向“栈内存”的“指针”，因为该内存会在函数结束后销毁</li><li>相同的输入应当产生相同的输出，尽量避免函数带有“记忆”功能少用static</li><li>避免函数有太多的参数，参数个数应当控制在4个以内</li><li>有时候函数不需要返回值，但是增加灵活性，可以附加返回值</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;无情的搬砖机器&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://shatang.github.io/categories/C/"/>
    
    
      <category term="关键字" scheme="http://shatang.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="符号" scheme="http://shatang.github.io/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="预处理" scheme="http://shatang.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="函数" scheme="http://shatang.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>迟来的总结</title>
    <link href="http://shatang.github.io/2020/03/14/%E8%BF%9F%E6%9D%A5%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://shatang.github.io/2020/03/14/迟来的总结/</id>
    <published>2020-03-14T06:01:24.000Z</published>
    <updated>2020-03-14T06:04:28.097Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近真的是，又懒又菜啊！整理这么久= =</p><img src="/2020/03/14/迟来的总结/1.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近真的是，又懒又菜啊！整理这么久= =&lt;/p&gt;
&lt;img src=&quot;/2020/03/14/迟来的总结/1.jpg&quot;&gt;
      
    
    </summary>
    
    
      <category term="生活" scheme="http://shatang.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://shatang.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>计划整理</title>
    <link href="http://shatang.github.io/2020/02/06/%E8%AE%A1%E5%88%92%E6%95%B4%E7%90%86/"/>
    <id>http://shatang.github.io/2020/02/06/计划整理/</id>
    <published>2020-02-06T04:05:49.000Z</published>
    <updated>2020-02-13T09:20:00.843Z</updated>
    
    <content type="html"><![CDATA[<p>作为备忘录，记录自己要做的事情</p><a id="more"></a><ol><li><p>11点睡觉</p></li><li><p>健身，跑步</p></li><li><p>时常要审视自己:对熟人的态度，对陌生人的态度</p></li><li><p>linux</p></li><li><p>ucosii</p></li><li><p>有道云笔记c语言整理</p></li><li><p>学习github代码管理</p></li><li><p>嵌入式C_博文改进：结构体成员指针初始化问题，看收藏，或者第一本笔记</p></li><li><p>modbus通讯_博文改进<br>(1)Modbus从机<br>(2)Modbus主机<br>(3)Modbus通讯例子</p></li><li><p>中断_定时器_博文改进：<br>(1)待增加线程任务<br>(2)定时器延时的副作用，轮询，扫描按键作为举例</p></li><li><p>Keil软件配置_博文改进：增加github上传处理</p></li><li><p>TCP/IP博文 差驱动</p></li><li><p>英文 注释 perip 外围 param 参数 offset 偏移  backups 备份 宏定义尝试修改SPI meset panel</p></li><li><p>IO口自定义管脚博文</p></li><li><p>ADC转换带滤波博文（未来）（IF（实际重量》最大量程+9*分度） ofl）</p></li><li><p>leetcode</p></li></ol><p>modbus通讯暂时</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为备忘录，记录自己要做的事情&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IO口配置</title>
    <link href="http://shatang.github.io/2020/01/14/IO%E5%8F%A3%E9%A9%B1%E5%8A%A8/"/>
    <id>http://shatang.github.io/2020/01/14/IO口驱动/</id>
    <published>2020-01-14T15:21:11.000Z</published>
    <updated>2020-02-12T02:41:11.201Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;该篇为基本IO配置，其思路适用于任意款MCU</p><a id="more"></a><h1 id="一、STM32四种管脚模式对比"><a href="#一、STM32四种管脚模式对比" class="headerlink" title="一、STM32四种管脚模式对比"></a>一、STM32四种管脚模式对比</h1><ol><li>普通推挽输出（ GPIO_Mode_Out_PP ） :<br><code>使用场合</code>：一般用在0V 和 3.3V 的场合。线路经过两个P_MOS和 N_MOS管，负责上拉和下拉电流。<br><code>使用方法</code>：直接使用<br><code>输出电平</code>：推挽输出的低电平是 0V，高电平是 3.3V。</li><li>普通开漏输出（ GPIO_Mode_Out_OD ）：<br><code>使用场合</code>：一般用在电平不匹配的场合，如需要输出 5V 的高电平。使用方法：就需要再外部接一个上拉电阻，电源为5V，把 GPIO设置为开漏模式，当输出高组态时，由上拉电阻和电源向外输出5V 的电压。<br><code>输出电平</code>：在开漏输出模式时，如果输出为0，低电平，则使 N_MOS导通，使输出接地。若控制输出为 1（无法直接输出高电平）， 则既不输出高电平也不输出低电平， 为高组态。为正常使用，必须在外部接一个上拉电阻。<br><code>特性</code>： 它具“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态， 才由上拉电阻提供高电平 ， 此高电平的 电压 为外部 上拉电阻所接的 电源 的电压。若其中一个引脚为低电平，那线路就相当于短路 接地 ，使得整条线路都为低电平，0 V。</li><li>复用推挽输出（ GPIO_Mode_AF_PP ） : 用作串口的输出。</li><li>复用开漏输出（ GPIO_Mode_AF_OD ）：用在 IIC 。</li></ol><p><strong><font color="red">Ps：</font>所有的开漏输出都需要接上拉电阻</strong></p><h1 id="二、IO-按键-输入消抖"><a href="#二、IO-按键-输入消抖" class="headerlink" title="二、IO(按键)输入消抖"></a>二、IO(按键)输入消抖</h1><p>&emsp;&emsp;IO(按键)输入的消抖，往往是嵌入式开发的排名前几门基础课。消抖方法分为2种：1)硬件消抖； 2)软件消抖；这里就不讲解硬件消抖方式，主要讲软件消抖；</p><p>软件消抖也分为2种: </p><ol><li>死循环延迟消抖 </li><li>定时器轮询消抖；</li></ol><p>这里讲解采用定时器轮询消抖方式。</p><ol><li>定时器轮询消抖有什么好处？</li><li>那 定时器轮询消抖 需要什么？</li><li>实现思路、功能分层？</li></ol><p><strong><font color="red">Ps：</font></strong>轮询的好处：IO(按键)输入的响应速度，直接与(裸机)系统效率挂钩；一旦其他地方出现问题，程序bug存在可以影响到IO(按键)输入的响应速度；采用轮询机制，在MCU从裸机移植到系统上，也会是十分便利</p><ol><li>定时器轮询消抖的好处：很明显，相对死循环延迟，定时器轮询 不会空白占用浪费CPU的资源</li><li>定时器消抖需要一个定时器；往往在MCU系统中，一般有公用基准1ms的定时器，用于各类操作，直接采用该定时器即可</li><li>实现思路、功能分层？以下均为实现功能的函数<br>1)(基本的)IO口初始化配置<br>2)无消抖 单输入(按键)扫描<br>3)消抖处理：循环调用 无消抖单输入扫描；每次程序重新轮询一次，检查现电平状态相比之前是否翻转；翻转则重新备份时间(采取定时器当前时间)，利用备份时间和当前时间 计算出来的时间差，实现延时消抖；</li></ol><h1 id="三、IO口自定义功能"><a href="#三、IO口自定义功能" class="headerlink" title="三、IO口自定义功能"></a>三、IO口自定义功能</h1><p>&emsp;&emsp;IO口自定义是一个在基础功能外扩展的功能；当我们有一定量的IO(按键)输入和输出时，哪个输入(按键)往往都制定好什么功能，输出IO也根据程序条件判断做对应操作；举个例子，当我们想把A键的功能和B键的功能互挪，我们就需要重新更改固件程序；IO口自定义，可以实现无需更改固件程序，直接在线更改输入输出管教功能。</p><p>实现思路如下：<br>&emsp;&emsp;将各种功能以枚举的方式罗列出来；利用数组的方式，将 <code>IO口[功能]</code> 和 <code>功能[IO口]</code> 两个数组，相互映射；先由 IO口 映射到 功能 去 ，程序只根据条件变动 功能 ，然后再 功能 映射回 IO口 ，实现底层的电平操作</p><blockquote><p>以下为实现IO口自定义功能的细节：</p></blockquote><p>1)额外设计掉电储存功能；因为当你设置好每个按键功能后，如果掉电不保存，则每次重新上电需要重新设置功能；<br>2)程序上电初始化，先进行IO口初始化；然后再进行IO口自定义初始化：从掉电存储读取IO功能，更新到对应的IO口；每次更新功能，存储一次对应掉电数据，读取数据只在重新上电初始化执行一次；<br>3)自定义功能复位；每个可自定义功能的IO口，原本就该有自带的默认功能，然后根据需求再改动，对应的，也要有复位默认功能的操作；</p><blockquote><p>数据掉电保存方法</p></blockquote><p>1)外扩额外的ROM(例：24C02)<br>2)基于备份寄存器<br><strong><font color="red">特点：</font>备份寄存器是依赖者备份电源的</strong>，当外界的VDD掉电，只要系统的VBAT能正常存在，那么<code>Bakeup Domaain Registers</code>的内容可以被正常保存起来。<br>3)基于内部闪存<br><strong><font color="red">原理：</font></strong>FLASH 存储器又称为闪存，它也是可重复擦写的储器。它分为 NOR FLASH 和 NAND FLASH，NOR FLASH一般应用在代码存储的场合，如嵌入式控制器内部的程序存储空间；而 NAND FLASH 一般应用在大数据量存储的场合，如U 盘以及固态硬盘等，一般都是 NAND FLASH 类型的。</p><p>&emsp;&emsp;在stm32芯片中，Flash的读写单位都是以“页”为单位的，以STM32F103C8T6为例，它的每页大小为2K bytes;<br><strong>读写保护解除</strong>：使用这种方法前提是，当前Flash页的读和写是允许的。</p><p><strong><font color="red">特点：</font></strong>使用该方法，相对比较复杂。但是由于保存数据以页为单位，页的大小可以多达2048bytes，所以该方法可以实用于保存掉电不易失的大数据。考虑到flash读写保护的逻辑机制，该方法最好在不考虑数据的安全性问题前提下，才使用这种方法。 </p><h1 id="四、预置点"><a href="#四、预置点" class="headerlink" title="四、预置点"></a>四、预置点</h1><h2 id="4-1-常规预置点"><a href="#4-1-常规预置点" class="headerlink" title="4.1 常规预置点"></a>4.1 常规预置点</h2><h2 id="4-2-优化预置点"><a href="#4-2-优化预置点" class="headerlink" title="4.2 优化预置点"></a>4.2 优化预置点</h2><h1 id="五、IO辅助逻辑"><a href="#五、IO辅助逻辑" class="headerlink" title="五、IO辅助逻辑"></a>五、IO辅助逻辑</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;该篇为基本IO配置，其思路适用于任意款MCU&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="STM32" scheme="http://shatang.github.io/tags/STM32/"/>
    
      <category term="IO口" scheme="http://shatang.github.io/tags/IO%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>STM32开发</title>
    <link href="http://shatang.github.io/2020/01/09/STM32%E5%BC%80%E5%8F%91/"/>
    <id>http://shatang.github.io/2020/01/09/STM32开发/</id>
    <published>2020-01-09T15:37:55.000Z</published>
    <updated>2020-03-19T12:18:51.606Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;水平有限，可能其中也有错误，希望各位大佬提醒和海涵</p><a id="more"></a><h1 id="一、硬件IO驱动异常"><a href="#一、硬件IO驱动异常" class="headerlink" title="一、硬件IO驱动异常"></a>一、硬件IO驱动异常</h1><p>&emsp;&emsp;Bug现象：刚写一个 功能(驱动)，出现异常；经过多次排查后，发现是硬件IO驱动初始化(部分IO异常)的问题。<br>问题来源：</p><ol><li>时钟使能问题；</li><li>该管脚为(默认)复用管脚；</li></ol><h2 id="1-1-宏定义错误"><a href="#1-1-宏定义错误" class="headerlink" title="1.1 宏定义错误"></a>1.1 宏定义错误</h2><p>&emsp;&emsp;其实在STM32库(其他芯片也是)，<strong>库函数初始化中的所有选项， 均为(寄存器)<font color="red">宏定义</font>  的一个特殊数值</strong>；具体例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); <span class="comment">//使能 GPIOB端口 时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); <span class="comment">//使能 串口2 时钟</span></span><br></pre></td></tr></table></figure><p>很明显，上面两行代码的时钟使能是错误的，但是编译是不会报错的；因为本质上就是一个赋值操作，赋错值并不会产生报错，除非类型不同、宏定义名称查询不到。不单单是IO的驱动，不管是什么驱动，大家在配置底层驱动的时候一定要细心，配置错误不一定会报警，但是会卡住你。</p><h2 id="1-2-关闭JTAG功能当普通IO口用"><a href="#1-2-关闭JTAG功能当普通IO口用" class="headerlink" title="1.2 关闭JTAG功能当普通IO口用"></a>1.2 关闭JTAG功能当普通IO口用</h2><p>&emsp;&emsp;例如：PA15是个复用引脚；关闭JTAG功能，把PA15当作普通IO口使用就行了。而下载调试程序就要使用SWD功能（平常应该都是用的SWD下载调试）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//使能复用时钟</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);<span class="comment">//关闭jtag，使能SWD，可以用SWD模式调试</span></span><br></pre></td></tr></table></figure><p><strong><font color="red">划重点</font>：初始化中，必须使能  复用端口<code>RCC_APB2Periph_AFIO</code>的时钟  才能对应关闭JTAG功能</strong></p><h1 id="二、STM32管脚四种输出模式对比"><a href="#二、STM32管脚四种输出模式对比" class="headerlink" title="二、STM32管脚四种输出模式对比"></a>二、STM32管脚四种输出模式对比</h1><ul><li>普通推挽输出（ GPIO_Mode_Out_PP ） :<ul><li><code>使用场合</code>：一般用在0V 和 3.3V 的场合。线路经过两个P_MOS和 N_MOS管，负责上拉和下拉电流。</li><li><code>使用方法</code>：直接使用</li><li><code>输出电平</code>：推挽输出的低电平是 0V，高电平是 3.3V。</li></ul></li><li>普通开漏输出（ GPIO_Mode_Out_OD ）：<ul><li><code>使用场合</code>：一般用在电平不匹配的场合，如需要输出 5V 的高电平。使用方法：就需要再外部接一个上拉电阻，电源为5V，把 GPIO设置为开漏模式，当输出高组态时，由上拉电阻和电源向外输出5V 的电压。</li><li><code>输出电平</code>：在开漏输出模式时，如果输出为0，低电平，则使 N_MOS导通，使输出接地。若控制输出为 1（无法直接输出高电平）， 则既不输出高电平也不输出低电平， 为高组态。为正常使用，必须在外部接一个上拉电阻。</li><li><code>特性</code>： 它具“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态， 才由上拉电阻提供高电平 ， 此高电平的 电压 为外部 上拉电阻所接的 电源 的电压。若其中一个引脚为低电平，那线路就相当于短路 接地 ，使得整条线路都为低电平，0 V。</li></ul></li><li>复用推挽输出（ GPIO_Mode_AF_PP ） : 用作串口的输出。</li><li>复用开漏输出（ GPIO_Mode_AF_OD ）：用在 IIC 。</li></ul><p><strong><font color="red">Ps：</font>所有的开漏输出都需要接上拉电阻</strong></p><h1 id="三、中断"><a href="#三、中断" class="headerlink" title="三、中断"></a>三、中断</h1><p>&emsp;&emsp;中断的概念具体就不赘述，这里以stm32F103RBT6芯片为例讲中断配置</p><h2 id="3-1-抢占优先级和响应优先级"><a href="#3-1-抢占优先级和响应优先级" class="headerlink" title="3.1 抢占优先级和响应优先级"></a>3.1 抢占优先级和响应优先级</h2><p>&emsp;&emsp;STM32的中断向量具有两个属性，一个为抢占属性，另一个为响应属性，其属性编号越小，表明它的优先级别越高。<br>&emsp;&emsp;<strong>抢占</strong>，是指打断其他中断的属性，即因为具有这个属性会出现嵌套中断（在执行中断服务函数A 的过程中被中断B打断，执行完中断服务函数B，再继续执行中断服务函数A），抢占属性由NVIC_IRQChannelPreemptionPriority 的参数配置。<br>&emsp;&emsp;<strong>响应</strong>，应用在抢占属性相同的情况下，当两个中断向量的抢占优先级相同时，如果两个中断同时到达，则先处理响应优先级高的中断， 响应属性由NVIC_IRQChannelSubPriority 参数配置。<br>&emsp;&emsp;<strong>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行</strong></p><h2 id="3-2-NVIC-的优先级组"><a href="#3-2-NVIC-的优先级组" class="headerlink" title="3.2 NVIC 的优先级组"></a>3.2 NVIC 的优先级组</h2><p>&emsp;&emsp;STM32的NVIC 有十六个优先级<br><strong>（一）STM32分组为：组0-4</strong><br><strong>（二）分组配置在寄存器SCB-&gt;AIRCR中：</strong></p><img src="/2020/01/09/STM32开发/0.png" title="中断优先级分组"><p><strong>（三）解析第二点</strong></p><ol><li>组0就是4位都用来设置成响应优先级，2^4=16位都是响应优先级</li><li>组1分为（2^1）两个抢占优先级，在这两个抢占优先级里面还分别有（2^3）八个响应优先级，（2^1） * （2^3） =16</li><li>组2分为（2^2）四个抢占优先级，在这四个抢占优先级里面还分别有（2^2）四个响应优先级，（2^2） * （2^2） =16</li><li>组3分为（2^3）八个抢占优先级，在这八个抢占优先级里面还分别有（2^1）两个响应优先级，（2^3） * （2^1） =16</li><li>组4分为（2^4）十六个都是抢占优先级  （2^4） =16</li></ol><p><strong>（四）配置示例</strong></p><ol><li>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级</li><li>也就是说可以配置成四个抢占优先级，在这四个抢占优先级中还可以配置四个响应优先级</li></ol><p><strong>（五）优先级顺序举例</strong><br>&emsp;&emsp;假定设置中断优先级组为2，然后设置<br>中断3(RTC中断)的抢占优先级为2，响应优先级为1<br>中断6（外部中断0）的抢占优先级为3，响应优先级为0<br>中断7（外部中断1）的抢占优先级为2，响应优先级为0。<br>&emsp;&emsp;那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6</p><h1 id="四、定时器"><a href="#四、定时器" class="headerlink" title="四、定时器"></a>四、定时器</h1><p>&emsp;&emsp;STM32 的高级定时器TIM1, TIM8以及通用定时器TIM9, TIM10, TIM11的时钟来源是APB2总线;通用的 TIM2、TIM3、TIM4 和 TIM5 定时器 挂载在低速的APB1总线上。</p><h2 id="4-1-时钟疑问"><a href="#4-1-时钟疑问" class="headerlink" title="4.1 时钟疑问"></a>4.1 时钟疑问</h2><p><strong><font color="red">疑问：</font></strong>以F103为例，APB1 提供时钟：他的最大值是 36M。有很多人不理解，为什么 TIM2 的时钟不是 36M 而是 72M呢？<br><strong>通用定时器（TIM2-7）的时钟不是直接来自APB1，而是通过APB1的预分频器以后才到达定时器模块</strong></p><p>APB1 的时钟最大只能是 36M,在 RCC 时钟配置的函数，也就是程序最开始初始化系统时钟到 72M（AHB）的时候,里面有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_PPRE1_DIV2;</span><br></pre></td></tr></table></figure><p>除以了 2，也就是在我们配置 AHB 为 72M 的时候 APB1 是 72/2=36M. 根据当APB1的预分频系数为1 时，这个倍频器不起作用，定时器的时钟频率等于 APB1 的频率；当 APB1 的预分频系数为其它数值(即预分频系数为 2、4、8 或 16)时，这个倍频器起作用，定时器的时钟频率等于 APB1 的频率两倍。这里我们设置的是 2，那么到定时器就要乘以 2，那么就是 72M 了</p><p>&emsp;&emsp;综上，通用定时器的时钟最大为72MHz，挂在APB1上除了通用定时器的其他外设时钟最大为36MHz。这样设计的目的就是让挂在APB1上的低速外设有合适的低速时钟，同时还可以让挂在APB1上的通用定时器能够在不影响低速外设的情况下仍然有高速的时钟。<br>(注：系统时钟初始化后，默认AHB是72MHz，APB1是AHB的2分频36MHz，通用定时器时钟是APB1的两倍72MHz)</p><h2 id="4-2-定时器计时"><a href="#4-2-定时器计时" class="headerlink" title="4.2 定时器计时"></a>4.2 定时器计时</h2><p>&emsp;&emsp;定时器跟时间相关的量有：系统时钟、分频系数、重装载值</p><p><strong>系统时钟:</strong> 默认不配置的时候是72M，可以根据自己需求配置；<br><strong>分频系数:</strong> psc,就是对系统时钟进行多少分频之后在使用，最好设置为72的倍数，方便运算；<br><strong>重新装载值:</strong> arr,是计算这么多值，时间到了之后重新开始计算的值，每一次计数的时间为分频之后时钟的到时；</p><p>举例：假设系统时间72M，分频系数设置为7200-1，那现在定时器的时钟为10kHz，每计一个数花费1/（10000）秒，重装值设置为5000-1，那一次溢出的时间为500ms。</p><p><strong>Time = （（period+1）*（prescaler+1））/sysclock</strong><br><code>time：溢出时间(MHz)</code><br><code>sysclock：系统时钟（us）</code><br><code>period：重装值</code><br><code>prescaler：分频系数</code></p><p>time = ((4999+1)*(7199+1))/72 = 5000 000us = 500ms</p><h2 id="4-3-计时拓展"><a href="#4-3-计时拓展" class="headerlink" title="4.3 计时拓展"></a>4.3 计时拓展</h2><p>&emsp;&emsp;定时器的计时可以采用 任务机制回调；<br>实现思路如下：</p><ol><li><p>创建结构体数组，用于存放 多定时器任务 数据；结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">块注释：结构体定义声明</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> Time_task_name;<span class="comment">//任务名称（组名称或上ID号码）</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> Time_Out;<span class="comment">//超时时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> Time_Count;<span class="comment">//任务启动为止到当前的时间</span></span><br><span class="line">FUNCTION*  callback_F;<span class="comment">//回调函数</span></span><br><span class="line">&#125;TIMER_TASK;<span class="comment">//定义添加执行任务所需要的数据</span></span><br></pre></td></tr></table></figure></li><li><p>创建任务需要：任务名称，设定时间，回调函数名；</p></li><li><p>定时器中断会循环检索任务的存在；如果任务存在则对应的Time_Count(任务计时)++；如果Time_Count和Time_Out(设定时间)相同，则重置Time_Count，并执行回调；</p></li><li><p>回调函数一般短小精悍，因为是在中断内处理；用于置某些标志位或者关闭自身定时器任务</p></li></ol><p>实现具体细节如下(均为功能函数)：</p><ol><li>创建某个定时器任务</li><li>复位某个定时器任务</li><li>清除某个定时器任务(一般在回调函数中使用)</li><li>清除全体定时器任务</li><li>获取当前定时器计数(函数返回值)</li></ol><h1 id="五、串口通讯"><a href="#五、串口通讯" class="headerlink" title="五、串口通讯"></a>五、串口通讯</h1><p>&emsp;&emsp;这里讲串口一般会遇到的问题；</p><h2 id="5-1-TXE-和-TC"><a href="#5-1-TXE-和-TC" class="headerlink" title="5.1 TXE 和 TC"></a>5.1 TXE 和 TC</h2><p>&emsp;&emsp;串口的发送TX标志位 <code>USART_FLAG_TXE</code> 和 <code>USART_FLAG_TC</code>的理解:<br>1)<code>TXE</code>是指“手里要搬运的”空；<br>2)<code>TC</code> 是指“地上要搬运的”空；</p><p><code>USART_FLAG_TXE</code> 来说，只是说明数据寄存器中的数据已经被发送移位寄存器取走了<br><code>USART_FLAG_TC</code>来说，没必要每次当发送移位寄存器中的数据发送完成后都发生中断，而应该是整个串口数据帧全部发送完毕，包括最后一个字节也发送出去之后才应该开中断，这代表的就是一个数据帧发送完成事件了。</p><h2 id="5-2-不停进入串口中断的Bug"><a href="#5-2-不停进入串口中断的Bug" class="headerlink" title="5.2 不停进入串口中断的Bug"></a>5.2 不停进入串口中断的Bug</h2><p>&emsp;&emsp;Bug现象：在使用stm32的时候，发现usart会莫名的卡在串口中断里，然而串口初始化只配置了<code>RXNE</code>中断，打断点发现不断进入中断却发现不是<code>RXNE</code>中断引起的</p><blockquote><p>该Bug来源：经过查找资料发现是<code>ORE</code>的问题：开启<code>RXNE</code>中断同时， <code>ORE</code> 也会被开启；</p></blockquote><p>但是如果直接用 <code>USART_GetITStatus</code> 无法读取到<code>ORE</code>标志位 置位的信息，这样也就无法消除中断申请(不知道什么时候置位)，一直进入串口中断；因为我们没有使能<code>ORE</code>标志位，所以才读不到 置位 信息；故</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USART_ITConfig(USART1, USART_IT_ORE, ENABLE);</span><br></pre></td></tr></table></figure><p>然后在串口中断内做对应处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意！不能使用if(USART_GetITStatus(_UART_M, USART_IT_RXNE) != RESET)来判断</span></span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(_UART_M,USART_IT_ORE) != RESET)</span><br><span class="line">&#123;</span><br><span class="line">USART_ClearITPendingBit(_UART_M,USART_IT_ORE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STM32中文参考手册541页，内容如下：</p><blockquote><p>ORE：过载错误 (Overrun error)<br>当RXNE仍然是’1’的时候，当前被接收在移位寄存器中的数据，需要传送至RDR寄存器时，硬件将该位置位。如果USART_CR1中的RXNEIE为’1’的话，则产生中断。由软件序列将其清零(先读USART_SR，然后读USART_CR)。<br>0：没有过载错误；<br>1：检测到过载错误。<br>注意：该位被置位时， RDR寄存器中的值不会丢失，但是移位寄存器中的数据会被覆盖。如果设置了EIE位，在多缓冲器通信模式下，ORE标志置位会产生中断的</p></blockquote><p><a href="https://blog.csdn.net/origin333/article/details/49992383" target="_blank" rel="noopener">STM32串口中断卡死主循环问题分析</a><br><a href="https://bbs.21ic.com/icview-160999-1-1.html" target="_blank" rel="noopener">关于USART接收中断的BUG和注意事项</a><br><a href="https://www.cnblogs.com/tiantiantian-dianzi/articles/5952318.html" target="_blank" rel="noopener">关于STM32不断进入串口中断的问题</a></p><h1 id="六、程序跑飞"><a href="#六、程序跑飞" class="headerlink" title="六、程序跑飞"></a>六、程序跑飞</h1><p>&emsp;&emsp;程序跑飞有两种情况：1)人为程序代码逻辑问题；2)进入<code>HardFault_Handler</code><br>1)代码逻辑问题，往往是逻辑错误(缺少)，进入死循环；可以通过软件仿真，很快就能排查该问题<br>2)<code>HardFault_Handler</code>的问题比较麻烦，这里讲其相关的问题</p><h2 id="6-1-HardFault-Handler的原因"><a href="#6-1-HardFault-Handler的原因" class="headerlink" title="6.1 HardFault_Handler的原因"></a>6.1 HardFault_Handler的原因</h2><p>&emsp;&emsp;在用Keil对STM32的程序进行仿真时程序有时会跑飞，停止仿真程序会停在<code>HardFault_Handler</code>函数里的死循环while(1)中。这说明STM32出现了硬件错误。</p><img src="/2020/01/09/STM32开发/1.jpg"><blockquote><p>STM32出现硬件错误可能有以下原因：</p></blockquote><ol><li>数组越界操作；</li><li>内存溢出，访问越界；</li><li>堆栈溢出，程序跑飞；(大多数是因为中断嵌套)</li><li>中断处理错误；</li></ol><p>遇到这种情况，可以通过以下方法来定位到出错代码段。</p><h2 id="6-2-解决方法"><a href="#6-2-解决方法" class="headerlink" title="6.2 解决方法"></a>6.2 解决方法</h2><p>&emsp;&emsp;在<code>HardFault_Handler</code>函数中，一般为 C语言的 <code>While(1);</code> 或 汇编的 <code>B .</code> ，实际效果都一样(死循环)。</p><blockquote><p><strong>方法1</strong></p></blockquote><p>1.1 在硬件中断函数<code>HardFault_Handler</code>里的while(1)处打调试断点，程序执行到断点处时点击“STOP”停止仿真。</p><img src="/2020/01/09/STM32开发/2.jpg"><p>1.2 在Keil菜单栏点击“View”——“Registers Window”，在寄存器查看窗口查找R14(LR)的值。如果R14(LR) = 0xFFFFFFE9，继续查看MSP（主堆栈指针）的值，如果R14(LR) = 0xFFFFFFFD，继续查看PSP（进程栈指针）的值。我的程序R14(LR) = 0xFFFFFFF9，接下来以此为例。</p><img src="/2020/01/09/STM32开发/3.png"><p>1.3 在Keil菜单栏点击“View”——“Memory Windows”——“Memory1”，在“Address”地址栏中输入MSP的值：0x20001288，然后在对应的行里找到地址。地址一般以0x08开头的32位数。本例中，地址为0x08003CB9。</p><img src="/2020/01/09/STM32开发/4.png"><p>1.4 在Keil菜单栏点击“View”——“Disassembly Window”，在“Disassembly”窗口中右击，在下拉菜单中选择“Show Disassemblyat Address…”。在弹出框“Show Code atAdress”的地址框中输入地址0x08003CB9进行搜索，然后就会找到相对应的代码。这里的代码就是进入循环中断之前的情况。仔细查看附近区域的相关代码来排查错误具体原因。</p><img src="/2020/01/09/STM32开发/5.jpg"><blockquote><p><strong>方法2</strong></p></blockquote><p>2.1 在硬件中断函数HardFault_Handler里的while(1)处打调试断点，程序执行到断点处时点击“STOP”停止仿真。</p><img src="/2020/01/09/STM32开发/6.jpg"><p>2.2 在Keil菜单栏点击“View”——“Call Stack Window”弹出“Call Stack + Locals”对话框。然后在对话框中右键选择“Show Caller Code”，就会跳转到出错之前的函数处，仔细查看这部分函数被调用或者数组内存使用情况。</p><blockquote><p><strong>方法3</strong></p></blockquote><p>&emsp;&emsp;默认的HardFault_Handler处理方法不是B .这样的死循环么？将它改成<code>BX LR</code>直接返回的形式，然后在这条语句打个断点；<br>一旦在断点中停下来，说明出错了，然后再返回，就可以返回到出错的位置的下一条语句那儿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function"><span class="keyword">asm</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">BX lr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HardFault_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="comment">/* Go to infinite loop when Hard Fault exception occurs */</span>   </span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-具体案例分析"><a href="#6-3-具体案例分析" class="headerlink" title="6.3 具体案例分析"></a>6.3 具体案例分析</h2><p>&emsp;&emsp;这里介绍 不断进入串口中断的问题分析，提供一种(遇到其他Bug时也可以借鉴)思路<br>现象：使用STM32作为主控，程序运行一段时间后概率出现主循环卡死。问题分析和解决方法如下：</p><ol><li>主循环卡死；</li><li>仿真并未进入<code>HardFault</code>；</li><li>仿真一直死循环在USART2中断处理(不做其他处理)</li><li>关闭对应USART2功能，系统正常</li><li>检查USART2接收中断标志是否忘记清除；</li><li>确认好Bug来自于STM32串口中断异常</li></ol><p>确认Bug来自于STM32串口中断异常，可能原因如下：<br>7.1 USART2接收中断标志没有清除；<br>7.2 堆栈数据溢出，导致程序异常；<br>7.3 USART2中断ERR；<br>7.4 USART2中断重入导致异常；<br>7.5 USART2中断函数被异常响应；</p><p>综上所述：<br>8.1 开始面向X度编程  or<br>8.2 查看STM32中文参考手册 串口章节</p><h1 id="七、UCOSIII系统"><a href="#七、UCOSIII系统" class="headerlink" title="七、UCOSIII系统"></a>七、UCOSIII系统</h1><h2 id="7-1-把一个裸机程序移植到ucos系统"><a href="#7-1-把一个裸机程序移植到ucos系统" class="headerlink" title="7.1 把一个裸机程序移植到ucos系统"></a>7.1 把一个裸机程序移植到ucos系统</h2><ol><li>先把裸机任务改一个名字；先在芯片上把ucos跑起来，启动一个ucos任务调用裸机的main函数就可以了；</li><li>先都放在一个进程中，再慢慢剥离到其他进程;想要优化程序的话你就将原来裸机的程序分成几个任务，再按照每个任务的重要性选择任务优先级和大小以及任务执行间隔。</li><li>清理原来的程序，区分出任务和任务间通信的数据；把任务按一定的优先级整理好，创建到UCOS中；再把任务间通信的数据，采用UCOS提供的：信号量、锁，队列等，机制建立起来。</li><li>然后，把任务和数据关联起来，再进一步调试，跑系统。特别注意有没有优先级反转、死机，任务饥饿等问题</li></ol><h1 id="八、Bootloader"><a href="#八、Bootloader" class="headerlink" title="八、Bootloader"></a>八、Bootloader</h1><p>&emsp;&emsp;一个成熟的嵌入式产品，往往有 软件升级 的功能；升级的功能 需要用到Bootloader。<br><strong><font color="red">Ps：</font></strong>BootLoader的实现还是需要靠BootLoader程序和App程序的配合才能正常使用：App程序需要重定位中断向量表，才能正常工作。</p><p>对于嵌入式系统来说，常见的升级方式为:<br>1)串口升级(私有协议或者X－Modem)<br>2)USB升级(DFU)<br>3)U盘升级(OTG)<br>4)网络升级<br>5)无线升级(OTA)</p><h2 id="8-1-hex文件和bin文件"><a href="#8-1-hex文件和bin文件" class="headerlink" title="8.1 hex文件和bin文件"></a>8.1 hex文件和bin文件</h2><p>&emsp;&emsp;Bootloader程序升级，往往是采用写入bin文件；那hex文件和bin文件有什么关系呢？</p><blockquote><p><strong>hex文件</strong></p></blockquote><p>&emsp;&emsp;hex文件是以ASCII文本形式保存编译后的二进制文件信息。Hex文件使用ASCII文本的形式保存Bin文件的内容和Bin文件的一些配置信息。hex文件可以由下载器（比如jlink）烧写到MCU的ROM中。<br>&emsp;&emsp;平时用J-LINK或者串口下载程序，都是下载hex文件的;因为hex文件包含地址信息，下载程序的时候知道程序下载到ROM的哪个区域。反过来讲，hex文件是不能直接写进ROM的，一边写需要一边转换(解码出地址信息，将对应内容写入ROM)。</p><blockquote><p><strong>bin文件</strong></p></blockquote><p>&emsp;&emsp;Bin文件是MCU固件烧写的最终形式，也就是说MCU的ROM中烧写的内容完全就是Bin文件的内容。</p><blockquote><p><strong>区别</strong></p></blockquote><p>&emsp;&emsp;Hex文件有更好的可读性，最重要的是hex文件能够保证固件在保存与传输时的完整性。因此hex文件更适用于保存与传输。而Bin文件是纯二进制文件，内部只包含程序编译后的机器码和变量数据。当文件损坏时，我们也无法知道文件已损坏。不过Bin文件作为固件的最终形式，在使用串口下载程序或者远程升级时，是不可替代的。</p><blockquote><p><strong>bin文件生成</strong></p></blockquote><p>&emsp;&emsp;默认情况下编译后生成的是hex文件，没有生成bin文件。keil的Bin文件生成方式有很多种，可以另外下载一个hex2bin工具，然后用Keil脚本执行；这里，介绍使用Keil自带的工具fromelf.exe。在Keil的安装目录下，例如：<code>E:\Keil\ARM\ARMCC\bin\fromelf.exe</code></p><p>第一种方式：设置绝对路径(不建议这样做，别人用你工程需要再次修改路径)</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">MDK516</span>\<span class="title">ARM</span>\<span class="title">ARMCC</span>\<span class="title">bin</span>\<span class="title">fromelf.exe</span>" --<span class="title">bin</span> -<span class="title">o</span> ./<span class="title">obj</span>/<span class="title">test_app.bin</span> ./<span class="title">obj</span>/<span class="title">test_app.axf</span></span></span><br></pre></td></tr></table></figure><p>第二种方式：相对路径，直接复制下面的路径就能直接使用</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$K\ARM\ARMCC\bin\fromelf.exe --bin --output=@L.bin !L</span><br></pre></td></tr></table></figure><p>bin文件生成在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下你可看到一个test1.bin（名字是根据你的hex文件名字一样）。</p><p>希望生成.bin文件输出在当前工程下的指定目录，比如Bin文件夹，可如下操作：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$K\ARM\ARMCC\bin\fromelf.exe --bin --output=Bin\@L.bin !L</span><br></pre></td></tr></table></figure><p>生成的文件也是在xxx.uvprojx的当前目录下，在xxx.uvprojx当前目录下，可看到一个新生成的Bin文件夹，里面是test1.bin。</p><h2 id="8-2-Flash地址0x08000000"><a href="#8-2-Flash地址0x08000000" class="headerlink" title="8.2 Flash地址0x08000000"></a>8.2 Flash地址0x08000000</h2><blockquote><p>为什么STM32从Flash地址0x08000000的启动重映射?</p></blockquote><p>&emsp;&emsp;在初写STM32程序时，遇到一个困惑，STM32的Flash在MDK里被设置为起始地址0x0800 0000，而CM3手册规定芯片复位时要从0x0000 0000地址开始取出中断向量 ，那STM32怎么样执行代码呢？地址重映射？或者在0x0000 0000里有对应有实际存储器？</p><p>仔细阅读手册，发现这件事是因为STM32设计的Flash起始地址是在0x0800 0000位置开始的。全部代码都只能从这里开始存储。详见STM32 referenc manual手册第54页。</p><p>那既然从这里才能存储代码，就必须在MDK里设置Flash地址为0x0800 0000，下面是MDK设置页面，这个应该都看到过。</p><img src="/2020/01/09/STM32开发/7.jpg"><p>&emsp;&emsp;这样就还有一个问题，理论上，CM3中规定上电后CPU是从0地址开始执行，但是这里中断向量表却被烧写在0x0800 0000地址里，那启动时不就找不到中断向量表了？既然CM3定下的规矩是从0地址启动，SMT32当然不能破坏ARM定下的“规矩”，所以它做了一个启动映射的过程，就是和芯片上总能见到的BOOT0和BOOT1有关了，当选择从主Flash启动模式后，芯片一上电，Flash的0x0800 0000地址被映射到0地址处，不影响CM3内核的读取，所以这时的CM3既可以在0地址处访问中断向量表，也可以在0x0800 0000地址处访问中断向量表，而代码还是在0x0800 0000地址处存储的。这就是最难理解的地方，其实，这是基本上所有ARM芯片采用的启动映射方法。ARM7，ARM9没有内部Flash的通常都是这样做的。这个过程出自STM32 referenc manual手册，里面是有说明的。</p><p>还要注意，<strong>这个中断向量表是可以在程序中再次被映射的</strong>。控制它的就是CM3已经规定的NVIC寄存器<code>SCB->VTOR</code>。在STM32库中给出的启动代码里，startup_stm32f10x_hd.s文件里，第146行，是上电后读取中断向量表中的复位中断位置，并执行复位中断处理代码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                LDR     R0, =SystemInit</span><br><span class="line">                BLX     R0               </span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><p> 注意复位后第一个被执行的是SystemInit代码，这个代码在库目录下的system_stm32f10x.c文件里，它初始化了时钟，NVIC等一系列操作，这里摘要与中断向量有关的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VECT_TAB_SRAM</span></span><br><span class="line">  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal SRAM. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal FLASH. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出中断向量重映射是一个选择性编译，通常宏定义<code>VECT_TAB_SRAM</code>都没有被定义，所以这里执行结束后，<code>SCB->VTOR</code>就是FLASH_BASE了，值为0x0800 0000。以后CM3再取中断向量里，就会根据<code>SCB->VTOR</code>的设置，从这里取向量执行了。中断向量自此终于转正。</p><p>注意：这时连__main函数都还没进，看起来中断向量的重映射位置还是够早的。</p><h2 id="8-3-Bootloader介绍"><a href="#8-3-Bootloader介绍" class="headerlink" title="8.3 Bootloader介绍"></a>8.3 Bootloader介绍</h2><p>&emsp;&emsp;源自linux上的BootLoader的概念，在linux上，BootLoader是首先执行的程序，BootLoader启动之后初始化CPU、RAM、Flash等设备，然后从Flash中读取Linux程序数据到RAM中去，最后跳转到RAM中Linux的起始地址中去启动Linux系统。除了从Flash中读取系统启动之外，BootLoader还能通过网络NFS协议从服务器上读取Linux并启动。BootLoader还能够更新Linux内核、配置Linux启动信息、测试系统等等。<br>&emsp;&emsp;在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像Window自带BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。</p><p>我们要做的STM32的BootLoader也是类似的工作原理，但是没有Linux系统的BootLoader功能那么强大。我们要做的STM32的BootLoader只有两个主要目的：</p><ol><li>跳转到应用程序并执行；</li><li>更新应用程序；</li></ol><p><strong><font color="red">Ps：</font></strong>因此，下载新程序后并不擦除bootLoader程序，下次启动依然先运行BootLoader程序，可以选择性更新或者不更新程序，所以STM32的BootLoader往往就是用来管理单片机程序的更新。</p><h2 id="8-4-Bootloader预备知识"><a href="#8-4-Bootloader预备知识" class="headerlink" title="8.4 Bootloader预备知识"></a>8.4 Bootloader预备知识</h2><h3 id="8-4-1-复位序列"><a href="#8-4-1-复位序列" class="headerlink" title="8.4.1 复位序列"></a>8.4.1 复位序列</h3><blockquote><p>栈指针<br>复位向量</p></blockquote><h3 id="8-4-2-重定位中断向量表"><a href="#8-4-2-重定位中断向量表" class="headerlink" title="8.4.2 重定位中断向量表"></a>8.4.2 重定位中断向量表</h3><blockquote><p>STM32的中断向量表<br>设置中断向量表偏移  </p></blockquote><h3 id="8-4-3-分散加载文件相关"><a href="#8-4-3-分散加载文件相关" class="headerlink" title="8.4.3 分散加载文件相关"></a>8.4.3 分散加载文件相关</h3><blockquote><p>C语言的函数地址<br>BootLoader占用的ROM<br>修改ROM起始地址</p></blockquote><h2 id="8-5-BootLoader的实现"><a href="#8-5-BootLoader的实现" class="headerlink" title="8.5 BootLoader的实现"></a>8.5 BootLoader的实现</h2><h2 id="8-8-Bin文件合并"><a href="#8-8-Bin文件合并" class="headerlink" title="8.8 Bin文件合并"></a>8.8 Bin文件合并</h2><p>需要烧录2个bin文件，整个程序才可以正常运行。那如果是量产烧录2次程序是非常耗时间的</p><p>目的：合并两个单独程序的bin文件<br>工具：keil，jlink，j-flash ARM</p><ol><li>用keil和jlink生成两个bin文件，如何生成不详细解释，主要是几个问题说明一下<br>1)使用jlink时需要注意，尤其是port的选择，明确用jlink是jtag还是sw。<br>2)既然是合并，那么两个bin文件的flash的地址分配需要明确</li><li>利用j-flash ARM合并bin文件<br>1)拖拽第一个文件进j-flash ARM，确定好初始地址<br>2)file–message data…–第二个文件，确定好初始地址<br>3)save data file as..保存合并后的文件</li><li>使用j-flash ARM进行程序下载<br>1)open project …选择芯片类型<br>2)Options-project setting 进行相关配置，明确用jlink是jtag还是sw。<br>3)注意芯片的选型。<br>参考资料：<a href="https://wenku.baidu.com/view/ae895065ddccda38376bafb5.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ae895065ddccda38376bafb5.html</a><br>#####pwm定时器脉冲</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;水平有限，可能其中也有错误，希望各位大佬提醒和海涵&lt;/p&gt;
    
    </summary>
    
    
      <category term="驱动编写" scheme="http://shatang.github.io/categories/%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    
    
      <category term="STM32" scheme="http://shatang.github.io/tags/STM32/"/>
    
      <category term="c" scheme="http://shatang.github.io/tags/c/"/>
    
  </entry>
  
</feed>
